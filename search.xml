<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>day25</title>
      <link href="/2023/05/15/shuati/day25/"/>
      <url>/2023/05/15/shuati/day25/</url>
      
        <content type="html"><![CDATA[<p>让网站更适合秋招好看一点吧，刷题记录本地有就行了。<br>不再上传。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081 Lab:Xv6 and Unix utilities</title>
      <link href="/2023/05/15/s081/lab1/"/>
      <url>/2023/05/15/s081/lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="lab-xv6-and-unix-utilities"><a class="markdownIt-Anchor" href="#lab-xv6-and-unix-utilities">#</a> Lab: Xv6 and Unix utilities</h1><h4 id="sleep"><a class="markdownIt-Anchor" href="#sleep">#</a> sleep</h4><p>函数的设计还是很简单的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: number should be given...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  sleep(n);</span><br><span class="line">  <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来刚开始写的是 return 0; 通过样例是没问题的，但是编译 OS 的时候再调用无法正常退出。</p><h3 id="查阅资料发现return和exit的区别还是蛮大的"><a class="markdownIt-Anchor" href="#查阅资料发现return和exit的区别还是蛮大的">#</a> 查阅资料发现，return 和 exit 的区别还是蛮大的。</h3><ol><li>exit 用于结束正在运行的整个程序，它将参数返回给 OS，把控制权交给操作系统；而 return 是退出当前函数，返回函数值，把控制权交给调用函数。</li><li>exit 是系统调用级别，它表示一个进程的结束；而 return 是语言级别的，它表示调用堆栈的返回。</li><li>在 main 函数结束时，会隐式地调用 exit 函数，所以一般程序执行到 main () 结尾时，则结束主进程。exit 将删除进程使用的内存空间，同时把错误信息返回给父进程。</li><li>void exit (int status); 一般 status 为 0，表示正常退出，非 0 表示非正常退出。</li></ol><h4 id="1-exit函数和return函数的主要区别是"><a class="markdownIt-Anchor" href="#1-exit函数和return函数的主要区别是">#</a> 1、exit 函数和 return 函数的主要区别是：</h4><p>1）exit 用于在程序运行的过程中随时结束程序，其参数是返回给 OS 的。也可以这么讲：exit 函数是退出应用程序，并将应用程序的一个状态返回给 OS，这个状态标识了应用程序的一些运行信息。</p><p>main 函数结束时也会隐式地调用 exit 函数，exit 函数运行时首先会执行由 atexit () 函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准 I/O 函数 tmpfile () 创建的临时文件。</p><p>exit 是系统调用级别的，它表示了一个进程的结束，它将删除进程使用的内存空间，同时把错误信息返回父进程。通常情况：exit (0) 表示程序正常，exit (1) 和 exit (-1) 表示程序异常退出，exit (2) 表示系统找不到指定的文件。在整个程序中，只要调用 exit 就结束。</p><p>2）return 是语言级别的，它表示了调用堆栈的返回；return 是返回函数值并退出函数，通常 0 为正常退出，非 0 为非正常退出，请注意，如果是在主函数 main, 自然也就结束当前进程了（也就是说，在 main () 里面，你可以用 return n，也能够直接用 exit (n) 来做），如果不是在 main 函数中，那就是退回上一层调用。在多个进程时，如果有时要检测上个进程是否正常退出，就要用到上个进程的返回值。</p><h4 id="2-进程环境与进程控制"><a class="markdownIt-Anchor" href="#2-进程环境与进程控制">#</a> 2、进程环境与进程控制</h4><p>exit (int n) 其实就是直接退出程序，因为默认的标准程序入口为 int main (int argc, char** argv)，返回值是 int 型的。一般在 shell 下面，运行一个程序，然后使用命令 echo $? 就能得到该程序的返回值，也就是退出值。</p><p>理论上 exit 可以返回小于 256 的任何整数，返回的不同数值主要是给调用者作不同处理的。</p><p>对于单独的进程 exit 的返回值是返回给操作系统的，但如果是多进程，则是返回给父进程的。父进程里面调用 waitpid () 等函数得到子进程退出的状态，以便作不同处理。根据相应的返回值来让调用者作出相应的处理。</p><p>总的说来，exit（）就是当前进程把其控制权返回给调用该子程序的主程序，括号里的是返回值，告诉调用程序该程序的运行状态。</p><h4 id="pingpong"><a class="markdownIt-Anchor" href="#pingpong">#</a> pingpong</h4><p>也还行，要注意管道 0 读 1 写，并且用不着哪边端口需要将其 close，用完的端口也要 close</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: create pipe number should be given one...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> p2[<span class="number">2</span>];</span><br><span class="line">  pipe(p1);</span><br><span class="line">  pipe(p2);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    close(p1[<span class="number">1</span>]);<span class="comment">//close p1 write</span></span><br><span class="line">    close(p2[<span class="number">0</span>]);<span class="comment">//close p2 read</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">10</span>];</span><br><span class="line">    read(p1[<span class="number">0</span>],buff, <span class="number">4</span>);</span><br><span class="line">    close(p1[<span class="number">0</span>]);</span><br><span class="line">    write(p2[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;pong&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buff);</span><br><span class="line">    close(p2[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    close(p1[<span class="number">0</span>]);<span class="comment">//close p1 write</span></span><br><span class="line">    close(p2[<span class="number">1</span>]);<span class="comment">//close p2 read</span></span><br><span class="line">    write(p1[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">    close(p1[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">10</span>];</span><br><span class="line">    read(p2[<span class="number">0</span>],buff, <span class="number">4</span>);</span><br><span class="line">    close(p2[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buff);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prime"><a class="markdownIt-Anchor" href="#prime">#</a> prime</h4><p>这个题细心阅读他给的文档就行了</p><p>这个解决思路就是每一次筛一个数的倍数，筛到给定的值就行了。</p><p>递归解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subProcess</span><span class="params">(<span class="type">int</span> *oldFd)</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭原管道写端</span></span><br><span class="line">    close(oldFd[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">// 若能从原管道读到数据</span></span><br><span class="line">    <span class="keyword">if</span> (read(oldFd[<span class="number">0</span>], &amp;prime, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">// 第一个数据为质数,进行输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">        <span class="comment">// 创建管道和子进程</span></span><br><span class="line">        pipe(fd);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;    <span class="comment">//子进程</span></span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            subProcess(fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 父进程</span></span><br><span class="line">            <span class="comment">// 关闭新管道读端</span></span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 从原管道进行读取</span></span><br><span class="line">            <span class="keyword">while</span> (read(oldFd[<span class="number">0</span>], &amp;num, <span class="number">4</span>)) &#123;</span><br><span class="line">                <span class="comment">// 不能被记录的质数整除则写入新管道</span></span><br><span class="line">                <span class="keyword">if</span> (num % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(fd[<span class="number">1</span>], &amp;num, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时父进程的原管道关闭, 则关闭原管道的读端</span></span><br><span class="line">            close(oldFd[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 关闭新管道的写端</span></span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 等待子进程结束</span></span><br><span class="line">            wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 此时说明原管道已关闭,第一个数字都读不出</span></span><br><span class="line">        <span class="comment">// 不创建子进程直接关闭原管道读端</span></span><br><span class="line">        close(oldFd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        subProcess(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 遍历 2~35 写入管道写端</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i) &#123;</span><br><span class="line">            write(fd[<span class="number">1</span>], &amp;i, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写完关闭管道写端并等待子进程结束</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="find"><a class="markdownIt-Anchor" href="#find">#</a> find</h4><p>参考 ls 的实现，就简单改一下，遍历当前路径下所有文件名，如果发现当前文件是一个文件夹，就递归下去，如果发现当前是一个文件并且文件名同所要查找的一样，那就输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(<span class="type">char</span> *dir, <span class="type">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 声明 文件名缓冲区 和 指针</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="comment">// 声明文件描述符 fd</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 声明与文件相关的结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open() 函数打开路径，返回一个文件描述符，如果错误返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(dir, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 报错，提示无法打开此路径</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, dir);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int fstat(int fd, struct stat *);</span></span><br><span class="line">    <span class="comment">// 系统调用 fstat 与 stat 类似，但它以文件描述符作为参数</span></span><br><span class="line">    <span class="comment">// int stat(char *, struct stat *);</span></span><br><span class="line">    <span class="comment">// stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本</span></span><br><span class="line">    <span class="comment">// stat 以文件名作为参数，返回文件的 i 结点中的所有信息</span></span><br><span class="line">    <span class="comment">// 如果出错，则返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出错则报错</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, dir);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是目录类型</span></span><br><span class="line">    <span class="keyword">if</span> (st.type != T_DIR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 报类型不是目录错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: %s is not a directory\n&quot;</span>, dir);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径过长放不入缓冲区，则报错提示</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(dir) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: directory too long\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 dir 指向的字符串即绝对路径复制到 buf</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, dir);</span><br><span class="line">    <span class="comment">// buf 是一个绝对路径，p 是一个文件名，通过加 &quot;/&quot; 前缀拼接在 buf 的后面</span></span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="comment">// 读取 fd ，如果 read 返回字节数与 de 长度相等则循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// strcmp(s, t);</span></span><br><span class="line">        <span class="comment">// 根据 s 指向的字符串小于（s&lt;t）、等于（s==t）或大于（s&gt;t） t 指向的字符串的不同情况</span></span><br><span class="line">        <span class="comment">// 分别返回负整数、0或正整数</span></span><br><span class="line">        <span class="comment">// 不要递归 &quot;.&quot; 和 &quot;...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// memmove，把 de.name 信息复制 p，其中 de.name 代表文件名</span></span><br><span class="line">        <span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">        <span class="comment">// 设置文件名结束符</span></span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int stat(char *, struct stat *);</span></span><br><span class="line">        <span class="comment">// stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本</span></span><br><span class="line">        <span class="comment">// stat 以文件名作为参数，返回文件的 i 结点中的所有信息</span></span><br><span class="line">        <span class="comment">// 如果出错，则返回 -1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 出错则报错</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是目录类型，递归查找</span></span><br><span class="line">        <span class="keyword">if</span> (st.type == T_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">find</span>(buf, file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是文件类型 并且 名称与要查找的文件名相同</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_FILE &amp;&amp; !<span class="built_in">strcmp</span>(de.name, file))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印缓冲区存放的路径</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果参数个数不为 3 则报错</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出提示</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: input should be three\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 find 函数查找指定目录下的文件</span></span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="xargs"><a class="markdownIt-Anchor" href="#xargs">#</a> xargs</h4><p>也还行，利用 fork 子进程然后 exec 执行命令就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果参数个数小于 2</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印参数错误提示</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: xargs command\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放子进程 exec 的参数</span></span><br><span class="line">    <span class="type">char</span> * argvs[MAXARG];</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 略去 xargs ，用来保存命令行参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        argvs[index++] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓冲区存放从管道读出的数据</span></span><br><span class="line">    <span class="type">char</span> buf[MAXN] = &#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="comment">// 0 代表的是管道的 0，也就是从管道循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span>((n = read(<span class="number">0</span>, buf, MAXN)) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 临时缓冲区存放追加的参数</span></span><br><span class="line"><span class="type">char</span> temp[MAXN] = &#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// xargs 命令的参数后面再追加参数</span></span><br><span class="line">        argvs[index] = temp;</span><br><span class="line">        <span class="comment">// 内循环获取追加的参数并创建子进程执行命令</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(buf); ++i) &#123;</span><br><span class="line">            <span class="comment">// 读取单个输入行，当遇到换行符时，创建子线程</span></span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建子线程执行命令</span></span><br><span class="line">                <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                    exec(argv[<span class="number">1</span>], argvs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待子线程执行完毕</span></span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，读取管道的输出作为输入</span></span><br><span class="line">                temp[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>multi-thread-exercise</title>
      <link href="/2023/05/11/mutlthread/"/>
      <url>/2023/05/11/mutlthread/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程编程"><a class="markdownIt-Anchor" href="#多线程编程">#</a> 多线程编程</h1><p>随便找几个多线程练习题练练手</p><p>1. 实现两个线程交替打印 1-100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="comment">/*实现两个线程交替打印1-100*/</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COUNT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumber</span><span class="params">(<span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (count &lt;= MAX_COUNT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == threadId) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printNumber, <span class="number">0</span>)</span></span>;  <span class="comment">// 线程0打印奇数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printNumber, <span class="number">1</span>)</span></span>;  <span class="comment">// 线程1打印偶数</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环 50 次，试写出代码</p><p>有点怪说实话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次，试写出代码。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_LOOPS = <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB_THREAD_LOOP_COUNT = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAIN_THREAD_LOOP_COUNT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isSubThreadTurn = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subThreadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_LOOPS; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> isSubThreadTurn; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SUB_THREAD_LOOP_COUNT; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Sub Thread: &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSubThreadTurn = <span class="literal">false</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">subThread</span><span class="params">(subThreadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_LOOPS; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !isSubThreadTurn; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MAIN_THREAD_LOOP_COUNT; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Main Thread: &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSubThreadTurn = <span class="literal">true</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有四个线程 1、2、3、4。线程 1 的功能就是输出 1，线程 2 的功能就是输出 2，</p><p>以此类推… 现在有四个文件 ABCD。初始都为空。现要让四个文件呈如下格式：</p><p>A：1 2 3 4 1 2…</p><p>B：2 3 4 1 2 3…</p><p>C：3 4 1 2 3 4…</p><p>D：4 1 2 3 4 1…</p><p>这个题比前面的有意思多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有四个线程1、2、3、4。线程1的功能就是输出1，线程2的功能就是输出2，</span></span><br><span class="line"><span class="comment">以此类推.........现在有四个文件ABCD。初始都为空。现要让四个文件呈如下格式：</span></span><br><span class="line"><span class="comment">A：1 2 3 4 1 2....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">B：2 3 4 1 2 3....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C：3 4 1 2 3 4....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">D：4 1 2 3 4 1....*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">4</span>; <span class="comment">// 线程数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxCount = <span class="number">10</span>; <span class="comment">// 每个线程要输出的数字总数</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ofstream&gt; <span class="title">outputFiles</span><span class="params">(numThreads)</span></span>; <span class="comment">// 输出文件流对象</span></span><br><span class="line"><span class="function">vector&lt;mutex&gt; <span class="title">fileMutexes</span><span class="params">(numThreads)</span></span>; <span class="comment">// 互斥锁，用于对文件进行同步访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> startNumber = threadId ; <span class="comment">// 每个线程的起始数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> number = (startNumber + i) % numThreads + <span class="number">1</span>; <span class="comment">// 计算当前要写入文件的数字</span></span><br><span class="line"></span><br><span class="line">        fileMutexes[threadId].<span class="built_in">lock</span>(); <span class="comment">// 获取当前线程对应的互斥锁</span></span><br><span class="line"></span><br><span class="line">        outputFiles[threadId] &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 将数字写入对应的文件</span></span><br><span class="line"></span><br><span class="line">        fileMutexes[threadId].<span class="built_in">unlock</span>(); <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        <span class="type">char</span> fileName = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">        outputFiles[i].<span class="built_in">open</span>(<span class="built_in">string</span>(<span class="number">1</span>, fileName) + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; threads; <span class="comment">// 线程对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        outputFiles[i].<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件写入完成。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经验证，符合题意。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081Lab:Xv6 and Unix utilities-part0</title>
      <link href="/2023/05/11/s081/lab0/"/>
      <url>/2023/05/11/s081/lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="mit6s081lab-xv6-and-unix-utilities"><a class="markdownIt-Anchor" href="#mit6s081lab-xv6-and-unix-utilities">#</a> MIT6.S081Lab: Xv6 and Unix utilities</h1><p>先来开个头</p><p>首先是 linux 开发环境搭建，我仍旧用的是阿里云 ECS Ubuntu  22.04 64 位</p><p>然后就是安装一些必备的包喽</p><p>将 git 到本地后进入文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure><p>成功后出现如下</p><p>ls 一下成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2226</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line">cat            2 4 24192</span><br><span class="line">echo           2 5 23016</span><br><span class="line">forktest       2 6 13240</span><br><span class="line">grep           2 7 27496</span><br><span class="line">init           2 8 23752</span><br><span class="line">kill           2 9 22960</span><br><span class="line">ln             2 10 22800</span><br><span class="line">ls             2 11 26384</span><br><span class="line">mkdir          2 12 23096</span><br><span class="line">rm             2 13 23080</span><br><span class="line">sh             2 14 41912</span><br><span class="line">stressfs       2 15 23952</span><br><span class="line">usertests      2 16 157000</span><br><span class="line">grind          2 17 38128</span><br><span class="line">wc             2 18 25280</span><br><span class="line">zombie         2 19 22344</span><br><span class="line">console        3 20 0</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure><p>先开个头吧，最近好累，字节青训营也开始了。</p><p>那边 CS144 的实验也并没有完全彻彻底底搞明白，下周开始做这个，预计这个六月份之前全部做完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MIT6.S081 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144Lab 4:the summit (TCP in full)</title>
      <link href="/2023/05/11/cs144/cs144lab4/"/>
      <url>/2023/05/11/cs144/cs144lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="cs144lab-4-the-summit-tcp-in-full"><a class="markdownIt-Anchor" href="#cs144lab-4-the-summit-tcp-in-full">#</a> CS144Lab 4: the summit (TCP in full)</h1><p>这节 lab 主要是将前面三小节的拼起来，以及繁琐的设计，难度估计比前面的加起来都离谱。</p><p>tcp_state.cc</p><p>TCP 的 FSM</p><p>然后看哪里错了，蛮慢慢改吧</p><p>TCP 中每一段的格式</p><p>讲义慢慢琢磨</p><p>OMG，so hard!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ms_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cerr&lt;&lt;&quot;receive: &quot; &lt;&lt; seg.header().to_string() &lt;&lt; &quot;length:&quot;&lt;&lt;seg.length_in_sequence_space()&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    _ms_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> send_empty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win)) &#123;</span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fsm_ack_rst_relaxed: ack in the future -&gt; sent ack back</span></span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> recv_recv = _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="keyword">if</span> (!recv_recv) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn &amp;&amp; !_sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore out of window RST</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (recv_recv || (seg.<span class="built_in">header</span>().ack &amp;&amp; (_sender.<span class="built_in">next_seqno</span>() == seg.<span class="built_in">header</span>().ackno))) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            <span class="built_in">test_end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_sender.<span class="built_in">fin_sent</span>()) &#123;  <span class="comment">// FIN + ACK</span></span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (send_empty &amp;&amp; _receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (!_clean_shutdown) &amp;&amp; (!_unclean_shutdown) &amp;&amp; (!_rst); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> size = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    _ms_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_rst) &#123;</span><br><span class="line">        _rst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            <span class="built_in">fill_queue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test the end of TCP connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::test_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; (<span class="built_in">unassembled_bytes</span>() == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>) &amp;&amp; _sender.<span class="built_in">fin_sent</span>()) &#123;</span><br><span class="line">        <span class="comment">// bytes_in_flight==0 =&gt; state: FIN_ACKED</span></span><br><span class="line">        _clean_shutdown |= (!_linger_after_streams_finish);</span><br><span class="line">        _unclean_shutdown |= (_ms_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill queue from _sender.segments_out() to _segments_out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::fill_queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; !_rst) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_rst || (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS)) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            seg = TCPSegment&#123;&#125;;</span><br><span class="line">            seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// TCPReceiver wants to advertise a window size</span></span><br><span class="line">            <span class="keyword">if</span> (_receiver.<span class="built_in">window_size</span>() &lt; numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  cerr &lt;&lt; &quot;send: &quot; &lt;&lt; seg.header().to_string()&lt;&lt;&quot;length:&quot; &lt;&lt; seg.length_in_sequence_space() &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前四个 lab 做完，有点懵，这周继续消化这四个 lab。</p><p>因为有的地方也参考了别人的 work，感觉完成的不是很好，这周吃透。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS144 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144Lab 3:the TCP sender</title>
      <link href="/2023/05/11/cs144/cs144lab3/"/>
      <url>/2023/05/11/cs144/cs144lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="cs144lab-3-the-tcp-sender"><a class="markdownIt-Anchor" href="#cs144lab-3-the-tcp-sender">#</a> CS144Lab 3: the TCP sender</h1><h3 id="定时器"><a class="markdownIt-Anchor" href="#定时器">#</a> 定时器</h3><p>文件中说最好在类外重新定义一个定时器，那么便如此</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPRetransmissionTimer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! retransmission timer for the connection</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _initial_RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! retransmission timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _TO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer, 1:open, 0:close</span></span><br><span class="line">    <span class="type">bool</span> _open;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Initialize a TCP retransmission timer</span></span><br><span class="line">    <span class="built_in">TCPRetransmissionTimer</span>(<span class="type">const</span> <span class="type">uint16_t</span> retx_timeout)</span><br><span class="line">        : _initial_RTO(retx_timeout), _RTO(retx_timeout), _TO(<span class="number">0</span>), _open(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">open</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _open; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! start the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">true</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! close the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">false</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! tick</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">tick</span><span class="params">(<span class="type">size_t</span> &amp;ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ms_since_last_tick &gt; _RTO - _TO) &#123;</span><br><span class="line">            ms_since_last_tick -= (_RTO - _TO);</span><br><span class="line">            _TO = _RTO;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _TO += ms_since_last_tick;</span><br><span class="line">            ms_since_last_tick = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_TO &gt;= _RTO) &#123;</span><br><span class="line">            _TO = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// the retransmission timer has expired.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="fill_window"><a class="markdownIt-Anchor" href="#fill_window">#</a> fill_window</h3><p>首先先看一下_next_seqno 的值，如果_next_seqno 为 0 则说明当前处于关闭状态，应该启动并发送一个非空的 TCPsegment。</p><p>如果_next_seqno 和_nBytes_inflight 相等，说明我们之前已经发送过了 SYN，就不用再发送了。</p><p>如果 window_size 的大小为 0，我们将其设为 1.</p><p>然后就是发送一个尽可能大的 TCPSegment 喽。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!_stream.<span class="built_in">error</span>());</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// state is CLOSE, need to send SYN</span></span><br><span class="line">        seg.<span class="built_in">header</span>().syn = <span class="number">1</span>;</span><br><span class="line">        _syn_sent = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(seg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_next_seqno == _nBytes_inflight) &#123;</span><br><span class="line">        <span class="comment">// state is SYN SENT, don&#x27;t send SYN</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero window probing</span></span><br><span class="line">    <span class="type">uint16_t</span> window_size = _window_size ? _window_size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> remaining;</span><br><span class="line">    <span class="keyword">while</span> ((remaining = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(window_size) + (_recv_ackno - _next_seqno))) &#123;</span><br><span class="line">        <span class="comment">// FIN flag occupies space in window</span></span><br><span class="line">        TCPSegment new_seg;</span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !_fin_sent) &#123;</span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">size_t</span> size = <span class="built_in">min</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(remaining), TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">        new_seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(size));</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() &lt; window_size &amp;&amp; _stream.<span class="built_in">eof</span>()) &#123;  <span class="comment">// piggy-back FIN</span></span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ack_received"><a class="markdownIt-Anchor" href="#ack_received">#</a> ack_received</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="comment">//! \returns `false` if the ackno appears invalid (acknowledges something the TCPSender hasn&#x27;t sent yet)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ackno - <span class="built_in">next_seqno</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果window_size为0，需要记录下来，&quot;zero window probing&quot;, 影响tick()和fill_window()的行为</span></span><br><span class="line">    _window_size = window_size;</span><br><span class="line">    <span class="type">uint64_t</span> abs_ackno = <span class="built_in">unwrap</span>(ackno, _isn, _recv_ackno);</span><br><span class="line">    <span class="keyword">if</span> (abs_ackno &lt;= _recv_ackno) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _recv_ackno = abs_ackno;</span><br><span class="line">    <span class="comment">// acknowledges the successful receipt of new data</span></span><br><span class="line">    _timer._RTO = _timer._initial_RTO;</span><br><span class="line">    _timer._TO = <span class="number">0</span>;</span><br><span class="line">    _consecutive_retransmissions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque fully-acknowledged segments</span></span><br><span class="line">    <span class="keyword">while</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;seg = _segments_outstanding.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (ackno - seg.<span class="built_in">header</span>().seqno &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(seg.<span class="built_in">length_in_sequence_space</span>())) &#123;</span><br><span class="line">            _nBytes_inflight -= seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            _segments_outstanding.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the window</span></span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// any outstanding segment, restart the timer.</span></span><br><span class="line">    <span class="comment">// [RFC6298](5.3)</span></span><br><span class="line">    <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _timer.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tick"><a class="markdownIt-Anchor" href="#tick">#</a> tick</h3><p>这里基本上就是和超时重传差不多吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> time_left = ms_since_last_tick;</span><br><span class="line">    <span class="keyword">if</span> (_timer.<span class="built_in">tick</span>(time_left)) &#123;</span><br><span class="line">        <span class="comment">// Notice: remove fill_the_window() here to fix the test fsm_retx_relaxed</span></span><br><span class="line">        <span class="comment">// timer has expired, retransmit at most ONE outstanding segment</span></span><br><span class="line">        <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// retransmit the outstanding segment with the lowest sequence number</span></span><br><span class="line">            _segments_out.<span class="built_in">push</span>(_segments_outstanding.<span class="built_in">front</span>());</span><br><span class="line">            <span class="keyword">if</span> (_window_size) &#123;</span><br><span class="line">                _consecutive_retransmissions++;</span><br><span class="line">                _timer._RTO *= <span class="number">2</span>;  <span class="comment">// double the RTO, exponential backoff, it slows down retransmissions on lousy</span></span><br><span class="line">                                   <span class="comment">// networks to avoid further gumming up the works</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_timer.<span class="built_in">open</span>()) &#123;  <span class="comment">//[RFC6298](5.1)</span></span><br><span class="line">                _timer.<span class="built_in">start</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">syn_sent</span>() &amp;&amp; (_next_seqno == _nBytes_inflight) &amp;&amp; (_timer._RTO &lt; <span class="number">3000</span>)) &#123;</span><br><span class="line">                _timer._RTO = <span class="number">3000</span>;  <span class="comment">// SYN_SENT, [RFC6298](5.7)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _timer.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CS144 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录-24天</title>
      <link href="/2023/05/10/shuati/day24/"/>
      <url>/2023/05/10/shuati/day24/</url>
      
        <content type="html"><![CDATA[<h4 id="1015-可被-k-整除的最小整数"><a class="markdownIt-Anchor" href="#1015-可被-k-整除的最小整数">#</a> <a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/">1015. 可被 K 整除的最小整数</a></h4><p>给定正整数  <code>k</code>  ，你需要找出可以被  <code>k</code>  整除的、仅包含数字  <code>**1**</code>  的最 <strong>小</strong> 正整数  <code>n</code>  的长度。</p><p>返回  <code>n</code>  的长度。如果不存在这样的  <code>n</code>  ，就返回 - 1。</p><p><strong>注意：</strong>  <code>n</code>  不符合 64 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的答案是 n = 1，其长度为 1。</span><br></pre></td></tr></table></figure><p>能整除 2 或 5 的肯定不行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span> || k % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> resid = <span class="number">1</span> % k, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (resid != <span class="number">0</span>) &#123;</span><br><span class="line">            resid = (resid * <span class="number">10</span> + <span class="number">1</span>) % k;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点  <code>root</code>  ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p>也还行吧，递归就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_gain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INT_MAX;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;right),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pp = r + l + root-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, pp);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">max_gain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表">#</a> <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h4><p>给你一个链表的头节点  <code>head</code>  ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪  <code>next</code>  指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数  <code>pos</code>  来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意： <code>pos</code>  不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回  <code>true</code>  。 否则，返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>典型快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="79-单词搜索"><a class="markdownIt-Anchor" href="#79-单词搜索">#</a> <a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h4><p>给定一个  <code>m x n</code>  二维字符网格  <code>board</code>  和一个字符串单词  <code>word</code>  。如果  <code>word</code>  存在于网格中，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>嗯，好像没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ex</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, string word, <span class="type">int</span> d, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == word.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; board[i][j] == word[d]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[d]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == word[d]) &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i<span class="number">-1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;board.<span class="built_in">size</span>() &amp;&amp; board[i+<span class="number">1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i+<span class="number">1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>&lt;board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[i][j+<span class="number">1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j+<span class="number">1</span>);</span><br><span class="line">            board[i][j] = word[d];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">ex</span>(board, word, <span class="number">0</span>, i, j);</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144-summary1</title>
      <link href="/2023/05/10/cs144/summary1/"/>
      <url>/2023/05/10/cs144/summary1/</url>
      
        <content type="html"><![CDATA[<h1 id="cs144lab0-1-2-summary"><a class="markdownIt-Anchor" href="#cs144lab0-1-2-summary">#</a> CS144lab0-1-2 summary</h1><p>在 lab0 中，首先实现了一个 get_url 函数，这个函数就是像指定地址发起 http 连接然后做出响应，注意一下 Htpp 报文响应格式就可以了。</p><p>随后我们又完成了 ByteStream 的实现。</p><p>这个 byteStream 主要就是实现 TCP 协议中的最基础的字节流，用来存储需要传输的字节。</p><p>在 lab1 中，实现 StreamReassembler。</p><p>这个主要是 TCP 协议中的数据流控制器，用来将传给 TCP 的数据确保有序写入 byteStream 中。</p><p>在 lab2 中，我们实现 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p><img src="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol><li>内核态下 UDP 数据包中的 payload 被解析为 TCPSegment (TCP 报文) 后，交给用户态下的 TCPConnection，即调用 segment_received 方法；</li><li>TCPConnection 收到报文后，将报文交给 TCPReceiver，即调用 TCPReceiver.segment_received 方法，并将报文中的 ackno (确认号) 与 window_size (窗口大小) 交给 TCPSender，即调用 ack_received 方法；</li><li>TCPReceiver 处理 TCP 报文，并将报文中的 payload 推入 StreamReassembler 中，并重组后交给应用程序，随后尝试发送报文；</li><li>TCPConnection 调用 TCPSender.fill_window 方法尝试得到待发送报文 (可能得不到，视具体情况而定)，若有报文，则设置报文 payload 以及其它字段，如 SYN、ackno (从 receiver 获取)、window_size 等，设置完毕后包装为 TCP 报文，将报文交给 UDP；</li><li>UDP 将其打包为数据报，并发送给远端。</li></ol><p>lab2 中只要注意这个图问题不大。</p><p><img src="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>在 TCP header 中 seqno 与 ackno 都是 32 位整数，但是 isn 是发送者随机生成的数字，那么可能会产生一个问题：如果随机生成的 isn 十分接近 2^32-1 怎么办？</p><p>这代表，TCP 数据流很快就会溢出 seqno。为了解决这个问题，sponge 实现了两个序号，一个是正常的 TCP header seqno，32 位，使用 WrappingInt32 表示，初始化为随机数，另一个是绝对 seqno 序号，使用 uint64_t 表示，初始化为 0。用绝对序号来表示数据流上字节的数量，最大数量为 2^64-1，这几乎是不可能达成的目标。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS144 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录-第23天</title>
      <link href="/2023/05/09/shuati/day23/"/>
      <url>/2023/05/09/shuati/day23/</url>
      
        <content type="html"><![CDATA[<h3 id="池塘计数"><a class="markdownIt-Anchor" href="#池塘计数">#</a> 池塘计数</h3><p>农夫约翰有一片 N∗M ∗  的矩形土地。</p><p>最近，由于降雨的原因，部分土地被水淹没了。</p><p>现在用一个字符矩阵来表示他的土地。</p><p>每个单元格内，如果包含雨水，则用”W” 表示，如果不含雨水，则用”.” 表示。</p><p>现在，约翰想知道他的土地中形成了多少片池塘。</p><p>每组相连的积水单元格集合可以看作是一片池塘。</p><p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p><p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W” 块。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含两个整数 N  和 M 。</p><p>接下来 N  行，每行包含 M  个字符，字符为”W” 或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出一个整数，表示池塘数目。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤N,M≤10001≤ , ≤1000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>经典连通块问题喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    f[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//上、下、左、右、左上、右上、左下、右下</span></span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; f[x+<span class="number">1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (y+<span class="number">1</span>&lt;m &amp;&amp; f[x][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x<span class="number">-1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x+<span class="number">1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="type">char</span> a;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;W&#x27;</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;.&#x27;</span>) f[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热浪"><a class="markdownIt-Anchor" href="#热浪">#</a> 热浪</h3><p>德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！</p><p>他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。</p><p>农夫 John 此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p><p>John 已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。</p><p>这些路线包括起始点和终点一共有 T  个城镇，为了方便标号为 11 到 T 。</p><p>除了起点和终点外的每个城镇都由 <strong>双向道路</strong> 连向至少两个其它的城镇。</p><p>每条道路有一个通过费用（包括油费，过路费等等）。</p><p>给定一个地图，包含 C  条直接连接 22 个城镇的道路。</p><p>每条道路由道路的起点 Rs  ，终点 Re   和花费 Ci   组成。</p><p>求从起始的城镇 Ts   到终点的城镇 Te   最小的总费用。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>第一行: 44 个由空格隔开的整数: T,C,Ts,Te , ,  ,  ;</p><p>第 22 到第 C+1 +1 行：第 i+1 +1 行描述第 i  条道路，包含 33 个由空格隔开的整数: Rs,Re,Ci  ,  ,  。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>一个单独的整数表示从 Ts   到 Te   的最小总费用。</p><p>数据保证至少存在一条道路。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤T≤25001≤ ≤2500,<br>1≤C≤62001≤ ≤6200,<br>1≤Ts,Te,Rs,Re≤T1≤  ,  ,  ,  ≤ ,<br>1≤Ci≤10001≤  ≤1000</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><p>dijkstra 算法板子题算是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,c, nbeg, nend;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[nbeg] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c&gt;&gt;nbeg&gt;&gt;nend;</span><br><span class="line">    <span class="keyword">while</span> (c --) &#123;</span><br><span class="line">        <span class="type">int</span> k, p, l;</span><br><span class="line">        cin&gt;&gt;k&gt;&gt;p&gt;&gt;l;</span><br><span class="line">        g[k][p] = g[p][k] = <span class="built_in">min</span>(g[k][p], l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout&lt;&lt;dist[nend];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dijkstra 的整体思路比较清晰<br>即进行 n（n 为 n 的个数）次迭代去确定每个点到起点的最小值 最后输出的终点的即为我们要找的最短路的距离</p><p>所以按照这个思路除了存储图外我们还需要存储两个量</p><p>dist [n] // 用于存储每个点到起点的最短距离<br> st [n]   // 用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新</p><p>每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点<br>（至于为什么是这样那么这就涉及到 Dijkstra 算法的具体数学证明了 有兴趣的同学可以百度一下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t=<span class="number">-1</span>;       <span class="comment">//将t设置为-1 因为Dijkstra算法适用于不存在负权边的图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j])    <span class="comment">//该步骤即寻找还未确定最短路的点中路径最短的点</span></span><br><span class="line">        t=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述操作当前我们的 t 代表就是剩余未确定最短路的点中 路径最短的点<br>而与此同时该点的最短路径也已经确定我们将该点标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st[t]=true;</span><br></pre></td></tr></table></figure><p>然后用这个去更新其余未确定点的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离</span></span><br><span class="line"><span class="comment">//但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响</span></span><br><span class="line"><span class="comment">//当然你也可以在循环判断条件里加上if(!st[i])</span></span><br><span class="line"><span class="comment">//这里j从1开始只是为了代码的简洁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行 n 次迭代后最后就可以确定每个点的最短距离</p><h4 id="面试题-0101-判定字符是否唯一"><a class="markdownIt-Anchor" href="#面试题-0101-判定字符是否唯一">#</a> <a href="https://leetcode.cn/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一</a></h4><p>实现一个算法，确定一个字符串  <code>s</code>  的所有字符是否全都不同。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;</span><br><span class="line">输出: false </span><br></pre></td></tr></table></figure><p>题目说了全是小写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; astr.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[astr[i]-<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            a[astr[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍">#</a> <a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>典</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">max</span>(f[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(f[<span class="number">0</span>], f[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], <span class="built_in">max</span>(nums[i]+f[i<span class="number">-2</span>],f[i<span class="number">-1</span>]));</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="面试题-0202-返回倒数第-k-个节点"><a class="markdownIt-Anchor" href="#面试题-0202-返回倒数第-k-个节点">#</a> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></h4><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p>** 注意：** 本题相对原题稍作改动</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p>双指针喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">while</span> (h!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast ++;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day22</title>
      <link href="/2023/05/08/shuati/day22/"/>
      <url>/2023/05/08/shuati/day22/</url>
      
        <content type="html"><![CDATA[<h4 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站">#</a> <a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h4><p>在一条环路上有  <code>n</code>  个加油站，其中第  <code>i</code>  个加油站有汽油  <code>gas[i]</code>  升。</p><p>你有一辆油箱容量无限的的汽车，从第  <code>i</code>  个加油站开往第  <code>i+1</code>  个加油站需要消耗汽油  <code>cost[i]</code>  升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组  <code>gas</code>  和  <code>cost</code>  ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回  <code>-1</code>  。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p>贪心即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">                start = i + <span class="number">1</span>;  </span><br><span class="line">                curSum = <span class="number">0</span>;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="135-分发糖果"><a class="markdownIt-Anchor" href="#135-分发糖果">#</a> <a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h4><p><code>n</code>  个孩子站成一排。给你一个整数数组  <code>ratings</code>  表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到  <code>1</code>  个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure><p>从左向右，从右向左，各来一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="860-柠檬水找零"><a class="markdownIt-Anchor" href="#860-柠檬水找零">#</a> <a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h4><p>在柠檬水摊上，每一杯柠檬水的售价为  <code>5</code>  美元。顾客排队购买你的产品，（按账单  <code>bills</code>  支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付  <code>5</code>  美元、 <code>10</code>  美元或  <code>20</code>  美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付  <code>5</code>  美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组  <code>bills</code>  ，其中  <code>bills[i]</code>  是第  <code>i</code>  位顾客付的账。如果你能给每位顾客正确找零，返回  <code>true</code>  ，否则返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bill : bills) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="comment">// 情况二</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况三</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着</span></span><br><span class="line">                <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                    twenty++; <span class="comment">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                    twenty++; <span class="comment">// 同理，这行代码也可以删了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="406-根据身高重建队列"><a class="markdownIt-Anchor" href="#406-根据身高重建队列">#</a> <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><p>假设有打乱顺序的一群人站成一个队列，数组  <code>people</code>  表示队列中一些人的属性（不一定按顺序）。每个  <code>people[i] = [hi, ki]</code>  表示第  <code>i</code>  个人的身高为  <code>hi</code>  ，前面 <strong>正好</strong> 有  <code>ki</code>  个身高大于或等于  <code>hi</code>  的人。</p><p>请你重新构造并返回输入数组  <code>people</code>  所表示的队列。返回的队列应该格式化为数组  <code>queue</code>  ，其中  <code>queue[j] = [hj, kj]</code>  是队列中第  <code>j</code>  个人的属性（ <code>queue[0]</code>  是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 身高从大到小排（身高相同k小的站前面）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span> (people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que; <span class="comment">// list底层是链表实现，插入效率比vector高的多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>]; <span class="comment">// 插入到下标为position的位置</span></span><br><span class="line">            std::list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (position--) &#123; <span class="comment">// 寻找在插入位置</span></span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(it, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>感觉有时候贪心和动态规划有时候好像。</p><p>很想用动态规划上去结题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 2:the TCP receiver</title>
      <link href="/2023/05/08/cs144/cs144lab2/"/>
      <url>/2023/05/08/cs144/cs144lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="lab-2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#lab-2-the-tcp-receiver">#</a> Lab 2: the TCP receiver</h1><p>在 Lab2，我们将实现一个 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p>TCPReceiver 除了将读入的数据写入至 ByteStream 中以外，它还需要<strong>告诉发送者两个属性</strong>：</p><ul><li>第一个未组装的字节索引，称为<strong>确认号 ackno</strong>，它是接收者需要的第一个字节的索引。</li><li><strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的距离，称为 <strong>窗口长度 window size</strong>。</li></ul><p>ackno 和 window size 共同描述了接收者当前的<strong>接收窗口</strong>。接收窗口是 发送者允许发送数据的一个范围，通常 TCP 接收方使用接收窗口来进行<strong>流量控制</strong>，限制发送方发送数据。</p><p>总的来说，我们将要实现的 TCPReceiver 需要做以下几件事情：</p><ul><li>接收 TCP segment</li><li>重新组装字节流（包括 EOF）</li><li>确定应该发回给发送者的信号，以进行数据确认和流量控制</li></ul><h2 id="索引转换"><a class="markdownIt-Anchor" href="#索引转换">#</a> 索引转换</h2><p>TCP 报文中用来描述 ** 当前数据首字节的索引（序列号 seqno）** 是 32 位类型的，这意味着在处理上增加了一些需要考虑的东西：</p><p>在传输的 TCP 报文头部中，由于空间限制，字节序列号只能用 32 位的索引来表示。但是 32 位可能无法完全一一对应一串字节流，所以需要我们在接收端人为将索引转换为 64 位以保证不会溢出。</p><ul><li><p>由于 32 位类型最大能表达的值是 4GB，存在上溢的可能。因此当 32 位的 seqno 上溢后，下一个字节的 seqno 就重新从 0 开始。</p></li><li><p>处于安全性考虑，以及避免与之前的 TCP 报文混淆，TCP 需要让每个 seqno 都不可被猜测到，并且降低重复的可能性。因此 TCP seqno 不会从 0 开始，而是从一个 32 位随机数起步（称为<strong>初始序列号 ISN</strong>）。</p><p>而 ISN 是表示 SYN 包（用以表示 TCP 流的开始）的序列号。</p></li><li><p>TCP 流的<strong>逻辑开始数据包</strong>和<strong>逻辑结束数据包</strong>各占用一个 seqno。除了确保<strong>接收到所有字节的数据</strong>以外，TCP 还需要确保接收到<strong>流的开头和结尾</strong>。 因此，在 TCP 中，SYN（流开始）和 FIN（流结束）控制标志将会被分别分配一个序列号（SYN 标志占用的序列号就是 ISN）。</p><p>流中的每个数据字节也占用一个序列号。</p><p>但需要注意的是，SYN 和 FIN 不是流本身的一部分，也不是传输的字节数据。它们只是代表字节流本身的开始和结束。</p></li></ul><p>字节索引类型一多就容易乱。当前总共有三种索引：</p><ul><li>序列号 seqno。<strong>从 ISN 起步</strong>，包含 SYN 和 FIN，<strong>32 位循环</strong>计数</li><li>绝对序列号 absolute seqno。<strong>从 0 起步</strong>，包含 SYN 和 FIN，<strong>64 位非循环</strong>计数</li><li>流索引 stream index。<strong>从 0 起步</strong>，<strong>排除 SYN 和 FIN</strong>，<strong>64 位非循环</strong>计数。</li></ul><p>这是一个简单浅显的例子，用于区分开三种索引的区别：</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" class="lazyload placeholder" data-srcset="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211107105751818"></p><p>序列号和<strong>绝对</strong>序列号之间相互转换稍微有点麻烦，因为序列号是<strong>循环计数</strong>的。在该实验中，CS144 使用自定义类型 WrappingInt32 表示序列号，并编写了它与绝对序列号之间的转换。</p><p>这个实现稍微有点麻烦，而且实现的时候也最好避免各类循环，减少使用条件判断的次数，以提高执行效率。</p><h4 id="wrap"><a class="markdownIt-Anchor" href="#wrap">#</a> wrap</h4><p>该函数时将 64 位转化为 64 位，还是比较容易</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn); </span></span><br><span class="line">    <span class="comment">// return WrappingInt32&#123;0&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(isn.<span class="built_in">raw_value</span>() + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="unwrap"><a class="markdownIt-Anchor" href="#unwrap">#</a> unwrap</h4><p>该函数将 32 位转化为 64 位，需要动点脑子</p><p>因为 64 位变成 32 位肯定会有些数字代表的并不是一个，可能是多个 64 位的数据，所以这个时候就需要 checkpoint 来告诉我们是哪个</p><p>离得近就是！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn, checkpoint);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">uint64_t</span> offset = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n.<span class="built_in">raw_value</span>()-isn.<span class="built_in">raw_value</span>());</span><br><span class="line">    <span class="type">uint64_t</span> mod = checkpoint&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> ii  = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add = ii&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add_1 = offset + add*mod;</span><br><span class="line">    <span class="type">uint64_t</span> add_2 = offset + add*(mod+<span class="number">1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> add_3 = offset + add*(mod<span class="number">-1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> r_1 = add_1 &gt; checkpoint ? add_1 - checkpoint : checkpoint - add_1;</span><br><span class="line">    <span class="type">uint64_t</span> r_2 = add_2 &gt; checkpoint ? add_2 - checkpoint : checkpoint - add_2;</span><br><span class="line">    <span class="type">uint64_t</span> r_3 = add_3 &gt; checkpoint ? add_3 - checkpoint : checkpoint - add_3;</span><br><span class="line">    r_3 ++;</span><br><span class="line">    r_3 --;</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="number">0</span>) r_3 = INT64_MAX;</span><br><span class="line">    <span class="type">uint64_t</span> min_off = <span class="built_in">min</span>(<span class="built_in">min</span>(r_1, r_2), r_3);</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_1) <span class="keyword">return</span> add_1;</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_2) <span class="keyword">return</span> add_2;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> add_3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 1: t_wrapping_ints_cmp</span><br><span class="line">1/3 Test #1: t_wrapping_ints_cmp ..............   Passed    0.01 sec</span><br><span class="line">    Start 2: t_wrapping_ints_unwrap</span><br><span class="line">2/3 Test #2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span><br><span class="line">    Start 3: t_wrapping_ints_wrap</span><br><span class="line">3/3 Test #3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 3</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.02 sec</span><br></pre></td></tr></table></figure><h4 id="implementing-the-tcp-receiver"><a class="markdownIt-Anchor" href="#implementing-the-tcp-receiver">#</a> Implementing the TCP receiver</h4><p>调试还是蛮麻烦的，很难一下子考虑到所有情况欸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> abs_seqno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_syn_flag) &#123;  <span class="comment">// already get a SYN, refuse other SYN.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _syn_flag = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">        _isn = seg.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>();</span><br><span class="line">        abs_seqno = <span class="number">1</span>;</span><br><span class="line">        _base = <span class="number">1</span>;</span><br><span class="line">        length = seg.<span class="built_in">length_in_sequence_space</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;  <span class="comment">// segment&#x27;s content only have a SYN flag</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_syn_flag) &#123;  <span class="comment">// before get a SYN, refuse any segment</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// not a SYN segment, compute it&#x27;s abs_seqno</span></span><br><span class="line">        abs_seqno = <span class="built_in">unwrap</span>(<span class="built_in">WrappingInt32</span>(seg.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>()), <span class="built_in">WrappingInt32</span>(_isn), abs_seqno);</span><br><span class="line">        length = seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_fin_flag) &#123;  <span class="comment">// already get a FIN, refuse other FIN</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _fin_flag = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// not FIN and not one size&#x27;s SYN, check border</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp; abs_seqno == _base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (abs_seqno &gt;= _base + <span class="built_in">window_size</span>() || abs_seqno + length &lt;= _base) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(), abs_seqno - <span class="number">1</span>, seg.<span class="built_in">header</span>().fin);</span><br><span class="line">    _base = _reassembler.<span class="built_in">head_index</span>() + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">input_ended</span>())  <span class="comment">// FIN be count as one byte</span></span><br><span class="line">        _base++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_base &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(<span class="built_in">wrap</span>(_base, <span class="built_in">WrappingInt32</span>(_isn)));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _reassembler.<span class="built_in">stream_out</span>().<span class="built_in">buffer_size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>测试结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">      Start  <span class="number">1</span>: t_wrapping_ints_cmp</span><br><span class="line"> <span class="number">1</span>/<span class="number">25</span> Test  #<span class="number">1</span>: t_wrapping_ints_cmp ..............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">2</span>: t_wrapping_ints_unwrap</span><br><span class="line"> <span class="number">2</span>/<span class="number">25</span> Test  #<span class="number">2</span>: t_wrapping_ints_unwrap ...........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">3</span>: t_wrapping_ints_wrap</span><br><span class="line"> <span class="number">3</span>/<span class="number">25</span> Test  #<span class="number">3</span>: t_wrapping_ints_wrap .............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">4</span>: t_recv_connect</span><br><span class="line"> <span class="number">4</span>/<span class="number">25</span> Test  #<span class="number">4</span>: t_recv_connect ...................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">5</span>: t_recv_transmit</span><br><span class="line"> <span class="number">5</span>/<span class="number">25</span> Test  #<span class="number">5</span>: t_recv_transmit ..................   Passed    <span class="number">0.06</span> sec</span><br><span class="line">      Start  <span class="number">6</span>: t_recv_window</span><br><span class="line"> <span class="number">6</span>/<span class="number">25</span> Test  #<span class="number">6</span>: t_recv_window ....................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">7</span>: t_recv_reorder</span><br><span class="line"> <span class="number">7</span>/<span class="number">25</span> Test  #<span class="number">7</span>: t_recv_reorder ...................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">8</span>: t_recv_close</span><br><span class="line"> <span class="number">8</span>/<span class="number">25</span> Test  #<span class="number">8</span>: t_recv_close .....................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">15</span>: t_strm_reassem_single</span><br><span class="line"> <span class="number">9</span>/<span class="number">25</span> Test #<span class="number">15</span>: t_strm_reassem_single ............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">16</span>: t_strm_reassem_seq</span><br><span class="line"><span class="number">10</span>/<span class="number">25</span> Test #<span class="number">16</span>: t_strm_reassem_seq ...............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">17</span>: t_strm_reassem_dup</span><br><span class="line"><span class="number">11</span>/<span class="number">25</span> Test #<span class="number">17</span>: t_strm_reassem_dup ...............   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">18</span>: t_strm_reassem_holes</span><br><span class="line"><span class="number">12</span>/<span class="number">25</span> Test #<span class="number">18</span>: t_strm_reassem_holes .............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">19</span>: t_strm_reassem_many</span><br><span class="line"><span class="number">13</span>/<span class="number">25</span> Test #<span class="number">19</span>: t_strm_reassem_many ..............   Passed    <span class="number">0.13</span> sec</span><br><span class="line">      Start <span class="number">20</span>: t_strm_reassem_overlapping</span><br><span class="line"><span class="number">14</span>/<span class="number">25</span> Test #<span class="number">20</span>: t_strm_reassem_overlapping .......   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">21</span>: t_strm_reassem_win</span><br><span class="line"><span class="number">15</span>/<span class="number">25</span> Test #<span class="number">21</span>: t_strm_reassem_win ...............   Passed    <span class="number">0.12</span> sec</span><br><span class="line">      Start <span class="number">22</span>: t_strm_reassem_cap</span><br><span class="line"><span class="number">16</span>/<span class="number">25</span> Test #<span class="number">22</span>: t_strm_reassem_cap ...............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">23</span>: t_byte_stream_construction</span><br><span class="line"><span class="number">17</span>/<span class="number">25</span> Test #<span class="number">23</span>: t_byte_stream_construction .......   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">24</span>: t_byte_stream_one_write</span><br><span class="line"><span class="number">18</span>/<span class="number">25</span> Test #<span class="number">24</span>: t_byte_stream_one_write ..........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">25</span>: t_byte_stream_two_writes</span><br><span class="line"><span class="number">19</span>/<span class="number">25</span> Test #<span class="number">25</span>: t_byte_stream_two_writes .........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">26</span>: t_byte_stream_capacity</span><br><span class="line"><span class="number">20</span>/<span class="number">25</span> Test #<span class="number">26</span>: t_byte_stream_capacity ...........   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">27</span>: t_byte_stream_many_writes</span><br><span class="line"><span class="number">21</span>/<span class="number">25</span> Test #<span class="number">27</span>: t_byte_stream_many_writes ........   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">28</span>: t_webget</span><br><span class="line"><span class="number">22</span>/<span class="number">25</span> Test #<span class="number">28</span>: t_webget .........................   Passed    <span class="number">0.50</span> sec</span><br><span class="line">      Start <span class="number">48</span>: t_address_dt</span><br><span class="line"><span class="number">23</span>/<span class="number">25</span> Test #<span class="number">48</span>: t_address_dt .....................   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">49</span>: t_parser_dt</span><br><span class="line"><span class="number">24</span>/<span class="number">25</span> Test #<span class="number">49</span>: t_parser_dt ......................   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">50</span>: t_socket_dt</span><br><span class="line"><span class="number">25</span>/<span class="number">25</span> Test #<span class="number">50</span>: t_socket_dt ......................   Passed    <span class="number">0.01</span> sec</span><br><span class="line"></span><br><span class="line"><span class="number">100</span>% tests passed, <span class="number">0</span> tests failed out of <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="function">Total Test <span class="title">time</span> <span class="params">(real)</span> </span>=   <span class="number">0.98</span> sec</span><br><span class="line">[<span class="number">100</span>%] Built target check_lab2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CS144 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144- 太可恶了!</title>
      <link href="/2023/05/08/cs144/css144/"/>
      <url>/2023/05/08/cs144/css144/</url>
      
        <content type="html"><![CDATA[<p>强烈声讨</p><p>CS144lab2cmake文件</p><p>库文件写错了，一直只会给出not found</p><p>搞得我还以为自己没安装成功</p><p>头痛一上午</p><p>寻找了各种方法</p><p>mmp</p><p>最后忍不了了直接查看cmake文件</p><p>好啊</p><p>原来是你在那个地方一直给了一个not found</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new-malloc-free-delete</title>
      <link href="/2023/05/07/c-basic/new-malloc/"/>
      <url>/2023/05/07/c-basic/new-malloc/</url>
      
        <content type="html"><![CDATA[<h3 id="new-delete"><a class="markdownIt-Anchor" href="#new-delete">#</a> new delete</h3><h3 id="new-和malloc的区别"><a class="markdownIt-Anchor" href="#new-和malloc的区别">#</a> new 和 malloc 的区别</h3><p>new 不仅可以开辟内存还可以初始化</p><p>malloc 开辟内存失败，是通过返回值和 nullptr 做比较的；而 new 开辟内存失败，是通过抛出 bad_alloc 类型的异常来判断的。</p><h3 id="delete和free的区别"><a class="markdownIt-Anchor" href="#delete和free的区别">#</a> delete 和 free 的区别</h3><p>malloc 和 free，C 的库函数</p><p>new 和 delete 运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">*p =<span class="number">20</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure><p>关于 delete 数组的时候</p><p>需要 delete [] p</p><p>如果不加的话只删第一个 (<strong>why?</strong>)</p><p>数组是一片连续的内存，释放时候你传递的数组名，也仅是一个指针，。<br>C++ 规定，delete p 时，仅删除指针指向的第一块内存。<br>delete [] p 才能把指针指向的一片连续内存都删除，因为在底层有一个变量，保存着需要删除的对象的数目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day21</title>
      <link href="/2023/05/07/shuati/day21/"/>
      <url>/2023/05/07/shuati/day21/</url>
      
        <content type="html"><![CDATA[<p>今天是贪心专题 KMP 暂且缓缓 调试 lab1 花了太久太久</p><h3 id="贪心本质局部最优推出全局最优"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优">#</a> 贪心本质：局部最优推出全局最优。</h3><h4 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干">#</a> <a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子  <code>i</code> ，都有一个胃口值  <code>g[i]</code> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干  <code>j</code> ，都有一个尺寸  <code>s[j]</code>  。如果  <code>s[j] &gt;= g[i]</code> ，我们可以将这个饼干  <code>j</code>  分配给孩子  <code>i</code>  ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gl = <span class="number">0</span>, sl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (gl &lt; g.<span class="built_in">size</span>() &amp;&amp; sl &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sl] &gt;= g[gl]) &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">                gl ++;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="376-摆动序列"><a class="markdownIt-Anchor" href="#376-摆动序列">#</a> <a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 ** 摆动序列 。** 第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如，  <code>[1, 7, 4, 9, 2, 5]</code>  是一个 <strong>摆动序列</strong> ，因为差值  <code>(6, -3, 5, -7, 3)</code>  是正负交替出现的。</li><li>相反， <code>[1, 4, 7, 2, 5]</code>  和  <code>[1, 7, 4, 5, 5]</code>  不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组  <code>nums</code>  ，返回  <code>nums</code>  中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p>这题可以用 DP，当然今天是贪心专题，贪心做法就是去掉连续上升值中然后制造峰值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201126%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E5%91%A8">https://www.programmercarl.com/ 周总结 / 20201126 贪心周末总结.html# 周</a></p><h3 id="贪心本质局部最优推出全局最优-2"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优-2">#</a> 贪心本质：局部最优推出全局最优。</h3>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144Lab 1:stitching substrings into a byte stream</title>
      <link href="/2023/05/07/cs144/cs144lab1/"/>
      <url>/2023/05/07/cs144/cs144lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="lab-1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#lab-1-stitching-substrings-into-a-byte-stream">#</a> Lab 1: stitching substrings into a byte stream</h1><h4 id="putting-substrings-in-sequence"><a class="markdownIt-Anchor" href="#putting-substrings-in-sequence">#</a> Putting substrings in sequence</h4><p>刚开始似乎思路出现了一些小小的偏差</p><p>想着用 unordered_map&lt;int,char&gt; 去直接把所有的信息都存进去。</p><p>实践发现，不太合适。</p><p>一直都是只能过 66.7%.</p><p>因为如果用 unordered_map 的话，其实不是很好把握住区间关系，虽然刚开始我是像借用数字寻找 char，然后就算是重复区间利用哈希表的特性完成问题，但是老是有意想不到的意外发生。</p><p>其实时间复杂度也不会低。</p><p>而且前后顺序出现问题是不能很好的解决的。</p><p>所以最后还是看了下别人写的，使用了两个 deque 来存，其实不用 deque 也可以的，这样也好吧，vector 也行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">char</span>&gt; buffer ;</span><br><span class="line">   std::deque&lt;<span class="type">bool</span>&gt; bufer_state ;</span><br><span class="line">   <span class="type">size_t</span> _unassembled_bytes = <span class="number">0</span>;<span class="comment">//已到地方索引</span></span><br><span class="line">   <span class="type">size_t</span> eof_index = <span class="number">0</span>;<span class="comment">//结束索引</span></span><br><span class="line">   <span class="type">bool</span> eof_ = <span class="literal">false</span>;</span><br><span class="line">   ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">   <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就是具体的实现了</p><p>因为数据发送方可能是乱序发送的数据，所以这里需要注意下前后顺序啊，然后对区间进行截取。</p><p>相当于实现了 tcp 协议中的对数据流进行排序</p><p>气死我了 调试了一天不知道问题所在，忘记初始化</p><p>以及如果实在函数外初始化切记要按照定义先后顺序初始化，否则大坑</p><p>然后像这种取交集啊，一般都是左取大，右取小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DUMMY_CODE(data, index, eof);</span></span><br><span class="line">    <span class="type">size_t</span> first_unassembled_bytes = _output.<span class="built_in">bytes_written</span>();</span><br><span class="line">    <span class="type">size_t</span> first_unaccept = first_unassembled_bytes + _capacity;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= first_unaccept || index+data.<span class="built_in">size</span>() &lt; first_unassembled_bytes) <span class="keyword">return</span> ;<span class="comment">//两端之外，去掉</span></span><br><span class="line">    <span class="comment">//左取大，右取小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> first_begin = <span class="built_in">max</span>(first_unassembled_bytes, index);</span><br><span class="line">    <span class="type">size_t</span> first_end = <span class="built_in">min</span>(first_unaccept, index+data.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向buffer里写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = first_begin; i &lt; first_end; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !bufer_state[i-first_unassembled_bytes]) &#123;</span><br><span class="line">            buffer[i-first_unassembled_bytes] = data[i-index];</span><br><span class="line">            _unassembled_bytes++;</span><br><span class="line">            bufer_state[i-first_unassembled_bytes] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (bufer_state.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        res += buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">        bufer_state.<span class="built_in">pop_front</span>();</span><br><span class="line">        buffer.<span class="built_in">emplace_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">        bufer_state.<span class="built_in">emplace_back</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stream_out</span>().<span class="built_in">write</span>(res);</span><br><span class="line">        _unassembled_bytes -= res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        eof_ = <span class="literal">true</span>;</span><br><span class="line">        eof_index = first_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eof_ &amp;&amp; _output.<span class="built_in">bytes_written</span>() == eof_index) _output.<span class="built_in">end_input</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调了一天，终于过了，再多调一下就会爆炸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Testing the stream reassembler...</span></span><br><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">      Start 15: t_strm_reassem_single</span><br><span class="line"> 1/16 Test #15: t_strm_reassem_single ............   Passed    0.00 sec</span><br><span class="line">      Start 16: t_strm_reassem_seq</span><br><span class="line"> 2/16 Test #16: t_strm_reassem_seq ...............   Passed    0.00 sec</span><br><span class="line">      Start 17: t_strm_reassem_dup</span><br><span class="line"> 3/16 Test #17: t_strm_reassem_dup ...............   Passed    0.01 sec</span><br><span class="line">      Start 18: t_strm_reassem_holes</span><br><span class="line"> 4/16 Test #18: t_strm_reassem_holes .............   Passed    0.00 sec</span><br><span class="line">      Start 19: t_strm_reassem_many</span><br><span class="line"> 5/16 Test #19: t_strm_reassem_many ..............   Passed    0.11 sec</span><br><span class="line">      Start 20: t_strm_reassem_overlapping</span><br><span class="line"> 6/16 Test #20: t_strm_reassem_overlapping .......   Passed    0.00 sec</span><br><span class="line">      Start 21: t_strm_reassem_win</span><br><span class="line"> 7/16 Test #21: t_strm_reassem_win ...............   Passed    0.12 sec</span><br><span class="line">      Start 22: t_byte_stream_construction</span><br><span class="line"> 8/16 Test #22: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">      Start 23: t_byte_stream_one_write</span><br><span class="line"> 9/16 Test #23: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">      Start 24: t_byte_stream_two_writes</span><br><span class="line">10/16 Test #24: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">      Start 25: t_byte_stream_capacity</span><br><span class="line">11/16 Test #25: t_byte_stream_capacity ...........   Passed    0.00 sec</span><br><span class="line">      Start 26: t_byte_stream_many_writes</span><br><span class="line">12/16 Test #26: t_byte_stream_many_writes ........   Passed    0.01 sec</span><br><span class="line">      Start 27: t_webget</span><br><span class="line">13/16 Test #27: t_webget .........................   Passed    0.47 sec</span><br><span class="line">      Start 47: t_address_dt</span><br><span class="line">14/16 Test #47: t_address_dt .....................   Passed    0.01 sec</span><br><span class="line">      Start 48: t_parser_dt</span><br><span class="line">15/16 Test #48: t_parser_dt ......................   Passed    0.00 sec</span><br><span class="line">      Start 49: t_socket_dt</span><br><span class="line">16/16 Test #49: t_socket_dt ......................   Passed    0.01 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 16</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CS144 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab Checkpoint 0:networking warmup</title>
      <link href="/2023/05/06/cs144/cs144lab0/"/>
      <url>/2023/05/06/cs144/cs144lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="cs144-lab-checkpoint-0-networking-warmup"><a class="markdownIt-Anchor" href="#cs144-lab-checkpoint-0-networking-warmup">#</a> CS144 Lab Checkpoint 0: networking warmup</h1><p>visit  <a href="http://cs144.keithw.org/hello">http://cs144.keithw.org/hello</a></p><p>the result is Hello, CS144!</p><h4 id="on-ecs"><a class="markdownIt-Anchor" href="#on-ecs">#</a> on ECS</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet cs144.keithw.org http</span><br><span class="line"></span><br><span class="line">Trying 104.196.238.229...</span><br><span class="line">Connected to cs144.keithw.org.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /hello HTTP/1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="listening-and-connecting"><a class="markdownIt-Anchor" href="#listening-and-connecting">#</a> Listening and connecting</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netcat -v -l -p 9090</span><br><span class="line">telnet localhost 9090</span><br></pre></td></tr></table></figure><h3 id="writing-a-network-program-using-an-os-stream-socket"><a class="markdownIt-Anchor" href="#writing-a-network-program-using-an-os-stream-socket">#</a> Writing a network program using an OS stream socket</h3><p>我真蠢，真的，配了一天环境。</p><h4 id="writing-webget"><a class="markdownIt-Anchor" href="#writing-webget">#</a> Writing webget</h4><p>这个还是比较简单的，轻松就可以拿下</p><p>是让我们实现 get_url 这个函数，就是向指定地址发送一个 http 请求，然后做出响应即可。</p><p>注意讲义的要求就可以完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line">    TCPSocket socket;</span><br><span class="line">    socket.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    socket.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span>+path+<span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span>+host+<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    socket.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    <span class="keyword">while</span>(!socket.<span class="built_in">eof</span>())&#123;</span><br><span class="line">        cout&lt;&lt;socket.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    socket.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 06 May 2023 03:25:15 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT</span><br><span class="line">ETag: &quot;e-57ce93446cb64&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 14</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Hello, CS144!</span><br></pre></td></tr></table></figure><p>运行测试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 27: t_webget</span><br><span class="line">1/1 Test #27: t_webget .........................   Passed    0.54 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 1</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.55 sec</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target check_webget</span></span><br></pre></td></tr></table></figure><h4 id="an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#an-in-memory-reliable-byte-stream">#</a> An in-memory reliable byte stream</h4><p>这个也还行，就是中间修改完一直忘记重新 make 了，一直 66.7%, 不知道脑子在抽风什么。</p><p>我这个人 remake 得了</p><p>对 ByteStream 定义如下私有变量</p><p>缓冲区就选 deque，因为这是双端的，实验其实要求就是一端读，一端写，正好 deque 符合啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; buffer= &#123;&#125;;<span class="comment">//缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> Capacity_ ;<span class="comment">//容量</span></span><br><span class="line">    <span class="type">size_t</span> Read_Cnt_ = <span class="number">0</span>;<span class="comment">//读计数</span></span><br><span class="line">    <span class="type">size_t</span> Write_Cnt_ = <span class="number">0</span>;<span class="comment">//写计数</span></span><br><span class="line">    <span class="type">bool</span> Input_End_flag_= <span class="literal">false</span>;<span class="comment">//输入终止标识</span></span><br><span class="line">    <span class="type">bool</span> _error = <span class="literal">false</span>;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br></pre></td></tr></table></figure><p>然后就是写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(data);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">min</span>(data.<span class="built_in">size</span>(), Capacity_ - buffer.<span class="built_in">size</span>());</span><br><span class="line">    Write_Cnt_ += len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        buffer.<span class="built_in">emplace_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的一看便知，lab0 还是蛮 easy 的，只要把环境调试好，别搞太多幺蛾子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(len);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">min</span>(len, buffer.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(buffer.<span class="built_in">begin</span>(), buffer.<span class="built_in">begin</span>() + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">min</span>(len, buffer.<span class="built_in">size</span>());</span><br><span class="line">    Read_Cnt_ += length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i ++) buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Input_End_flag_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Input_End_flag_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; <span class="built_in">input_ended</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Write_Cnt_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Read_Cnt_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Capacity_ - <span class="built_in">buffer_size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 22: t_byte_stream_construction</span><br><span class="line">1/9 Test #22: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">    Start 23: t_byte_stream_one_write</span><br><span class="line">2/9 Test #23: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">    Start 24: t_byte_stream_two_writes</span><br><span class="line">3/9 Test #24: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">    Start 25: t_byte_stream_capacity</span><br><span class="line">4/9 Test #25: t_byte_stream_capacity ...........   Passed    0.00 sec</span><br><span class="line">    Start 26: t_byte_stream_many_writes</span><br><span class="line">5/9 Test #26: t_byte_stream_many_writes ........   Passed    0.01 sec</span><br><span class="line">    Start 27: t_webget</span><br><span class="line">6/9 Test #27: t_webget .........................   Passed    0.89 sec</span><br><span class="line">    Start 47: t_address_dt</span><br><span class="line">7/9 Test #47: t_address_dt .....................   Passed    0.01 sec</span><br><span class="line">    Start 48: t_parser_dt</span><br><span class="line">8/9 Test #48: t_parser_dt ......................   Passed    0.01 sec</span><br><span class="line">    Start 49: t_socket_dt</span><br><span class="line">9/9 Test #49: t_socket_dt ......................   Passed    0.01 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 9</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.95 sec</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target check_lab0</span></span><br></pre></td></tr></table></figure><p>lab0 还是比较 easy，只要把环境配置好，然后注意下 Git 以及 Cmake。</p><p>其余问题不大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS144 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day20</title>
      <link href="/2023/05/06/shuati/day20/"/>
      <url>/2023/05/06/shuati/day20/</url>
      
        <content type="html"><![CDATA[<h4 id="131-分割回文串"><a class="markdownIt-Anchor" href="#131-分割回文串">#</a> <a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h4><p>给你一个字符串  <code>s</code> ，请你将  <code>s</code>  分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回  <code>s</code>  所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; r;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d;i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ishuiwen</span>(s, d, i)) &#123;</span><br><span class="line">                string str = s.<span class="built_in">substr</span>(d, i-d+<span class="number">1</span>);</span><br><span class="line">                r.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ishuiwen</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="93-复原-ip-地址"><a class="markdownIt-Anchor" href="#93-复原-ip-地址">#</a> <a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于  <code>0</code>  到  <code>255</code>  之间组成，且不能含有前导  <code>0</code> ），整数之间用  <code>'.'</code>  分隔。</p><ul><li>例如： <code>&quot;0.1.2.201&quot;</code>  和 <code> &quot;192.168.1.1&quot;</code>  是 <strong>有效</strong> IP 地址，但是  <code>&quot;0.011.255.245&quot;</code> 、 <code>&quot;192.168.1.312&quot;</code>  和  <code>&quot;192.168@1.1&quot;</code>  是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串  <code>s</code>  ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在  <code>s</code>  中插入  <code>'.'</code>  来形成。你 <strong>不能</strong> 重新排序或删除  <code>s</code>  中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isrule</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; l != r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt;<span class="string">&#x27;0&#x27;</span> || s[i] &gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = n * <span class="number">10</span> + s[i] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s, d, s.<span class="built_in">size</span>()<span class="number">-1</span>)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s,d,i)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>); </span><br><span class="line">                p ++;</span><br><span class="line">                <span class="built_in">dfs</span>(s, i+<span class="number">2</span>, p);</span><br><span class="line">                p --;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> res; </span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集">#</a> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p>给你一个整数数组  <code>nums</code>  ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (d == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不在状态，困死惹</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day19</title>
      <link href="/2023/05/05/shuati/day19/"/>
      <url>/2023/05/05/shuati/day19/</url>
      
        <content type="html"><![CDATA[<h4 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合">#</a> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数  <code>n</code>  和  <code>k</code> ，返回范围  <code>[1, n]</code>  中所有可能的  <code>k</code>  个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= n; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="216-组合总和-iii"><a class="markdownIt-Anchor" href="#216-组合总和-iii">#</a> <a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><p>找出所有相加之和为  <code>n</code>  的  <code>k</code>  个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k, <span class="type">int</span> tar, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == tar) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; tar) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= <span class="number">9</span>-(k-r.<span class="built_in">size</span>())+<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k, tar, sum);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合">#</a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; board = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//表示按到了键盘上的第几个键</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board[num].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(board[num][i]);  </span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, digits);  <span class="comment">//递归下一层</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();      <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28-找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#28-找出字符串中第一个匹配项的下标">#</a> <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><p>给你两个字符串  <code>haystack</code>  和  <code>needle</code>  ，请你在  <code>haystack</code>  字符串中找出  <code>needle</code>  字符串的第一个匹配项的下标（下标从 0 开始）。如果  <code>needle</code>  不是  <code>haystack</code>  的一部分，则返回  <code>-1</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pipei</span><span class="params">(string haystack, string needle, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle[y] == haystack[x] &amp;&amp; y == needle.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> haystack[x] == needle[y] &amp;&amp; <span class="built_in">pipei</span>(haystack, needle, x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pipei</span>(haystack, needle, i, <span class="number">0</span>)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP 优化版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置哨兵</span></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//预处理next数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="459-重复的子字符串"><a class="markdownIt-Anchor" href="#459-重复的子字符串">#</a> <a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><p>给定一个非空的字符串  <code>s</code>  ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; query, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = query.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是 KMP，掌握不是很熟练，明日重点 KMP.</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础</title>
      <link href="/2023/05/04/c/"/>
      <url>/2023/05/04/c/</url>
      
        <content type="html"><![CDATA[<h4 id="内联函数和普通函数的区别"><a class="markdownIt-Anchor" href="#内联函数和普通函数的区别">#</a> 内联函数和普通函数的区别</h4><p>省去函数调用开销</p><h4 id="c为什么支持函数重载c语言不支持"><a class="markdownIt-Anchor" href="#c为什么支持函数重载c语言不支持">#</a> C++ 为什么支持函数重载，C 语言不支持</h4><p>C++ 产生函数符号的时候，是由函数名 + 参数列表类型组成</p><p>C 代码是由函数名来决定的</p><h4 id="函数重载需要注意什么"><a class="markdownIt-Anchor" href="#函数重载需要注意什么">#</a> 函数重载需要注意什么</h4><h4 id="c和c语言代码之间如何调用"><a class="markdownIt-Anchor" href="#c和c语言代码之间如何调用">#</a> C++ 和 C 语言代码之间如何调用</h4><p><strong>extern &quot;C&quot; 的主要作用就是为了能够正确实现 C<ins> 代码调用其他 C 语言代码。加上 extern &quot;C&quot; 后，会指示编译器这部分代码按 C 语言（而不是 C</ins>）的方式进行编译。由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</strong></p><p>这个功能十分有用处，因为在 C<ins> 出现以前，很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，** 为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C</ins> 中尽可能的支持 C，而 extern &quot;C&quot; 就是其中的一个策略。**</p><p><strong>这个功能主要用在下面的情况：</strong></p><ol><li><strong>C++ 代码调用 C 语言代码</strong></li><li><strong>在 C++ 的头文件中使用</strong></li><li><strong>在多个人协同开发时，可能有的人比较擅长 C 语言，而有的人擅长 C++，这样的情况下也会有用到</strong></li></ol><p>看一个简单的例子：</p><p>有 moduleA、moduleB 两个模块，B 调用 A 中的代码，其中 A 是用 C 语言实现的，而 B 是利用 C++ 实现的，下面给出一种实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//moduleA头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MODULE_A_H <span class="comment">//对于模块A来说，这个宏是为了防止头文件的重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_A_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleA实现文件moduleA.C //模块A的实现部分并没有改变</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB头文件</span></span><br><span class="line"><span class="meta">#idndef __MODULE_B_H <span class="comment">//很明显这一部分也是为了防止重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">//而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件， extern &quot;C&quot;&#123; //因为cpp文件默认定义了该宏),则采用C语言方式进行编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">… <span class="comment">//其他代码</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB实现文件 moduleB.cpp //B模块的实现也没有改变，只是头文件的设计变化了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleB.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充介绍：</p><p>由于 C、C<ins> 编译器对函数的编译处理是不完全相同的，尤其对于 C</ins> 来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。</p><p>例如函数<strong> void fun (int, int)，编译后的可能是_fun_int_int (不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而 C 语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun 这样的名字。</strong></p><p>看下面的一个面试题：为什么标准头文件都有类似的结构？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __INCvxWorksh <span class="comment">/*防止该头文件被重复引用*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INCvxWorksh</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus             <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*…*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*end of __INCvxWorksh*/</span></span></span><br></pre></td></tr></table></figure><p><strong>extern &quot;C&quot; 包含双重含义</strong>，从字面上可以知道，首先，被它修饰的目标是 &quot;extern&quot; 的；其次，被它修饰的目标代码是 &quot;C&quot; 的。</p><ul><li>被 extern &quot;C&quot; 限定的函数或变量是 extern 类型的</li></ul><p>extern 是 C/C++ 语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。</p><p><strong>记住</strong>，语句：<strong>extern int a; 仅仅是一个变量的声明，其并不是在定义变量 a，也并未为 a 分配空间。变量 a 在所有模块中作为一种全局变量只能被定义一次，否则会出错。</strong></p><p>通常来说 **，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字 extern 生命。** 例如，如果模块 B 要引用模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但并不会报错；它会在链接阶段从模块 A 编译生成的目标代码中找到该函数。</p><p><strong>extern 对应的关键字是 static，static 表明变量或者函数只能在本模块中使用，因此，被 static 修饰的变量或者函数不可能被 extern C 修饰。</strong></p><ul><li><strong>被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式进行编译和链接的：这点很重要！！！！</strong></li></ul><p>上面也提到过，由于 C<ins> 支持函数重载，而 C 语言不支持，因此函数被 C</ins> 编译后在<strong>符号库</strong>中的名字是与 C 语言不同的；C++ 编译后的函数需要加上参数的类型才能唯一标定重载后的函数，而加上 extern &quot;C&quot; 后，是为了向编译器指明这段代码按照 C 语言的方式进行编译</p><p>未加 extern &quot;C&quot; 声明时的链接方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//模块A头文件 moduleA.h</span><br><span class="line">#idndef _MODULE_A_H</span><br><span class="line">#define _MODULE_A_H</span><br><span class="line"> </span><br><span class="line">int foo(int x, int y);</span><br><span class="line">#endif　</span><br></pre></td></tr></table></figure><p>在模块 B 中调用该函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//模块B实现文件 moduleB.cpp</span><br><span class="line">#include&quot;moduleA.h&quot;</span><br><span class="line">foo(2,3);　</span><br></pre></td></tr></table></figure><p>实际上，<strong>在链接阶段，链接器会从模块 A 生成的目标文件 moduleA.obj 中找_foo_int_int 这样的符号，显然这是不可能找到的，因为 foo () 函数被编译成了_foo 的符号，因此会出现链接错误。</strong></p><p><strong>extern &quot;C&quot; 的使用要点总结</strong></p><p>1，可以是如下的单一语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; double sqrt(double);</span><br></pre></td></tr></table></figure><p>2，可以是复合语句，相当于复合语句中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">      double sqrt(double);</span><br><span class="line">      int min(int, int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，可以包含头文件，相当于头文件中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    ＃include &lt;cmath&gt;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure><ul><li>不可以将 extern “C” 添加在函数内部</li><li>如果函数有多个声明，可以都加 extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。</li><li>除 extern “C”, 还有 extern “FORTRAN” 等。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day18</title>
      <link href="/2023/05/04/shuati/day18/"/>
      <url>/2023/05/04/shuati/day18/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列">#</a> <a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><p>开个数组记录一下不重复，开一个哈希表避免结果里有重复元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; jud;</span><br><span class="line">    unordered_map &lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,  <span class="type">int</span> d, <span class="type">int</span> n, string r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == n &amp;&amp; m.<span class="built_in">count</span>(r) == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">            m[r] == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jud[i]) &#123;</span><br><span class="line">                r.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                jud[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s, d + <span class="number">1</span>, n, r);</span><br><span class="line">                r.<span class="built_in">pop_back</span>();</span><br><span class="line">                jud[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        jud.<span class="built_in">resize</span>(<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">        string r;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>(), r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-43-1~n-整数中-1-出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-43-1~n-整数中-1-出现的次数">#</a> <a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p>输入一个整数  <code>n</code>  ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。</p><p>例如，输入 12，1～12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mulk = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; n &gt;= mulk; ++k) &#123;</span><br><span class="line">            ans += (n / (mulk * <span class="number">10</span>)) * mulk + <span class="built_in">min</span>(<span class="built_in">max</span>(n % (mulk * <span class="number">10</span>) - mulk + <span class="number">1</span>, <span class="number">0LL</span>), mulk);</span><br><span class="line">            mulk *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="541-反转字符串-ii"><a class="markdownIt-Anchor" href="#541-反转字符串-ii">#</a> <a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串  <code>s</code>  和一个整数  <code>k</code> ，从字符串开头算起，每计数至  <code>2k</code>  个字符，就反转这  <code>2k</code>  字符中的前  <code>k</code>  个字符。</p><ul><li>如果剩余字符少于  <code>k</code>  个，则将剩余字符全部反转。</li><li>如果剩余字符小于  <code>2k</code>  但大于或等于  <code>k</code>  个，则反转前  <code>k</code>  个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; i += 2 * k) &#123;</span><br><span class="line">            reverse(s.begin() + i, s.begin() + min(i + k, n));</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-05-替换空格"><a class="markdownIt-Anchor" href="#剑指-offer-05-替换空格">#</a> <a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串  <code>s</code>  中的每个空格替换成 &quot;%20&quot;。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a class="markdownIt-Anchor" href="#151-反转字符串中的单词">#</a> <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><p>给你一个字符串  <code>s</code>  ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。 <code>s</code>  中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>** 注意：** 输入字符串  <code>s</code>  中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p>好几种写法，用了下双端队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span>) ++left;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">&#x27; &#x27;</span>) --right;</span><br><span class="line">        deque&lt;string&gt; d;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[left];</span><br><span class="line">            <span class="keyword">if</span> (word.<span class="built_in">size</span>() &amp;&amp; c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += c;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += d.<span class="built_in">front</span>();</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/05/04/qmi/"/>
      <url>/2023/05/04/qmi/</url>
      
        <content type="html"><![CDATA[<p>\875. 快速幂</p><p>给定 n  组 ai,bi,pi  ,  ,  ，对于每组数据，求出 abiimodpi    mod   的值。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含整数 n 。</p><p>接下来 n  行，每行包含三个整数 ai,bi,pi  ,  ,  。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>对于每组数据，输出一个结果，表示 abiimodpi    mod   的值。</p><p>每个结果占一行。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤1000001≤ ≤100000,<br>1≤ai,bi,pi≤2×1091≤  , ≤2×109</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 2 5</span><br><span class="line">4 3 9</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>快速幂，类似于二进制优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * t % p;</span><br><span class="line">        t = (<span class="type">long</span> <span class="type">long</span>) t * t % p;</span><br><span class="line">        k &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">qmi</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day17</title>
      <link href="/2023/05/03/shuati/day17/"/>
      <url>/2023/05/03/shuati/day17/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-offer-60-n个骰子的点数"><a class="markdownIt-Anchor" href="#剑指-offer-60-n个骰子的点数">#</a> <a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n 个骰子的点数</a></h4><p>把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure><p>Dp，找到状态转移方程就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">70</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i ++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">6</span>*i; j &gt;= i; j --) &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> cur = <span class="number">1</span>; cur &lt;= <span class="number">6</span>; cur ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - cur &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] += dp[j-cur];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> all = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= <span class="number">6</span> * n; i ++) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(dp[i] * <span class="number">1.0</span> / all);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润">#</a> <a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p>一个维护最大值，一个维护最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i]-m);</span><br><span class="line">            m = <span class="built_in">min</span>(m, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-66-构建乘积数组"><a class="markdownIt-Anchor" href="#剑指-offer-66-构建乘积数组">#</a> <a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p>给定一个数组  <code>A[0,1,…,n-1]</code> ，请构建一个数组  <code>B[0,1,…,n-1]</code> ，其中  <code>B[i]</code>  的值是数组  <code>A</code>  中除了下标  <code>i</code>  以外的元素的积，即  <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code> 。不能使用除法。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><p>各开一个数组记录左右乘积</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            l[i] = l[i<span class="number">-1</span>]*a[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            r[i] = r[i+<span class="number">1</span>]*a[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            b[i] *= l[i];</span><br><span class="line">            b[i] *= r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#剑指-offer-46-把数字翻译成字符串">#</a> <a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><p>爬楼梯进阶版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num); </span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="type">int</span> t = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>)    </span><br><span class="line">                    f[i] += f[i - <span class="number">2</span>];     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#剑指-offer-45-把数组排成最小的数">#</a> <a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p>排序就行，自定义一下排序规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">            string s1 = <span class="built_in">to_string</span>(n1), s2 = <span class="built_in">to_string</span>(n2);</span><br><span class="line">            <span class="built_in">return</span> (s1 + s2) &lt; (s2 + s1);</span><br><span class="line">        &#125;);</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) ret += <span class="built_in">to_string</span>(e);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-44-数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#剑指-offer-44-数字序列中某一位的数字">#</a> <a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p>数字以 0123456789101112131415… 的格式序列化到一个字符序列中。在这个序列中，第 5 位（从下标 0 开始计数）是 5，第 13 位是 1，第 19 位是 4，等等。</p><p>请写一个函数，求任意第 n 位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; (<span class="type">long</span>) d * count) &#123;</span><br><span class="line">            n -= d * count;</span><br><span class="line">            d++;</span><br><span class="line">            count *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start = (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> num = start + index / d;</span><br><span class="line">        <span class="type">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="type">int</span> digit = (num / (<span class="type">int</span>) (<span class="built_in">pow</span>(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day16</title>
      <link href="/2023/04/30/shuati/day16/"/>
      <url>/2023/04/30/shuati/day16/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-offer-33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#剑指-offer-33-二叉搜索树的后序遍历序列">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回  <code>true</code> ，否则返回  <code>false</code> 。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>注意下二叉搜索树的性质即可快速求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p ++;</span><br><span class="line">        <span class="type">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, i, m - <span class="number">1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, j - <span class="number">1</span>) &amp;&amp; (p == j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的大小顺序排列是：左中右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串">#</a> <a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>动态规划</p><p>哈希表 + 动态规划</p><p>开一个哈希表存上次出现的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        mp[s[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> j = mp[s[i]];</span><br><span class="line">                <span class="keyword">if</span> (i-j &gt; f[i<span class="number">-1</span>]) f[i] = f[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i] = i-j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])==<span class="number">0</span>) &#123;</span><br><span class="line">                f[i] = f[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-56-i-数组中数字出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-56-i-数组中数字出现的次数">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组  <code>nums</code>  里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O (n)，空间复杂度是 O (1)。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p>此题甚妙</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU算法实现</title>
      <link href="/2023/04/30/lru/"/>
      <url>/2023/04/30/lru/</url>
      
        <content type="html"><![CDATA[<h3 id="实现lru算法"><a class="markdownIt-Anchor" href="#实现lru算法">#</a> 实现 LRU 算法</h3><p>LRU-least recently used - 最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</p><p>可以使用双向链表加哈希表</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现LRU缓存机制</span></span><br><span class="line"><span class="comment">//LRU-least recently used-最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_lru.<span class="built_in">count</span>(x)==<span class="number">0</span>) &#123; <span class="comment">//此事时没有这个key</span></span><br><span class="line">            <span class="keyword">if</span> (size_lru &lt; v) &#123;<span class="comment">//此时LRU未满</span></span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">                size_lru ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> front_node = node_lru.<span class="built_in">front</span>();</span><br><span class="line">                hash_lru.<span class="built_in">erase</span>(front_node);</span><br><span class="line">                node_lru.<span class="built_in">pop_front</span>();</span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//存在这个</span></span><br><span class="line">            node_lru.<span class="built_in">remove</span>(x);</span><br><span class="line">            node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash_lru[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = node_lru.<span class="built_in">back</span>();</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k:node_lru) cout&lt;&lt;k&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LRU</span>(<span class="type">int</span> x,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">v</span>(x), <span class="built_in">size_lru</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash_lru;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; node_lru;</span><br><span class="line">    <span class="type">int</span> size_lru;<span class="comment">//当前节点数量</span></span><br><span class="line">    <span class="type">int</span> v;<span class="comment">//容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">0 </span><br><span class="line">3 </span><br><span class="line">0 </span><br><span class="line">4 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">7 0 </span><br><span class="line">0 1 </span><br><span class="line">1 2 </span><br><span class="line">2 0 </span><br><span class="line">0 3 </span><br><span class="line">3 0 </span><br><span class="line">0 4 </span><br></pre></td></tr></table></figure><p>7<br>7 0<br>7 0 1<br>0 1 2<br>1 2 0<br>2 0 3<br>2 3 0<br>3 0 4</p><p>没问题，表现良好</p>]]></content>
      
      
      
        <tags>
            
            <tag> LRU算法实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2023/04/29/weiyuansuan/"/>
      <url>/2023/04/29/weiyuansuan/</url>
      
        <content type="html"><![CDATA[<h3 id="1位运算概述"><a class="markdownIt-Anchor" href="#1位运算概述">#</a> 1. 位运算概述</h3><p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*、/) 都是叫位运算，即将符号位共同参与运算的运算。</p><p>口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 35;</span><br><span class="line">int b = 47;</span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure><p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">35:  0 0 1 0 0 0 1 1</span><br><span class="line">47:  0 0 1 0 1 1 1 1</span><br><span class="line">————————————————————</span><br><span class="line">82:  0 1 0 1 0 0 1 0</span><br></pre></td></tr></table></figure><p>所以，相比在代码中直接使用 (+、-、*、/) 运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。</p><h3 id="2位运算概览"><a class="markdownIt-Anchor" href="#2位运算概览">#</a> 2. 位运算概览</h3><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th><th style="text-align:left">运算规则</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">与</td><td style="text-align:left">两个位都为 1 时，结果才为 1</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">或</td><td style="text-align:left">两个位都为 0 时，结果才为 0</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">异或</td><td style="text-align:left">两个位相同为 0，相异为 1</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">取反</td><td style="text-align:left">0 变 1，1 变 0</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移</td><td style="text-align:left">各二进位全部左移若干位，高位丢弃，低位补 0</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移</td><td style="text-align:left">各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）</td></tr></tbody></table><h3 id="3按位与运算符"><a class="markdownIt-Anchor" href="#3按位与运算符">#</a> 3. 按位与运算符（&amp;）#</h3><p><strong>定义</strong>：参加运算的两个数据，按二进制位进行 &quot;与&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&amp;0=0  0&amp;1=0  1&amp;0=0  1&amp;1=1</span><br></pre></td></tr></table></figure><p>总结：两位同时为 1，结果才为 1，否则结果为 0。</p><p>例如：3&amp;5 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得 1。</p><p>注意：负数按补码形式参加按位与运算。</p><p><strong>与运算的用途：</strong></p><p>1）清零</p><p>如果想将一个单元清零，即使其全部二进制位为 0，只要与一个各位都为零的数值相与，结果为零。</p><p>2）取一个数的指定位</p><p>比如取数 X=1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位与运算（X&amp;Y=0000 1110）即可得到 X 的指定位。</p><p>3）判断奇偶</p><p>只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a &amp; 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。</p><p>4. 按位或运算符（|）</p><p>定义：参加运算的两个对象，按二进制位进行 &quot;或&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0|0=0  0|1=1  1|0=1  1|1=1</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为 1，其值为 1。</p><p>例如：3|5 即 0000 0011| 0000 0101 = 0000 0111，因此，3|5 的值得 7。</p><p>注意：负数按补码形式参加按位或运算。</p><p>或运算的用途：</p><p>1）常用来对一个数据的某些位设置为 1</p><p>比如将数 X=1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位或运算（X|Y=1010 1111）即可得到。</p><p>5. 异或运算符（^）</p><p>定义：参加运算的两个数据，按二进制位进行 &quot;异或&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0^0=0  0^1=1  1^0=1  1^1=0</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为 0，相异为 1。</p><p>异或的几条性质:</p><ul><li>1、交换律</li><li>2、结合律 (a<sup>b)</sup>c == a<sup>(b</sup>c)</li><li>3、对于任何数 x，都有 x<sup>x=0，x</sup>0=x</li><li>4、自反性: a<sup>b</sup>b=a^0=a;</li></ul><p>异或运算的用途：</p><p>1）翻转指定位</p><p>比如将数 X=1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行异或运算（X^Y=1010 0001）即可得到。</p><p>2）与 0 相异或值不变</p><p>例如：1010 1110 ^ 0000 0000 = 1010 1110</p><p>3）交换两个数</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例">#</a> 实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a != b)&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6. 取反运算符 (~)</p><p>定义：参加运算的一个数据，按二进制进行 &quot;取反&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~1=0</span><br><span class="line">~0=1</span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将 0 变 1，1 变 0。</p><p>异或运算的用途：</p><p>1）使一个数的最低位为零</p><p>使 a 的最低位为 0，可以表示为：a &amp; <sub>1。</sub>1 的值为 1111 1111 1111 1110，再按 &quot;与&quot; 运算，最低位一定为 0。因为 &quot;~&quot; 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p><p>7. 左移运算符（&lt;&lt;）</p><p>定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。</p><p>设 a=1010 1110，a = a&lt;&lt; 2 将 a 的二进制位左移 2 位、右补 0，即得 a=1011 1000。</p><p>若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2。</p><p>8. 右移运算符（&gt;&gt;）</p><p>定义：将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。</p><p>例如：a=a&gt;&gt;2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以 2。</p><p>10. 复合赋值运算符</p><p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;=        例：a&amp;=b    相当于     a=a&amp;b</span><br><span class="line"></span><br><span class="line">|=        例：a|=b    相当于     a=a|b</span><br><span class="line"></span><br><span class="line">&gt;&gt;=      例：a&gt;&gt;=b   相当于     a=a&gt;&gt;b</span><br><span class="line"></span><br><span class="line">&lt;&lt;=      例：a&lt;&lt;=b     相当于      a=a&lt;&lt;b</span><br><span class="line"></span><br><span class="line">^=        例：a^=b    相当于   a=a^b</span><br></pre></td></tr></table></figure><p>运算规则：和前面讲的复合赋值运算符的运算规则相似。</p><p>不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p><p>以 &quot;与运算&quot; 为例说明如下：我们知道在 C 语言中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行 &quot;与运算&quot;，右端对齐后，左边不足的位依下面三种情况补足，</p><ul><li><p>1）如果整型数据为正数，左边补 16 个 0。</p></li><li><p>2）如果整型数据为负数，左边补 16 个 1。</p></li><li><p>3）如果整形数据为无符号数，左边也补 16 个 0。</p></li><li><p>如：long a=123；int b=1；计算 a&amp; b。</p></li><li></li><li><p>如：long a=123；int b=-1；计算 a&amp; b。</p></li><li><p>如：long a=123；unsigned intb=1；计算 a &amp; b。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day15</title>
      <link href="/2023/04/29/shuati/day15/"/>
      <url>/2023/04/29/shuati/day15/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-offer-13-机器人的运动范围"><a class="markdownIt-Anchor" href="#剑指-offer-13-机器人的运动范围">#</a> <a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>地上有一个 m 行 n 列的方格，从坐标  <code>[0,0]</code>  到坐标  <code>[m-1,n-1]</code>  。一个机器人从坐标  <code>[0, 0] </code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>将满足条件的格子置为 1，不满住的置为 0，然后对起点做一个 dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rx = <span class="number">0</span>, ry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            rx += x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            ry += y%<span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rx + ry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m,<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m[x][y] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        m[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; m[x<span class="number">-1</span>][y]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span>&lt;m.<span class="built_in">size</span>() &amp;&amp; m[x+<span class="number">1</span>][y]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; m[x][y<span class="number">-1</span>]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(y+<span class="number">1</span>&lt;m[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; m[x][y+<span class="number">1</span>]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x, y+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j= <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get_value</span>(i, j) &gt; k) a[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> a[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(a,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-14-ii-剪绳子-ii"><a class="markdownIt-Anchor" href="#剑指-offer-14-ii-剪绳子-ii">#</a> <a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><p>给你一根长度为  <code>n</code>  的绳子，请把绳子剪成整数长度的  <code>m</code>  段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为  <code>k[0],k[1]...k[m - 1]</code>  。请问  <code>k[0]*k[1]*...*k[m - 1]</code>  可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = n / <span class="number">3</span> - <span class="number">1</span>; a &gt; <span class="number">0</span>; a /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">            x = (x * x) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> rem * <span class="number">3</span> % p;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> rem * <span class="number">4</span> % p;</span><br><span class="line">        <span class="keyword">return</span> rem * <span class="number">6</span> % p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-16-数值的整数次方"><a class="markdownIt-Anchor" href="#剑指-offer-16-数值的整数次方">#</a> <a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="type">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-31-栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#剑指-offer-31-栈的压入-弹出序列">#</a> <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p>直接按照题意开整就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            st.<span class="built_in">emplace</span>(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == popped[j]) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识复习</title>
      <link href="/2023/04/29/muduo/muduo1/"/>
      <url>/2023/04/29/muduo/muduo1/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识复习"><a class="markdownIt-Anchor" href="#基础知识复习">#</a> 基础知识复习</h2><h3 id="阻塞-非阻塞-同步-异步"><a class="markdownIt-Anchor" href="#阻塞-非阻塞-同步-异步">#</a> 阻塞、非阻塞、同步、异步</h3><p>典型的一次数据 IO 包含两个阶段：数据准备、数据读写</p><h4 id="数据准备"><a class="markdownIt-Anchor" href="#数据准备">#</a> 数据准备：</h4><ul><li><p>阻塞</p><p>调用 IO 方法的线程进入阻塞状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = recv(sockfd, buf, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果 sockfd 没有数据（默认阻塞)，此时就回阻塞在这里。</p></li><li><p>非阻塞</p><p>不会改变线程的状态，通过返回值判断</p><p>如果非阻塞，会直接返回。(size == -1 &amp;&amp; errno == EAGAIN)</p></li></ul><h4 id="数据读写io的同步和异步"><a class="markdownIt-Anchor" href="#数据读写io的同步和异步">#</a> 数据读写：(IO 的同步和异步)</h4><ul><li><p>同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = recv(sockfd, buf, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果数据没有全部写到缓冲区中，那么将阻塞，且需自己写入缓冲区</p></li><li><p>异步</p><p>异步 IO 接口的时候，当系统 sigio<strong> 通知</strong>的时候，buf 的数据已经准备好了。</p><p>（aio_read, aio_write)</p></li></ul><p>Node.js 基于异步非阻塞模式下的高性能服务器</p><p>在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用特殊的 API 才是异步 IO。</p><h4 id="业务层面的一个逻辑处理是同步还是异步"><a class="markdownIt-Anchor" href="#业务层面的一个逻辑处理是同步还是异步">#</a> 业务层面的一个逻辑处理是同步还是异步？</h4><h5 id="同步"><a class="markdownIt-Anchor" href="#同步">#</a> 同步：</h5><p>A 操作等待 B 操作完成事情，得到返回，继续处理</p><h5 id="异步"><a class="markdownIt-Anchor" href="#异步">#</a> 异步：</h5><p>A 操作告诉 B 操作它感兴趣的事件以及通知方式，A 操作继续自己的业务逻辑，等待 B 监听到响应事件发生后，B 会通知 A，A 开始数据处理逻辑。</p><p>一个典型的网络 IO 接口调用，分为两个阶段，分别是 &quot;数据就绪&quot; 和 &quot;数据读写&quot;， 数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结：</h4><p>同步表示 A 向 B 请求调用一个网络 IO 接口时，数据读写都是由请求方 A 来自己完成的；异步表示 A 向 B 请求调用一个网络 IO 接口时，向 B 传入请求的事件以及事件发生时统治的方式，A 就可以处理其他逻辑了，当 B 监听到事件处理完成后，会用实现约定好的通知方式，通知 A 处理结果</p><h3 id="unixlinux上的五种io模型"><a class="markdownIt-Anchor" href="#unixlinux上的五种io模型">#</a> Unix/Linux 上的五种 IO 模型</h3><ul><li><p>阻塞 blocking</p></li><li><p>非阻塞 non-blocking</p></li><li><p>IO 复用 IO multiplexing</p></li><li><p>信号驱动 signal-driven</p></li><li><p>异步 asynchronous</p></li></ul><h3 id="网络服务器设计"><a class="markdownIt-Anchor" href="#网络服务器设计">#</a> 网络服务器设计</h3><p>one loop pre thread is usually a good model</p><h3 id="reactor模型"><a class="markdownIt-Anchor" href="#reactor模型">#</a> Reactor 模型</h3><p>Event 事件，Reactor 反应堆，Demultiplex 事件分发器，Eventhandler 事件分发器</p><h3 id="epoll"><a class="markdownIt-Anchor" href="#epoll">#</a> epoll</h3><h4 id="select和poll的缺点"><a class="markdownIt-Anchor" href="#select和poll的缺点">#</a> select 和 poll 的缺点</h4><h5 id="select的缺点"><a class="markdownIt-Anchor" href="#select的缺点">#</a> select 的缺点：</h5><p>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是 1024，当然可以更改数量，但由于 select 采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在 linux 内核头文件中，有 这样的定义：#define_FD_SETSIZE 1024 __</p><p>2、内核 / 用户空间内存拷贝问题，select 需要复制大量的句柄数据结构，产生巨大的开销</p><p>3、select 返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</p><p>4、select 的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行 IO 操作， 那么之后每次 select 调用还是会将这些文件描述符通知进程</p><p>相比 select 模型，poll 使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依 然存在。</p><p>以 select 模型为例，假设我们的服务器需要支持 100 万的并发连接，则在__FD_SETSIZE 为 1024 的情况 下，则我们至少需要开辟 1k 个进程才能实现 100 万的并发连接。除了进程间上下文切换的时间消耗外， 从内核 / 用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于 select 模型的 服务器程序，要达到 100 万级别的并发访问，是一个很难完成的任务。</p><h5 id="epoll原理以及优势"><a class="markdownIt-Anchor" href="#epoll原理以及优势">#</a> epoll 原理以及优势</h5><p>epoll 的实现机制与 select/poll 机制完全不同，它们的缺点在 epoll 上不复存在。</p><p>设想一下如下场景：有 100 万个客户端同时与一个服务器进程保持着 TCP 连接。而每一时刻，通常只有 几百上千个 TCP 连接是活跃的 (事实上大部分场景都是这种情况)。如何实现这样的高并发？ 在 select/poll 时代，服务器进程每次都把这 100 万个连接告诉操作系统（从用户态复制句柄数据结构到 内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据复制到用 户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll 一般 只能处理几千的并发连接。</p><p>epoll 的设计和实现与 select 完全不同。epoll 通过在 Linux 内核中申请一个简易的文件系统（文件系统一 般用什么数据结构实现？B + 树，磁盘 IO 消耗低，效率很高）。把原先的 select/poll 调用分成以下 3 个部 分：</p><ul><li>调用 epoll_create () 建立一个 epoll 对象（在 epoll 文件系统中为这个句柄对象分配资源）</li><li>调用 epoll_ctl 向 epoll 对象中添加这 100 万个连接的套接字</li><li>调用 epoll_wait 收集发生的事件的 fd 资源</li></ul><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个 epoll 对象，然后在需要的时候向这 个 epoll 对象中添加或者删除事件。同时，epoll_wait 的效率也非常高，因为调用 epoll_wait 时，并没有 向操作系统复制这 100 万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><p>epoll_create 在内核上创建的 eventpoll 结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line"><span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="lt模式"><a class="markdownIt-Anchor" href="#lt模式">#</a> LT 模式</h4><p>内核数据没被读完，就会一直上报数据。</p><h4 id="et模式"><a class="markdownIt-Anchor" href="#et模式">#</a> ET 模式</h4><p>内核数据只上报一次。</p><h4 id="muduo采用的是lt"><a class="markdownIt-Anchor" href="#muduo采用的是lt">#</a> muduo 采用的是 LT</h4><ul><li>不会丢失数据或者消息 应用没有读取完数据，内核是会不断上报的</li><li>低延迟处理 每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量 过大而影响其他连接处理消息</li><li>跨平台处理 像 select 一样可以跨平台使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> muduo设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针简单设计</title>
      <link href="/2023/04/29/smart-pointers/ptr/"/>
      <url>/2023/04/29/smart-pointers/ptr/</url>
      
        <content type="html"><![CDATA[<h3 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针">#</a> 智能指针</h3><h4 id="关于智能指针的设计"><a class="markdownIt-Anchor" href="#关于智能指针的设计">#</a> 关于智能指针的设计</h4><p>智能指针是为了方便的智能管理内存资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//智能指针 保证能做到资源的自动释放！！！</span></span><br><span class="line"><span class="comment">//利用栈上的对象出作用域自动析构</span></span><br><span class="line"><span class="comment">//不能是堆上</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;<span class="keyword">delete</span> ptr;&#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不带引用计数的智能指针"><a class="markdownIt-Anchor" href="#不带引用计数的智能指针">#</a> 不带引用计数的智能指针</h4><p>如果我们这样：</p><p>smart_ptr<int> p1(new int);<br>smart_ptr<int> p2(p1);</p><p>会发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(): double free detected in tcache 2</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>原因是为拷贝构造默认是一个浅拷贝，相当于对同一份资源释放了两次。</p><h5 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法">#</a> 解决方法</h5><p>1）可以重新定义拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;<span class="keyword">delete</span> ptr;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src) &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">T</span>(*src.ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时运行就不会出错</p><p>2）禁用拷贝构造，即 (unique_ptr)</p><p>保持独占性即可。</p><p>3）当然还有其他的方法，不再赘述，会有安全性的问题</p><h4 id="带引用计数的智能指针设计"><a class="markdownIt-Anchor" href="#带引用计数的智能指针设计">#</a> 带引用计数的智能指针设计</h4><p>加一个计数的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr_cnt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr_cnt</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_cnt</span><span class="params">()</span> </span>&#123; cnt++;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">subtract_cnt</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> --cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="built_in">smart_ptr_cnt</span>&lt;T&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == cnt-&gt;<span class="built_in">subtract_cnt</span>()) <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src): <span class="built_in">ptr</span>(src.ptr), <span class="built_in">cnt</span>(src.cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) cnt-&gt;<span class="built_in">add_cnt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == cnt-&gt;<span class="built_in">subtract_cnt</span>()) <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = src.ptr;</span><br><span class="line">        cnt = src.cnt;</span><br><span class="line">        cnt-&gt;<span class="built_in">add_cnt</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// smart_ptr(const smart_ptr&lt;T&gt; &amp;src) = delete;</span></span><br><span class="line">    <span class="comment">// smart_ptr&lt;T&gt;&amp; operator = (const smart_ptr&lt;T&gt; &amp;) = delete;</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">    <span class="comment">//std::atomic&lt;int&gt; cnt;</span></span><br><span class="line">    smart_ptr_cnt&lt;T&gt; *cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day14</title>
      <link href="/2023/04/29/shuati/day14/"/>
      <url>/2023/04/29/shuati/day14/</url>
      
        <content type="html"><![CDATA[<p>昨天忘发了</p><h4 id="剑指-offer-12-矩阵中的路径"><a class="markdownIt-Anchor" href="#剑指-offer-12-矩阵中的路径">#</a> <a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><p>给定一个  <code>m x n</code>  二维字符网格  <code>board</code>  和一个字符串单词  <code>word</code>  。如果  <code>word</code>  存在于网格中，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>dfs，没什么难的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        rows = board.<span class="built_in">size</span>();</span><br><span class="line">        cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= rows || i &lt; <span class="number">0</span> || j &gt;= cols || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || </span><br><span class="line">                      <span class="built_in">dfs</span>(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-47-礼物的最大价值"><a class="markdownIt-Anchor" href="#剑指-offer-47-礼物的最大价值">#</a> <a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p>没啥难度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = grid.<span class="built_in">size</span>(), r = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(l, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r, <span class="number">0</span>));</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; r; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">0</span>) res[i][j] = <span class="built_in">max</span>(res[i<span class="number">-1</span>][j], res[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) res[i][j] = res[i<span class="number">-1</span>][j]+ grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) res[i][j] = res[i][j<span class="number">-1</span>]+ grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-047-二叉树剪枝"><a class="markdownIt-Anchor" href="#剑指-offer-ii-047-二叉树剪枝">#</a> <a href="https://leetcode.cn/problems/pOCWxh/">剑指 Offer II 047. 二叉树剪枝</a></h4><p>给定一个二叉树 <strong>根节点</strong>  <code>root</code>  ，树的每个节点的值要么是  <code>0</code> ，要么是  <code>1</code> 。请剪除该二叉树中所有节点的值为  <code>0</code>  的子树。</p><p>节点  <code>node</code>  的子树为  <code>node</code>  本身，以及所有  <code>node</code>  的后代。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,0,0,1]</span><br><span class="line">输出: [1,null,0,null,1] </span><br><span class="line">解释: </span><br><span class="line">只有红色节点满足条件“所有不包含 1 的子树”。</span><br><span class="line">右图为返回的答案。</span><br></pre></td></tr></table></figure><p>另外定义一个函数判断一下是否全位 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">iszero</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == <span class="number">0</span> &amp;&amp; <span class="built_in">iszero</span>(root-&gt;left) &amp;&amp; <span class="built_in">iszero</span>(root-&gt;right)) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || <span class="built_in">iszero</span>(root)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">pruneTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">pruneTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-004-只出现一次的数字"><a class="markdownIt-Anchor" href="#剑指-offer-ii-004-只出现一次的数字">#</a> <a href="https://leetcode.cn/problems/WGki4K/">剑指 Offer II 004. 只出现一次的数字 </a></h4><p>给你一个整数数组  <code>nums</code>  ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 ** 三次 。** 请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,1,0,1,100]</span><br><span class="line">输出：100</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] != nums[<span class="number">1</span>] &amp;&amp; nums[<span class="number">1</span>] == nums[<span class="number">2</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>] != nums[nums.<span class="built_in">size</span>()<span class="number">-2</span>] &amp;&amp; nums[nums.<span class="built_in">size</span>()<span class="number">-2</span>] == nums[nums.<span class="built_in">size</span>()<span class="number">-3</span>]) <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i<span class="number">-1</span>] &amp;&amp; nums[i] != nums[i+<span class="number">1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-07-重建二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-07-重建二叉树">#</a> <a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++)</span><br><span class="line">            dic[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(<span class="number">0</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preorder;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dic;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;                        <span class="comment">// 递归终止</span></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="type">int</span> i = dic[preorder[root]];                            <span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        node-&gt;left = <span class="built_in">recur</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        node-&gt;right = <span class="built_in">recur</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;                                            <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点意思这题</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维vector初始化</title>
      <link href="/2023/04/27/some-tips/ve/"/>
      <url>/2023/04/27/some-tips/ve/</url>
      
        <content type="html"><![CDATA[<p>二维 vector 初始化</p><p>今天写题的时候遇到一种情况，二维 vector 初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(l, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>在已知维度的前提下，这种初始化方式就挺不错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者练习题</title>
      <link href="/2023/04/27/some-tips/con-pro/"/>
      <url>/2023/04/27/some-tips/con-pro/</url>
      
        <content type="html"><![CDATA[<h3 id="生产者消费者练习题"><a class="markdownIt-Anchor" href="#生产者消费者练习题">#</a> 生产者消费者练习题</h3><p>线程 A 每隔 10~200ms 按顺序生成 1-100 的数字，放入队列中</p><p>三个线程 B,C,D 即时消费这些数据，线程 B 打印所有被 2 整除的数，线程 C 打印所有被 3 整除的数，线程 D 打印其他数。</p><p>且打印出来的数字得有序</p><p>刷到牛友分享的一道面试题，于是随手做一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line">std::mutex mutex_;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(i);</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0.2</span>);</span><br><span class="line">        i ++;</span><br><span class="line">        i %= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cv.notify_all();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者B线程函数，打印所有被2整除的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerB: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者C线程函数，打印所有被3整除的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerC: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者D线程函数，打印其他数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; x%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerD: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g++ pruduct_cumsor.cpp -o a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动生产者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">consumerB_thread</span><span class="params">(consumerB)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerC_thread</span><span class="params">(consumerC)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerD_thread</span><span class="params">(consumerD)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerB_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerC_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerD_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumerD: 1</span><br><span class="line">consumerB: 2</span><br><span class="line">consumerC: 3</span><br><span class="line">consumerB: 4</span><br><span class="line">consumerD: 5</span><br><span class="line">consumerC: 6</span><br><span class="line">consumerD: 7</span><br><span class="line">consumerB: 8</span><br><span class="line">consumerC: 9</span><br><span class="line">consumerB: 10</span><br><span class="line">consumerD: 11</span><br><span class="line">consumerB: 12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出没啥问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生产者消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day13</title>
      <link href="/2023/04/27/shuati/day13/"/>
      <url>/2023/04/27/shuati/day13/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-offer-20-表示数值的字符串"><a class="markdownIt-Anchor" href="#剑指-offer-20-表示数值的字符串">#</a> <a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个  <code>'e'</code>  或  <code>'E'</code>  ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（ <code>'+'</code>  或  <code>'-'</code> ）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点  <code>'.'</code></li><li>至少一位数字，后面跟着一个点  <code>'.'</code>  ，后面再跟着至少一位数字</li><li>一个点  <code>'.'</code>  ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（ <code>'+'</code>  或  <code>'-'</code> ）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>吐血，本来还想着是否有什么算法可以求解，解决直接来一个有限状态机，算了这种题，再次碰见类似的估计还是想不出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CharType</span> &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">CharType <span class="title">toCharType</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_SPACE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                STATE_INITIAL, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_INITIAL&#125;,</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_INT_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INT_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INTEGER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT_WITHOUT_INT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_FRACTION,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_EXP_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_NUMBER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_END, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        State st = STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            CharType typ = <span class="built_in">toCharType</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (transfer[st].<span class="built_in">find</span>(typ) == transfer[st].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st = transfer[st][typ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-17-打印从1到最大的n位数"><a class="markdownIt-Anchor" href="#剑指-offer-17-打印从1到最大的n位数">#</a> <a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从 1 到最大的 n 位数</a></h4><p>输入数字  <code>n</code> ，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure><p>很简单的一道题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">            r *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; r; i ++) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-14-i-剪绳子"><a class="markdownIt-Anchor" href="#剑指-offer-14-i-剪绳子">#</a> <a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><p>给你一根长度为  <code>n</code>  的绳子，请把绳子剪成整数长度的  <code>m</code>  段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为  <code>k[0],k[1]...k[m-1]</code>  。请问  <code>k[0]*k[1]*...*k[m-1]</code>  可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><p>此题动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dp[3] = 2;</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">max</span>(<span class="number">0</span>, dp[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j*(i-j), j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-40-最小的k个数"><a class="markdownIt-Anchor" href="#剑指-offer-40-最小的k个数">#</a> <a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的 k 个数</a></h4><p>输入整数数组  <code>arr</code>  ，找出其中最小的  <code>k</code>  个数。例如，输入 4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>排序…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) res.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-55-ii-平衡二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-55-ii-平衡二叉树">#</a> <a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong></p><p>给定二叉树  <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回  <code>true</code>  。</p><p>对每个节点都判断一下是否满足，随后看一下子节点是否满足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="built_in">return</span> ((<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right))*(<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right)) &lt;= <span class="number">1</span>) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-27-二叉树的镜像"><a class="markdownIt-Anchor" href="#剑指-offer-27-二叉树的镜像">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p><code>   4  /  \ 2   7 / \  / \1  3 6  9</code> <br> 镜像输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4  /  \ 7   2 / \  / \9  6 3  1</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p>没什么好说的，直接翻转就完事了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="built_in">mirror</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">mirror</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">mirror</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-68-i-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#剑指-offer-68-i-二叉搜索树的最近公共祖先">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* ancestor = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-089-房屋偷盗"><a class="markdownIt-Anchor" href="#剑指-offer-ii-089-房屋偷盗">#</a> <a href="https://leetcode.cn/problems/Gu0c2T/">剑指 Offer II 089. 房屋偷盗</a></h4><p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组  <code>nums</code>  ，请计算 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        res[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="number">0</span>, res[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res[i] = <span class="built_in">max</span>(res[i<span class="number">-1</span>], res[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">            r = <span class="built_in">max</span>(r, res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day12</title>
      <link href="/2023/04/25/shuati/day12/"/>
      <url>/2023/04/25/shuati/day12/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-offer-57-和为s的两个数字"><a class="markdownIt-Anchor" href="#剑指-offer-57-和为s的两个数字">#</a> <a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为 s 的两个数字</a></h4><p>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (slow &lt; fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] &gt; target) fast --;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] &lt; target) slow ++;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] == target) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[slow]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[fast]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-26-树的子结构"><a class="markdownIt-Anchor" href="#剑指-offer-26-树的子结构">#</a> <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)</p><p>B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。</p><p>例如:<br> 给定的树 A:</p><p><code>   3  / \  4  5 / \ 1  2</code> <br> 给定的树 B：</p><p><code>  4  / 1</code> <br> 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>递归判断呗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">iszi</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!A ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iszi</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">iszi</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (A != nullptr &amp;&amp; !B) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (!A || A != <span class="literal">nullptr</span> &amp;&amp; !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">iszi</span>(A, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-57-ii-和为s的连续正数序列"><a class="markdownIt-Anchor" href="#剑指-offer-57-ii-和为s的连续正数序列">#</a> <a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为 s 的连续正数序列</a></h4><p>输入一个正整数  <code>target</code>  ，输出所有和为  <code>target</code>  的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; target; i ++) &#123;</span><br><span class="line">            cnt += i;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (cnt == target) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">                <span class="comment">//return true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; target) &#123;</span><br><span class="line">                <span class="comment">//return false;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; target; i ++) &#123;</span><br><span class="line">            <span class="built_in">get</span>(i, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上来直接暴力了一下，发现超时了</p><p>随后想如何优化，可以用滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">            rr += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) &gt; target) l ++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) &lt; target) r ++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) == target) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) re.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(re);</span><br><span class="line">                l ++;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-58-ii-左旋转字符串"><a class="markdownIt-Anchor" href="#剑指-offer-58-ii-左旋转字符串">#</a> <a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串 &quot;abcdefg&quot; 和数字 2，该函数将返回左旋转两位得到的结果 &quot;cdefgab&quot;。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p>没啥难度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        n %= len;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-32-i-从上到下打印二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-32-i-从上到下打印二叉树">#</a> <a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br> 给定二叉树:  <code>[3,9,20,null,null,15,7]</code> ,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><p>层序遍历而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-04-二维数组中的查找"><a class="markdownIt-Anchor" href="#剑指-offer-04-二维数组中的查找">#</a> <a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target =  <code>5</code> ，返回  <code>true</code> 。</p><p>给定 target =  <code>20</code> ，返回  <code>false</code> 。</p><p>真是烧脑筋，想了又想，还是得结合这个图长得样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现线程安全的懒汉单例模式</title>
      <link href="/2023/04/25/some-tips/danli/"/>
      <url>/2023/04/25/some-tips/danli/</url>
      
        <content type="html"><![CDATA[<h3 id="实现线程安全的懒汉单例模式并定义一个函数获取单例地址"><a class="markdownIt-Anchor" href="#实现线程安全的懒汉单例模式并定义一个函数获取单例地址">#</a> 实现线程安全的懒汉单例模式并定义一个函数获取单例地址</h3><p>昨天面试居然没实现出来，痛定思痛，今天好好写一遍。</p><p>创建这个单例类需要使用静态变量，利用了静态变量的一些性质，静态变量在整个代码运行周期内只会定义一次。</p><p><strong>对于 static 静态局部变量的初始化，编译器会自动对它的初始化进行加锁和解锁控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single *<span class="title">get_single</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Single single_only;</span><br><span class="line">        <span class="keyword">return</span> &amp;single_only;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_dizhi</span><span class="params">(Single *a)</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;create victory&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Single *ah = Single::<span class="built_in">get_single</span>();</span><br><span class="line">    ah-&gt;<span class="built_in">get_dizhi</span>(ah);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create victory</span><br><span class="line">0x560ecd8d9152</span><br><span class="line">0x560ecd8d9152</span><br><span class="line">0x560ecd8d9152</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 线程安全的懒汉单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某厂面试(被薄纱)</title>
      <link href="/2023/04/24/mianshi/mianshi/"/>
      <url>/2023/04/24/mianshi/mianshi/</url>
      
        <content type="html"><![CDATA[<p>怎么这样捏，太紧张了，很多东西都没想起来</p><p>自我介绍开场</p><h4 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h4><h4 id="智能指针熟悉吗介绍下智能指针"><a class="markdownIt-Anchor" href="#智能指针熟悉吗介绍下智能指针">#</a> 智能指针熟悉吗，介绍下智能指针</h4><p>智能指针（Smart Pointer）是一种 C++ 中的类，它的主要作用是管理动态分配的内存资源，从而避免内存泄漏和野指针等常见的内存安全问题。</p><p>智能指针通过重载指针操作符，提供与原生指针类似的使用方式，但其具有以下几个重要的特点：</p><ol><li>自动内存管理：智能指针会在其生命周期结束时自动释放其所管理的内存资源，从而避免了内存泄漏的风险。</li><li>所有权转移：智能指针支持所有权转移，即可以将一个智能指针的所有权转移给另一个智能指针，从而避免了多个指针同时管理同一块内存的问题。</li><li>引用计数：智能指针通常会维护一个引用计数器，用于记录有多少个智能指针共享同一块内存。当引用计数器减为 0 时，智能指针会自动释放其所管理的内存资源。</li><li>类型安全：智能指针可以防止类型不匹配的错误，从而提高程序的稳定性和安全性。</li></ol><h4 id="智能指针是为了解决什么问题提出来的"><a class="markdownIt-Anchor" href="#智能指针是为了解决什么问题提出来的">#</a> 智能指针是为了解决什么问题提出来的</h4><h4 id="为什么会有unique_ptr"><a class="markdownIt-Anchor" href="#为什么会有unique_ptr">#</a> 为什么会有 unique_ptr</h4><p>unique_ptr 是一种独占式智能指针，它的主要特点是只能有一个指针拥有它所管理的内存资源。unique_ptr 的出现主要是为了解决动态内存分配和释放过程中的一些常见问题，具有以下几个优点：</p><ol><li>防止内存泄漏：unique_ptr 能够确保在其生命周期结束时自动释放所管理的内存资源，从而避免了内存泄漏的风险。</li><li>防止多个指针同时访问同一块内存：由于 unique_ptr 是独占式的，即只能有一个指针拥有它所管理的内存资源，因此可以有效避免多个指针同时访问同一块内存的问题。</li><li>支持移动语义：unique_ptr 支持移动语义，即可以将其所有权转移给另一个 unique_ptr 对象，从而避免了显式内存管理过程中的复制和赋值问题。</li><li>更好的性能：unique_ptr 相比原生指针可以更好地支持现代 C++ 的一些高级特性，例如使用 RAII（Resource Acquisition Is Initialization）技术和模板元编程等。</li></ol><p>总之，unique_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以有效避免内存泄漏和野指针等常见问题。在编写 C</ins> 程序时，使用 unique_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="为什么会有shared_ptr"><a class="markdownIt-Anchor" href="#为什么会有shared_ptr">#</a> 为什么会有 shared_ptr</h4><p>shared_ptr 是一种共享式智能指针，它可以实现多个指针共享同一块内存资源，具有以下优点：</p><ol><li>引用计数机制：shared_ptr 会维护一个引用计数器，用于记录有多少个 shared_ptr 共享同一块内存。当引用计数器减为 0 时，shared_ptr 会自动释放其所管理的内存资源，从而避免了内存泄漏的风险。</li><li>所有权转移：shared_ptr 支持所有权转移，即可以将一个 shared_ptr 的所有权转移给另一个 shared_ptr，从而避免了多个指针同时管理同一块内存的问题。</li><li>方便使用：shared_ptr 与原生指针类似，可以使用普通的指针操作符和普通的函数调用方式，非常方便易用。</li><li>高效性能：shared_ptr 采用的是 “写时复制”（copy-on-write）机制，即只有在多个 shared_ptr 共享同一块内存资源时才进行复制，从而提高了内存和性能的效率。</li><li>支持自定义删除器：shared_ptr 支持自定义删除器（deleter），可以通过自定义删除器来控制内存资源的释放方式，增加了灵活性和可扩展性。</li></ol><p>总之，shared_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以实现多个指针共享同一块内存资源，并且能够自动管理内存资源，避免了内存泄漏和野指针等常见问题。在编写 C</ins> 程序时，使用 shared_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="为什么会有weak_ptr"><a class="markdownIt-Anchor" href="#为什么会有weak_ptr">#</a> 为什么会有 weak_ptr</h4><p>weak_ptr 是一种弱引用智能指针，它用于解决 shared_ptr 的循环引用问题。当两个或多个对象通过 shared_ptr 相互引用时，可能会形成一个环形引用，从而导致内存泄漏的问题。为了解决这个问题，C++11 引入了 weak_ptr，它具有以下优点：</p><ol><li>弱引用：weak_ptr 只是对所管理的对象的一个弱引用，它不会增加引用计数，也不会影响对象的生命周期。因此，当 shared_ptr 对象释放了它所管理的内存资源时，weak_ptr 并不会导致内存泄漏。</li><li>防止循环引用：当两个或多个对象通过 shared_ptr 相互引用时，可以将其中的某些指针替换为 weak_ptr，从而避免形成循环引用，减少内存泄漏的风险。</li><li>空指针检查：通过 lock () 函数可以检查所管理的对象是否存在，如果对象已经被释放，则返回一个空的 shared_ptr，从而避免了使用已经释放的内存资源的问题。</li></ol><p>总之，weak_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以有效避免 shared_ptr 的循环引用问题，并且能够检查所管理的对象是否存在，避免了使用已经释放的内存资源的问题。在编写 C</ins> 程序时，使用 weak_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="智能指针底层是如何实现的"><a class="markdownIt-Anchor" href="#智能指针底层是如何实现的">#</a> 智能指针底层是如何实现的</h4><h4 id="除了计数还有其他的什么解决方法吗"><a class="markdownIt-Anchor" href="#除了计数还有其他的什么解决方法吗">#</a> 除了计数，还有其他的什么解决方法吗</h4><p>除了引用计数，还有其他一些方法可以解决循环引用的问题，例如：</p><ol><li>弱回调：可以使用回调函数来避免循环引用。当对象之间需要相互引用时，可以将其中一个对象作为回调函数的参数传递给另一个对象，并在需要释放内存时，调用回调函数释放所管理的内存资源。这种方式可以避免引用计数的问题，但是需要手动管理回调函数的注册和调用，比较繁琐。</li><li>其他智能指针：除了 shared_ptr 和 weak_ptr，还有其他一些智能指针可以用于管理内存资源，例如 unique_ptr 和 auto_ptr。这些指针不支持循环引用，因此可以用于避免循环引用的问题。但是需要注意，使用 unique_ptr 和 auto_ptr 时需要确保对象之间不存在循环引用。</li><li>弱化对象之间的关系：可以通过重新设计对象之间的关系，将原本相互引用的关系弱化，从而避免循环引用的问题。例如，可以将对象之间的关系转化为单向依赖关系，或者使用事件机制来解耦对象之间的依赖关系。</li></ol><p>总之，除了引用计数之外，还有其他一些方法可以用于解决循环引用的问题。在设计和实现程序时，应该根据具体的需求和场景选择合适的方法，避免出现内存泄漏和野指针等问题。</p><h4 id="介绍下循环引用问题以及如何用weak_ptr解决循环引用问题的"><a class="markdownIt-Anchor" href="#介绍下循环引用问题以及如何用weak_ptr解决循环引用问题的">#</a> 介绍下循环引用问题，以及如何用 weak_ptr 解决循环引用问题的</h4><p>循环引用是指在两个或多个对象之间相互引用的情况下，可能会导致内存泄漏和野指针等问题。在 C++ 中，循环引用通常出现在使用 shared_ptr 管理内存资源的场景中。</p><p>当两个或多个对象通过 shared_ptr 相互引用时，每个 shared_ptr 都会增加所管理的对象的引用计数。如果其中一个对象被释放时，它所管理的内存资源可能并不会被释放，因为另一个对象仍然持有对它的引用，从而导致内存泄漏。此外，当所有对象都释放后，如果某个 shared_ptr 继续持有对已经释放的内存资源的引用，就会导致野指针问题。</p><p>为了解决循环引用问题，C++11 引入了 weak_ptr。weak_ptr 是一种弱引用智能指针，它不会增加引用计数，也不会影响对象的生命周期。当两个或多个对象通过 shared_ptr 相互引用时，可以将其中的某些指针替换为 weak_ptr，从而避免形成循环引用。当所有的 shared_ptr 对象释放了它们所管理的内存资源时，weak_ptr 并不会导致内存泄漏。此外，可以使用 lock () 函数来检查所管理的对象是否存在，从而避免了使用已经释放的内存资源的问题。</p><p>具体来说，使用 weak_ptr 解决循环引用问题的步骤如下：</p><ol><li>将其中的某些 shared_ptr 指针替换为 weak_ptr，避免形成循环引用。</li><li>在需要访问所管理的对象时，先使用 lock () 函数检查对象是否存在。如果对象已经被释放，则返回一个空的 shared_ptr；否则，返回一个新的 shared_ptr，可以安全地访问所管理的内存资源。</li></ol><p>总之，使用 weak_ptr 可以有效避免 shared_ptr 的循环引用问题，并且能够检查所管理的对象是否存在，避免了使用已经释放的内存资源的问题。在编写 C++ 程序时，使用 weak_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量。</p><h4 id="你说到了死锁为什么多个shared_ptr互相引用会发生死锁"><a class="markdownIt-Anchor" href="#你说到了死锁为什么多个shared_ptr互相引用会发生死锁">#</a> 你说到了死锁，为什么多个 shared_ptr 互相引用会发生死锁</h4><h4 id="什么是拷贝构造函数什么是赋值构造函数"><a class="markdownIt-Anchor" href="#什么是拷贝构造函数什么是赋值构造函数">#</a> 什么是拷贝构造函数，什么是赋值构造函数</h4><p>拷贝构造函数和赋值构造函数都是 C++ 中的特殊函数，用于创建新对象或将一个对象的值复制到另一个对象。</p><p>拷贝构造函数是一个特殊的构造函数，用于创建一个新对象，并将已有对象的值复制到新对象中。当用已有对象初始化一个新对象或者将一个对象作为参数传递给函数时，拷贝构造函数会被自动调用。拷贝构造函数的函数签名通常是类名 (const 类名 &amp; other)，其中 const 表示被复制的对象是只读的，&amp; 表示传递的是一个引用。</p><p>赋值构造函数是另一个特殊的函数，用于将一个对象的值复制到另一个已经存在的对象中。当使用一个对象为另一个对象赋值时，赋值构造函数会被自动调用。赋值构造函数的函数签名通常是类名 &amp; operator=(const 类名 &amp; other)，其中 = 表示赋值操作，&amp; 表示返回的是一个引用。</p><p>需要注意的是，拷贝构造函数和赋值构造函数是不同的函数，其函数签名也不同。拷贝构造函数创建新对象时，需要分配新的内存；而赋值构造函数则是将一个已有对象的值复制到另一个已经存在的对象中，不需要分配新的内存。</p><p>在 C++ 中，如果没有定义拷贝构造函数和赋值构造函数，编译器会自动生成默认的拷贝构造函数和赋值构造函数。默认的拷贝构造函数和赋值构造函数只是将每个成员变量的值从一个对象复制到另一个对象，因此如果类中存在指针等需要手动管理的资源，就需要自定义拷贝构造函数和赋值构造函数来确保正确的资源管理。</p><h4 id="这两个是为了解决一个什么问题"><a class="markdownIt-Anchor" href="#这两个是为了解决一个什么问题">#</a> 这两个是为了解决一个什么问题</h4><h4 id="拷贝构造函数和赋值构造函数时干什么用的可以告诉我你都知道什么吗"><a class="markdownIt-Anchor" href="#拷贝构造函数和赋值构造函数时干什么用的可以告诉我你都知道什么吗">#</a> 拷贝构造函数和赋值构造函数时干什么用的，可以告诉我你都知道什么吗</h4><h4 id="什么是浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#什么是浅拷贝和深拷贝">#</a> 什么是浅拷贝和深拷贝</h4><h4 id="newdelete-mallocfree是干什么用的具体有什么区别"><a class="markdownIt-Anchor" href="#newdelete-mallocfree是干什么用的具体有什么区别">#</a> new/delete malloc/free 是干什么用的，具体有什么区别</h4><p>new/delete 和 malloc/free 都是用于动态内存管理的 C++ 和 C 语言函数，用于在程序运行时分配和释放内存空间。</p><p>new/delete 是 C++ 语言中的运算符，用于动态地分配和释放内存空间，并在内存中构造和销毁对象。new 返回一个指向已分配内存的指针，而 delete 则释放已分配的内存空间。</p><p>malloc/free 是 C 语言中的函数，用于动态地分配和释放内存空间，但它们并不会自动构造和销毁对象。malloc 返回一个指向已分配内存的指针，而 free 则释放已分配的内存空间。</p><p>虽然 new/delete 和 malloc/free 都用于动态内存管理，但它们之间存在一些重要的区别：</p><ol><li>语法：new/delete 是 C++ 运算符，malloc/free 是 C 语言函数，因此它们的语法不同。</li><li>类型安全：new/delete 是类型安全的，可以自动调用对象的构造函数和析构函数，确保了类型安全。而 malloc/free 并不具备类型安全的特性，需要手动调用构造函数和析构函数。</li><li>内存分配方式：new/delete 分配的内存是从自由存储区（heap）中分配的，而 malloc/free 分配的内存是从堆（heap）中分配的。</li><li>内存分配大小：new/delete 在分配内存时，需要指定对象的类型，因此可以自动计算对象的大小。而 malloc/free 需要手动计算分配内存的大小，因此可能会产生错误。</li><li>重载：new/delete 可以被重载，可以自定义内存分配和释放方式。而 malloc/free 是 C 语言函数，不能被重载。</li></ol><p>综上所述，虽然 new/delete 和 malloc/free 都是用于动态内存管理，但它们的语法、类型安全、内存分配方式、内存分配大小和重载等方面都存在一定的区别。在 C++ 中，建议使用 new/delete 来管理动态内存，以确保类型安全和内存分配的正确性。</p><h4 id="如果new的一片内存用free会发生什么"><a class="markdownIt-Anchor" href="#如果new的一片内存用free会发生什么">#</a> 如果 new 的一片内存用 free，会发生什么</h4><p>如果使用 free 释放由 new 分配的内存，会导致未定义的行为。因为 new 和 free 是不同的内存分配函数，它们使用不同的内存管理机制。new 操作符在分配内存时，会调用 C++ 运行库的 operator new () 函数，它使用了动态分配内存的底层机制，例如 malloc 等。而 free 函数只能释放由 malloc 等函数分配的内存。所以，如果使用 free 函数释放由 new 分配的内存，会导致未定义的行为，可能会发生内存泄漏或者其他的错误。</p><p>在 C++ 中，建议使用 delete 操作符来释放由 new 分配的内存，而不是使用 free 函数。使用 delete 操作符可以确保内存分配和释放的正确性，同时也可以调用对象的析构函数来进行资源释放。</p><h4 id="我们知道如果new一个数组的话会是new-a这种格式为什么delete的也要delete-a"><a class="markdownIt-Anchor" href="#我们知道如果new一个数组的话会是new-a这种格式为什么delete的也要delete-a">#</a> 我们知道如果 new 一个数组的话会是 new a [] 这种格式，为什么 delete 的也要 delete a []</h4><h4 id="new-和-malloc分配的内存空间都在哪个地方"><a class="markdownIt-Anchor" href="#new-和-malloc分配的内存空间都在哪个地方">#</a> new 和 malloc 分配的内存空间都在哪个地方</h4><p>在 C++ 中， <code>new</code>  和  <code>malloc</code>  都可以用来动态分配内存。但是它们在分配内存的方式和位置上有一些不同。</p><p><code>new</code>  运算符分配内存的位置在 C++ 的自由存储区 (heap) 上，它会在运行时在堆上分配一段连续的内存区域来存储数据，并返回这段内存的首地址。使用  <code>new</code>  分配内存时，系统会自动调用构造函数来对分配的内存进行初始化。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int *ptr = new int;  // 分配一个整数的内存空间，并初始化为0</span><br></pre></td></tr></table></figure><p><code>malloc</code>  函数分配内存的位置在 C 的堆 (heap) 上，它也会在运行时在堆上分配一段连续的内存区域来存储数据，并返回这段内存的首地址。与  <code>new</code>  不同的是， <code>malloc</code>  只是简单地分配了一块内存空间，并不会自动调用构造函数来初始化这块内存。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int *ptr = (int*)malloc(sizeof(int));  // 分配一个整数的内存空间，但是不会初始化</span><br></pre></td></tr></table></figure><p>需要注意的是，使用  <code>malloc</code>  分配内存时，必须使用  <code>free</code>  函数来释放内存。而使用  <code>new</code>  分配内存时，则需要使用  <code>delete</code>  运算符来释放内存。</p><p>总之， <code>new</code>  和  <code>malloc</code>  的不同之处在于它们所在的存储区域不同、分配内存的方式和返回内存地址的类型不同，同时也涉及到了对象构造和析构等语义的差异。因此，在使用时需要根据实际需求来选择适合的内存分配方式。</p><h4 id="分配一段内存都有什么方法说说你都知道哪些"><a class="markdownIt-Anchor" href="#分配一段内存都有什么方法说说你都知道哪些">#</a> 分配一段内存都有什么方法，说说你都知道哪些</h4><p>在 C++ 中，常用的动态分配内存的方法主要有以下几种：</p><ol><li><code>new</code>  运算符：使用  <code>new</code>  运算符可以动态地分配指定类型的内存空间。例如，可以使用  <code>new int</code>  来分配一个  <code>int</code>  类型的内存空间，或者使用  <code>new int[10]</code>  来分配一个包含 10 个  <code>int</code>  类型元素的数组。</li><li><code>malloc</code>  函数：使用  <code>malloc</code>  函数可以在堆上动态地分配指定大小的内存空间，它的函数原型为  <code>void *malloc(size_t size)</code> 。需要注意的是，使用  <code>malloc</code>  分配内存时，必须使用  <code>free</code>  函数来释放内存。</li><li><code>calloc</code>  函数：使用  <code>calloc</code>  函数可以在堆上动态地分配指定数量、指定大小的内存空间，并且会将分配的内存空间清零，它的函数原型为  <code>void *calloc(size_t nmemb, size_t size)</code> 。</li><li><code>realloc</code>  函数：使用  <code>realloc</code>  函数可以重新分配之前由  <code>malloc</code>  或  <code>calloc</code>  分配的内存空间，它的函数原型为  <code>void *realloc(void *ptr, size_t size)</code> 。需要注意的是，使用  <code>realloc</code>  函数时，必须将之前分配的内存空间的地址作为第一个参数传递给该函数，而且不能用于  <code>new</code>  分配的内存空间。</li></ol><p>除了上述方法，C++ 标准库中还提供了一些内存分配函数，例如  <code>std::malloc</code> 、 <code>std::calloc</code> 、 <code>std::realloc</code> 、 <code>std::aligned_alloc</code> 、 <code>std::new_handler</code>  等，这些函数可以方便地进行内存分配、重新分配、对齐等操作。</p><h4 id="知道static吗详细介绍下static的功能"><a class="markdownIt-Anchor" href="#知道static吗详细介绍下static的功能">#</a> 知道 static 吗，详细介绍下 static 的功能</h4><p>在 C++ 中， <code>static</code>  关键字可以用于以下三个方面：</p><ol><li>静态变量：使用  <code>static</code>  关键字声明的变量被称为静态变量，它们存储在静态存储区中，并且只会被初始化一次。在函数内部声明的静态变量在函数执行完毕后不会被销毁，而是会一直存在于程序的生命周期中。在类中声明的静态变量被称为类变量或静态成员变量，它们被所有类对象共享，并且不依赖于任何类对象而存在。</li><li>静态函数：使用  <code>static</code>  关键字声明的函数被称为静态函数或类函数，它们与类的静态成员变量类似，不依赖于任何类对象而存在。因此，静态函数只能访问类的静态成员变量或其他静态函数，不能访问类的非静态成员变量或成员函数。</li><li>静态类：使用  <code>static</code>  关键字声明的类被称为静态类，它们只包含静态成员变量和静态成员函数，不能创建任何对象。静态类通常用于实现一些辅助函数或工具类，例如数学库、字符串库等。</li></ol><p>除了上述功能之外， <code>static</code>  关键字还可以用于限制变量和函数的作用域，使其仅在当前文件或代码块中可见。在这种情况下， <code>static</code>  关键字相当于将变量或函数的链接类型改为内部链接。这种用法可以用于隐藏实现细节，防止变量和函数被其他文件或代码块访问，从而增强程序的安全性和可维护性。</p><h4 id="知道const吗详细介绍下const的功能"><a class="markdownIt-Anchor" href="#知道const吗详细介绍下const的功能">#</a> 知道 const 吗，详细介绍下 const 的功能</h4><p>在 C++ 中， <code>const</code>  关键字用于修饰变量、函数和类成员函数等，其功能如下：</p><ol><li>常量变量：使用  <code>const</code>  关键字声明的变量称为常量变量，其值在程序运行过程中不可修改。常量变量可以在声明时进行初始化，也可以在构造函数中进行初始化。</li><li>常量函数：使用  <code>const</code>  关键字修饰的函数称为常量函数，其内部不能修改对象的状态或调用非常量成员函数。常量函数可以被常量对象和非常量对象调用，但在常量对象中只能调用常量成员函数。</li><li>常量类成员函数：使用  <code>const</code>  关键字修饰的类成员函数称为常量类成员函数，其作用与常量函数类似，但只能在类的成员函数中使用。常量类成员函数不能修改类的成员变量，但可以访问类的非常量成员函数。</li><li>常量对象：使用  <code>const</code>  关键字修饰的对象称为常量对象，其状态不能在程序运行过程中被修改。常量对象只能调用常量成员函数和常量类成员函数，不能调用非常量成员函数和非常量类成员函数。</li></ol><p>通过使用  <code>const</code>  关键字，可以增加程序的可读性、可靠性和安全性，减少代码中的错误和 bug。例如，常量变量可以防止在程序运行过程中意外修改变量的值，常量函数可以确保对象的状态不会被修改，常量类成员函数可以避免在类内部误用非常量成员函数等。</p><h4 id="关于c内存管理机制详细介绍一下"><a class="markdownIt-Anchor" href="#关于c内存管理机制详细介绍一下">#</a> 关于 C++ 内存管理机制，详细介绍一下</h4><h4 id="介绍下堆区和栈区他们有什么区别"><a class="markdownIt-Anchor" href="#介绍下堆区和栈区他们有什么区别">#</a> 介绍下堆区和栈区，他们有什么区别</h4><p>C++ 的内存管理机制主要包括两个方面：栈内存管理和堆内存管理。</p><ol><li>栈内存管理</li></ol><p>在 C++ 中，函数调用时会在栈内存中为函数创建一个新的栈帧，用于存储函数的局部变量、函数参数、返回地址和临时变量等。栈内存是由操作系统分配和管理的，因此其大小和位置是固定的。栈内存管理具有以下特点：</p><ul><li>自动分配和释放：栈内存的分配和释放是自动的，程序员不需要显式地调用函数进行内存管理。</li><li>后进先出：栈内存采用后进先出的方式进行管理，即最后进入栈的变量最先被释放。</li><li>快速访问：栈内存的访问速度非常快，因为栈内存是连续的、顺序存储的，可以直接通过栈指针进行访问。</li></ul><ol><li>堆内存管理</li></ol><p>堆内存是由程序员手动分配和释放的，其大小和位置不固定，可以动态调整。在 C++ 中，使用  <code>new</code>  运算符分配堆内存，使用  <code>delete</code>  运算符释放堆内存。堆内存管理具有以下特点：</p><ul><li>动态分配和释放：堆内存的分配和释放是由程序员手动控制的，需要使用  <code>new</code>  和  <code>delete</code>  运算符进行操作。</li><li>不连续存储：堆内存是不连续存储的，其分配和释放涉及到内存的分配和释放算法，比较复杂。</li><li>慢速访问：堆内存的访问速度比栈内存慢，因为堆内存是不连续存储的，访问需要通过指针进行间接访问。</li></ul><p>C++ 的内存管理机制是基于 RAII（Resource Acquisition Is Initialization）原则的，即资源获取即初始化。该原则要求程序员在使用资源（如堆内存、文件、锁等）时，通过对象的构造函数获取资源，在对象的析构函数中释放资源，从而避免资源泄漏和错误。例如，使用智能指针可以自动管理堆内存的分配和释放，避免手动控制  <code>new</code>  和  <code>delete</code>  运算符的问题。同时，C++ 标准库提供了多种容器和算法，可以更方便地管理内存和数据结构。</p><h4 id="你说到栈区比堆区快为什么栈快"><a class="markdownIt-Anchor" href="#你说到栈区比堆区快为什么栈快">#</a> 你说到栈区比堆区快，为什么栈快</h4><h4 id="你说到os对其做了许多优化os究竟做了什么优化为什么要这样优化呢"><a class="markdownIt-Anchor" href="#你说到os对其做了许多优化os究竟做了什么优化为什么要这样优化呢">#</a> 你说到 OS 对其做了许多优化，OS 究竟做了什么优化，为什么要这样优化呢</h4><h4 id="我们知道在递归层数太深的时候会发生栈溢出为什么会发生栈溢出呢"><a class="markdownIt-Anchor" href="#我们知道在递归层数太深的时候会发生栈溢出为什么会发生栈溢出呢">#</a> 我们知道在递归层数太深的时候会发生栈溢出，为什么会发生栈溢出呢</h4><p>栈溢出（stack overflow）是指在程序运行时，栈内存中的数据超出了栈的大小，导致无法继续正常执行程序的现象。</p><p>在函数调用时，函数的参数、局部变量、返回地址等信息都会被压入栈中，每次函数调用都会在栈上分配一段内存，称为栈帧（stack frame），当函数执行结束后，栈帧就被销毁，栈顶指针回到上一层调用函数的位置，继续执行后续的代码。</p><p>当递归层数太深时，栈空间被不断地分配和销毁，如果栈的空间不足以存储所有的栈帧，就会导致栈溢出。这通常是因为程序中使用了过多的递归调用，或者函数中分配了过多的局部变量或数组等占用了大量的栈空间。</p><p>另外，有些编译器还可以检测到递归的循环调用，从而避免栈溢出的问题。例如 GCC 编译器的 - O2 优化级别会启用尾递归优化，将递归调用转化为循环调用，从而减少栈帧的使用。</p><h4 id="你知道什么是压栈和入栈吗"><a class="markdownIt-Anchor" href="#你知道什么是压栈和入栈吗">#</a> 你知道什么是压栈和入栈吗</h4><p>在内存管理中，栈（stack）是一种线性的数据结构，具有先进后出（Last-In-First-Out，LIFO）的特点。栈通常用来存储临时变量、函数调用返回地址、函数参数以及一些其他的上下文信息。</p><p>压栈和入栈都是指将数据放入栈中的操作，但它们的含义略有不同：</p><ul><li>压栈（push）通常指将一个数据压入栈顶，即栈指针向下移动一个位置，指向新压入的数据。</li><li>入栈（push）通常指将一组数据按照某种顺序依次压入栈中，其中包括多个数据元素和可能的一些控制信息。这个操作通常用于函数调用时将参数和返回地址压入栈中。</li></ul><p>举个例子，假设我们有一个栈，其中已经有两个元素 10 和 20，栈指针指向第三个空位。此时，我们执行以下操作：</p><ul><li>压栈 30，即将数据 30 放入栈顶，栈指针指向第四个位置。</li><li>入栈函数调用信息，即将函数调用的参数和返回地址按照一定的顺序压入栈中，同时更新栈指针的位置。</li></ul><p>需要注意的是，栈的大小是有限的，当栈满了之后，就会发生栈溢出（stack overflow）的错误，这通常是因为递归调用过多或者占用了过多的栈空间导致的。因此，在编写程序时，需要谨慎使用栈，并保证栈空间的合理分配和管理。</p><h4 id="你知道什么是栈争吗详细解释下"><a class="markdownIt-Anchor" href="#你知道什么是栈争吗详细解释下">#</a> 你知道什么是栈争吗，详细解释下</h4><p>栈争（Stack Clash）是一种计算机安全漏洞，可以被黑客用来攻击目标系统并获取系统权限。该漏洞最初于 2017 年被发现，但其基本原理已经存在了很长时间。</p><p>栈争漏洞的基本原理是，当程序的堆栈空间与另一个内存区域（例如堆或共享库）发生冲突时，黑客可以利用这个漏洞来覆盖栈中的数据，从而控制程序的执行流程。具体来说，黑客会通过精心构造的输入数据来使程序在堆栈和其他内存区域之间跳转，从而实现代码注入和控制流劫持。</p><p>栈争漏洞通常发生在使用静态栈分配的程序中，这种程序在编译时会为每个线程分配固定大小的堆栈空间。黑客可以通过超出堆栈空间的边界来覆盖栈中的数据，从而实现攻击。</p><p>为了防止栈争漏洞，开发人员可以采用一些措施，例如：</p><ol><li>使用动态栈分配：动态栈分配可以使程序在运行时动态地分配堆栈空间，从而减少堆栈与其他内存区域发生冲突的可能性。</li><li>限制堆栈空间的大小：开发人员可以限制程序的堆栈空间大小，从而减少栈与其他内存区域发生冲突的可能性。</li><li>栈随机化：开发人员可以采用栈随机化技术来使每个线程的堆栈空间的地址随机化，从而使攻击者难以确定正确的地址。</li></ol><p>总之，栈争漏洞是一种常见的安全漏洞，可以通过采用适当的措施来减少其发生的可能性。</p><h4 id="什么变量分配在堆上什么变量分配在栈上"><a class="markdownIt-Anchor" href="#什么变量分配在堆上什么变量分配在栈上">#</a> 什么变量分配在堆上，什么变量分配在栈上</h4><p>在计算机编程中，内存被划分为栈（stack）和堆（heap），它们都用于存储变量。</p><p>栈（stack）：栈是一种线性数据结构，具有后进先出（LIFO）的特性。栈上的变量由编译器自动分配和释放内存。当程序执行一个函数时，该函数的参数、局部变量和返回地址被压入栈中。当函数返回时，这些变量被弹出栈。因此，栈上的变量的生命周期是由函数的调用和返回决定的。栈的大小通常是固定的，由操作系统或编译器定义。</p><p>堆（heap）：堆是一种非线性数据结构，由程序员动态分配和释放内存。堆上的变量可以在程序的任何位置被访问，因此它们的生命周期可以由程序员控制。在堆上分配内存需要显式地调用分配函数（如 malloc () 或 new），在不需要变量时，需要显式地释放它们（如 free () 或 delete）。</p><p>一般来说，较小的变量（如基本数据类型）通常分配在栈上，而较大的变量（如数组、对象等）通常分配在堆上。但是，这也取决于编译器和操作系统的实现方式，所以并非所有的编程语言和平台都遵循这种规则。</p><h4 id="关于操作系统是如何实现堆和栈的堆和栈究竟是一个怎么样的结构"><a class="markdownIt-Anchor" href="#关于操作系统是如何实现堆和栈的堆和栈究竟是一个怎么样的结构">#</a> 关于操作系统是如何实现堆和栈的，堆和栈究竟是一个怎么样的结构</h4><h4 id="c中一个很重要的特性是多态关于c中多态是如何实现的呢"><a class="markdownIt-Anchor" href="#c中一个很重要的特性是多态关于c中多态是如何实现的呢">#</a> C<ins> 中一个很重要的特性是多态，关于 C</ins> 中多态是如何实现的呢？</h4><h4 id="讲到了虚函数然后问虚函数是如何实现的呢"><a class="markdownIt-Anchor" href="#讲到了虚函数然后问虚函数是如何实现的呢">#</a> 讲到了虚函数，然后问虚函数是如何实现的呢？</h4><p>在 C<ins> 中，多态是通过虚函数（virtual function）实现的。虚函数是在基类中声明的一种特殊的成员函数，它可以被派生类重写以实现特定的行为。通过虚函数，C</ins> 能够实现运行时多态性（runtime polymorphism）。</p><p>当一个类中包含至少一个虚函数时，编译器会为该类生成一个虚函数表（virtual table，也称为 vtable），用于存储类的虚函数地址。当一个对象被创建时，它会包含一个指向虚函数表的指针。当调用一个虚函数时，C++ 会根据该对象的指针找到虚函数表，并调用相应的函数。</p><p>通过使用虚函数，C++ 可以实现动态绑定（dynamic binding）或晚绑定（late binding）的特性，即在运行时确定调用哪个函数。这样可以实现在运行时根据对象的实际类型调用相应的函数，而不是根据变量类型调用函数，从而实现多态性。</p><p>下面是一个使用虚函数实现多态的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;This is an animal sound.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Meow!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Woof!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal *ptr;</span><br><span class="line">    Cat cat;</span><br><span class="line">    Dog dog;</span><br><span class="line">    ptr = &amp;cat;</span><br><span class="line">    ptr-&gt;makeSound(); // 输出：Meow!</span><br><span class="line">    ptr = &amp;dog;</span><br><span class="line">    ptr-&gt;makeSound(); // 输出：Woof!</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Animal 类包含一个虚函数 makeSound ()，Cat 类和 Dog 类都重写了这个函数。在 main 函数中，定义了一个 Animal 类型的指针 ptr，并分别让它指向 Cat 对象和 Dog 对象。当调用 ptr 的 makeSound () 函数时，C++ 会根据 ptr 指向的对象的实际类型调用相应的函数，输出相应的结果。这就是多态的表现。</p><h4 id="c如何找到虚表的如何确定每一个子类对应的虚表就是这个虚表呢"><a class="markdownIt-Anchor" href="#c如何找到虚表的如何确定每一个子类对应的虚表就是这个虚表呢">#</a> C++ 如何找到虚表的，如何确定每一个子类对应的虚表就是这个虚表呢</h4><p>在 C++ 中，每个包含虚函数的类都会有一个虚函数表（vtable），这个表中存储了虚函数的地址。每个对象都有一个指向其对应类的虚函数表的指针（通常被称为虚表指针或 vptr），通过这个指针可以动态地调用虚函数。</p><p>在编译时，编译器为每个包含虚函数的类生成一个虚表，虚表中存储了该类中所有虚函数的地址。当派生类继承了基类的虚函数时，派生类也会包含基类的虚表，而且在该虚表的末尾添加自己的虚函数地址。这样，派生类就可以重写基类的虚函数，并添加自己的虚函数。</p><p>在运行时，当调用一个虚函数时，C++ 会根据对象的虚表指针找到对应的虚表，然后根据虚函数在虚表中的位置，调用相应的虚函数。</p><p>在实际编程中，可以使用指针操作虚表。例如，可以将一个指向虚函数的指针与一个指向对象的虚表指针相加，从而获取对象中某个虚函数的地址。这个技巧在某些情况下可以提高程序的效率。</p><p>需要注意的是，不同的编译器可能会对虚表的实现方式有所不同，因此在使用指针操作虚表时需要注意不同编译器的差异。</p><h4 id="什么是纯虚函数纯虚函数是如何实现的"><a class="markdownIt-Anchor" href="#什么是纯虚函数纯虚函数是如何实现的">#</a> 什么是纯虚函数，纯虚函数是如何实现的</h4><p>纯虚函数是在 C++ 中的一种特殊的虚函数，它没有函数体，只有函数原型，而且必须被子类重写。纯虚函数的定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">virtual return_type function_name(parameters) = 0;</span><br></pre></td></tr></table></figure><p>其中， <code>= 0</code>  表示这是一个纯虚函数。</p><p>纯虚函数的作用是为了定义一个接口，强制子类实现该接口中的方法，从而实现多态性。例如，我们可以定义一个抽象类，其中包含一个纯虚函数，子类必须实现这个函数才能被实例化。下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void draw() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Circle : public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        // 实现画圆的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle : public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        // 实现画矩形的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Shape *ptr;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Rectangle rectangle;</span><br><span class="line">    ptr = &amp;circle;</span><br><span class="line">    ptr-&gt;draw(); // 调用Circle的draw函数</span><br><span class="line">    ptr = &amp;rectangle;</span><br><span class="line">    ptr-&gt;draw(); // 调用Rectangle的draw函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Shape 类包含一个纯虚函数 draw ()，表示它是一个抽象类，不能被实例化。Circle 类和 Rectangle 类继承自 Shape 类，并重写了 draw () 函数。在 main 函数中，使用 Shape 类型的指针 ptr 分别指向 Circle 对象和 Rectangle 对象，并调用它们的 draw () 函数。由于 draw () 是一个虚函数，并且在 Shape 中被声明为纯虚函数，因此在运行时会根据 ptr 指向的对象的实际类型调用相应的函数，从而实现多态性。</p><p>纯虚函数是通过将虚函数表中的函数指针设为 NULL 来实现的。由于纯虚函数没有函数体，因此编译器不会为它生成函数的代码，而是在虚函数表中将对应的函数指针设为 NULL。这就表示该函数没有实现，必须由子类重写并实现。当派生类实现了纯虚函数后，虚函数表中对应的函数指针会被更新为子类中的函数地址，从而实现动态绑定。</p><h4 id="为什么纯虚函数不能初始化"><a class="markdownIt-Anchor" href="#为什么纯虚函数不能初始化">#</a> 为什么纯虚函数不能初始化</h4><h4 id="定义了虚函数如何在子类中访问父类的虚函数方法"><a class="markdownIt-Anchor" href="#定义了虚函数如何在子类中访问父类的虚函数方法">#</a> 定义了虚函数，如何在子类中访问父类的虚函数方法</h4><p>在 C++ 中，如果子类定义了一个和父类同名的虚函数，子类的这个函数会覆盖父类的函数，使得父类的函数在子类对象中无法直接访问。</p><p>但是，在子类中可以通过使用作用域限定符来显式地调用父类的虚函数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void foo() &#123;</span><br><span class="line">        // 父类中的虚函数实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        // 子类中的虚函数实现</span><br><span class="line">        Base::foo(); // 调用父类中的虚函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Derived 类继承自 Base 类，并覆盖了 Base 类中的虚函数 foo ()。在 Derived 类中，我们可以使用作用域限定符 <code>Base::</code>  来调用父类中的 foo () 函数。</p><p>使用作用域限定符可以在子类中显式地调用父类的虚函数，从而保留父类的实现，并添加子类的特定功能。需要注意的是，如果父类的虚函数是纯虚函数，子类必须重写该函数，否则编译器会报错。</p><h4 id="你说的这个多态是编译器多态还是运行时多态"><a class="markdownIt-Anchor" href="#你说的这个多态是编译器多态还是运行时多态">#</a> 你说的这个多态是编译器多态还是运行时多态？</h4><p>在 C++ 中，多态分为两种类型：编译时多态和运行时多态。</p><p>在编译时多态中，函数的调用在编译期就已经确定了，具体调用哪个函数由函数的静态类型（即声明时的类型）决定。这种多态性也称为静态多态性，它是通过函数重载和模板实现的。</p><p>而在运行时多态中，函数的调用是在运行时确定的，具体调用哪个函数由函数的实际类型（即运行时对象的类型）决定。这种多态性也称为动态多态性，它是通过虚函数和继承实现的。</p><p>所以，我之前提到的多态是指运行时多态，即通过虚函数和继承实现的多态。在运行时多态中，函数的调用是在运行时才确定的，具体调用哪个函数取决于对象的实际类型，而不是声明时的类型。</p><h4 id="你知道什么是编译器多态以及运行时多态吗"><a class="markdownIt-Anchor" href="#你知道什么是编译器多态以及运行时多态吗">#</a> 你知道什么是编译器多态以及运行时多态吗？</h4><h4 id="动态库和静态库有什么区别为什么有动态库和静态库关于动态库和静态库你都知道什么"><a class="markdownIt-Anchor" href="#动态库和静态库有什么区别为什么有动态库和静态库关于动态库和静态库你都知道什么">#</a> 动态库和静态库有什么区别，为什么有动态库和静态库，关于动态库和静态库你都知道什么</h4><p>动态库和静态库都是编译后的可执行文件所依赖的库，它们的主要区别在于链接方式不同。</p><p>静态库是在编译时将库的代码链接到可执行文件中，因此可执行文件中包含了完整的库代码。静态库的好处是使用简单，只需要将库的头文件和库文件一起编译即可，不需要在运行时再去加载库。但是，静态库会使得可执行文件变得比较大，而且如果多个可执行文件都使用同一个静态库，这些可执行文件会重复包含静态库的代码，导致浪费空间。</p><p>动态库则是在运行时动态加载并链接到可执行文件中，因此可执行文件中只包含了对库函数的引用，而不包含完整的库代码。动态库的好处是可以在运行时动态加载，节省空间，也方便库的更新和维护。但是，动态库的使用相对复杂，需要在编译时指定库的位置，并且需要在运行时保证库文件的可用性。</p><p>关于动态库和静态库，我还知道以下几点：</p><ol><li>静态库的文件扩展名通常为.a（Unix/Linux）或.lib（Windows），<a href="http://xn--siqsrq5g3tb3wu3ycdsap5gqzh71i2q4cq5x3i0c.so">而动态库的文件扩展名通常为.so</a>（Unix/Linux）或.dll（Windows）。</li><li>静态库和动态库都可以包含函数、变量和类等。但是，如果库中包含了全局变量，那么在动态库中可能会出现符号冲突问题。</li><li>动态库需要在运行时加载，所以可能会影响程序的性能。此外，由于动态库的引用是在运行时解析的，所以动态库存在版本兼容性问题，需要进行版本管理。</li><li>静态库和动态库的选择取决于具体的需求和场景。通常情况下，如果需要多个可执行文件共享同一库，使用动态库更为合适；如果只需要在一个可执行文件中使用库，使用静态库更为合适。</li></ol><h4 id="为什么析构函数要定义成虚函数详细解释一下"><a class="markdownIt-Anchor" href="#为什么析构函数要定义成虚函数详细解释一下">#</a> 为什么析构函数要定义成虚函数详细解释一下</h4><p>C++ 中析构函数的作用是在对象生命周期结束时进行资源的清理和释放，它与构造函数相对应。如果一个类有虚函数，那么它的析构函数通常也应该被定义成虚函数。</p><p>理由如下：</p><ol><li>多态调用问题：如果一个基类指针指向派生类对象，那么通过这个指针调用 delete 操作时，只会调用到基类的析构函数，而不会调用到派生类的析构函数。这就导致派生类中可能存在的资源泄漏问题。如果将基类的析构函数定义成虚函数，那么在调用 delete 操作时，就会自动调用到派生类的析构函数，从而确保资源被正确释放。</li><li>防止内存泄漏问题：当一个对象从动态分配的内存中释放时，如果析构函数不是虚函数，可能只有该对象的部分内存会被释放，而不是整个对象的内存。这种情况下，就会出现内存泄漏的问题。</li><li>防止对象切割问题：如果派生类对象以值传递给一个函数，而函数参数类型是基类指针或引用类型，那么传递进去的对象就会发生 “对象切割”，即只有基类部分会被复制到函数的参数中，而派生类部分会被丢失。如果基类的析构函数不是虚函数，那么在函数结束时只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类对象的资源无法释放。</li></ol><p>综上所述，如果一个类可能会被继承或者被作为基类，那么应该将其析构函数定义为虚函数，以确保在对象被销毁时能够正确地释放资源。</p><h4 id="只定义析构函数会自动生成哪些构造函数"><a class="markdownIt-Anchor" href="#只定义析构函数会自动生成哪些构造函数">#</a> 只定义析构函数，会自动生成哪些构造函数</h4><p>在 C++ 中，如果只定义一个析构函数，编译器会自动生成默认的构造函数、拷贝构造函数和拷贝赋值运算符。</p><p>具体来说，如果一个类只定义了析构函数，没有定义任何构造函数，则编译器会自动生成默认构造函数。默认构造函数没有参数，并且不执行任何操作，仅仅是为对象分配空间。</p><p>如果一个类只定义了析构函数和拷贝构造函数，则编译器会自动生成默认拷贝赋值运算符。默认拷贝构造函数用于在对象被复制时执行浅复制，即仅仅复制对象的成员变量的值，而不会复制对象的动态资源。默认拷贝赋值运算符用于在对象被赋值时执行浅复制，即将右侧对象的成员变量的值复制给左侧对象的成员变量。</p><p>需要注意的是，如果一个类需要执行深复制或者需要自定义构造函数，那么就需要手动定义这些函数，否则使用默认函数可能会导致程序错误或者内存泄漏。</p><h4 id="解释下向上转型和向下转型以及c中的四种强制类型转换为什么要有这四种强制类型转换你平时都用过哪些"><a class="markdownIt-Anchor" href="#解释下向上转型和向下转型以及c中的四种强制类型转换为什么要有这四种强制类型转换你平时都用过哪些">#</a> 解释下向上转型和向下转型，以及 C++ 中的四种强制类型转换，为什么要有这四种强制类型转换，你平时都用过哪些</h4><ol><li>向上转型（upcasting）：指的是将一个派生类指针或引用赋值给基类指针或引用的过程，即从派生类到基类的转换。这种转换是安全的，因为基类指针或引用只能访问基类中的成员，不会访问派生类中新增的成员或重载的成员函数。</li><li>向下转型（downcasting）：指的是将一个基类指针或引用转换为派生类指针或引用的过程，即从基类到派生类的转换。这种转换是危险的，因为基类指针或引用可能并不指向一个派生类对象，如果这样的转换失败，则会导致程序崩溃或者未定义行为。</li><li>C++ 中的四种强制类型转换分别为：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。<ul><li>static_cast：用于基本数据类型之间的转换，以及指针或引用之间的转换。这种转换是在编译时完成的，对于向上转型和向下转型都可以使用。但是，对于向下转型，如果类型转换不合法，则会在运行时产生未定义行为，因此需要谨慎使用。</li><li>dynamic_cast：用于将基类指针或引用转换为派生类指针或引用。这种转换是在运行时完成的，会进行类型检查，如果类型转换不合法，则返回空指针或抛出 std::bad_cast 异常。dynamic_cast 只能用于有虚函数的类之间的转换，因为它依赖于运行时类型信息。</li><li>const_cast：用于移除对象的 const 属性或将对象的 volatile 属性移除。这种转换主要用于遗留代码和与 C 语言代码的互操作。</li><li>reinterpret_cast：用于不同类型之间的强制转换，它可以将任何类型的指针或引用转换为任何其他类型的指针或引用。这种转换是非常危险的，因为它完全依赖于编译器的实现，可能会导致未定义行为或崩溃。</li></ul></li><li>强制类型转换的主要目的是为了解决类型不匹配的问题。这四种转换方式提供了不同的转换方式，使程序员可以根据需要选择适当的方式。需要注意的是，强制类型转换应该尽可能地避免使用，因为它们可能会导致安全问题和未定义行为。在实际开发中，应该尽量使用更加安全的类型转换方式，例如模板函数、函数重载、继承等。</li></ol><h3 id="做题吧"><a class="markdownIt-Anchor" href="#做题吧">#</a> 做题吧</h3><h4 id="写一个线程安全且高效的懒汉单例模式"><a class="markdownIt-Anchor" href="#写一个线程安全且高效的懒汉单例模式">#</a> 写一个线程安全且高效的懒汉单例模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 私有化构造函数，保证只能在内部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day11</title>
      <link href="/2023/04/24/shuati/day11/"/>
      <url>/2023/04/24/shuati/day11/</url>
      
        <content type="html"><![CDATA[<h4 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和">#</a> <a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><p>给你一个整数数组  <code>nums</code>  ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>这个题动态规划就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> r = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i<span class="number">-1</span>] + nums[i] &gt; nums[i]) res[i] = res[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">            <span class="keyword">else</span> res[i] = nums[i];</span><br><span class="line"></span><br><span class="line">            r = <span class="built_in">max</span>(r, res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a class="markdownIt-Anchor" href="#70-爬楼梯">#</a> <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要  <code>n</code>  阶你才能到达楼顶。</p><p>每次你可以爬  <code>1</code>  或  <code>2</code>  个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p>DP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + res[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表">#</a> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>老熟人了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list1) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span> (!list2) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list2-&gt;next, list1);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="912-排序数组"><a class="markdownIt-Anchor" href="#912-排序数组">#</a> <a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></h4><p>给你一个整数数组  <code>nums</code> ，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p>写一个快排吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="83-删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#83-删除排序链表中的重复元素">#</a> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><p>给定一个已排序的链表的头  <code>head</code>  ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>用的递归，过了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        ListNode* hn = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (!hn) <span class="keyword">return</span> h;</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;val == hn-&gt;val) <span class="keyword">return</span> hn;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            h-&gt;next = hn;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="19-删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第-n-个结点">#</a> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>给你一个链表，删除链表的倒数第  <code>n</code>  个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>用的笨方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        ListNode* he  = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (ListNode* a = head; a != <span class="literal">nullptr</span>; a = a-&gt;next) &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = l - n;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* a = he;a != <span class="literal">nullptr</span> ; a = a-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == r ) &#123;</span><br><span class="line">                a-&gt;next = a-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = he-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> he;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="876-链表的中间结点"><a class="markdownIt-Anchor" href="#876-链表的中间结点">#</a> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><p>给你单链表的头结点  <code>head</code>  ，请你找出并返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[3,4,5]</span><br><span class="line">解释：链表只有一个中间结点，值为 3 。</span><br></pre></td></tr></table></figure><p>明显双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day10</title>
      <link href="/2023/04/23/shuati/day10/"/>
      <url>/2023/04/23/shuati/day10/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-offer-25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#剑指-offer-25-合并两个排序的链表">#</a> <a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>难度简单 343 收藏分享切换为英文接收动态反馈</p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>算是很简单吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* h;</span><br><span class="line">        <span class="comment">//ListNode* head = new ListNode(0);</span></span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">            h = l2;</span><br><span class="line">            h-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            h = l1;</span><br><span class="line">            h-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-56-ii-数组中数字出现的次数-ii"><a class="markdownIt-Anchor" href="#剑指-offer-56-ii-数组中数字出现的次数-ii">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p>难度中等 443 收藏分享切换为英文接收动态反馈</p><p>在一个数组  <code>nums</code>  中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>排序解决了应该有更好的解法</p><p>需要特殊处理下边界条件，第一个元素和最后一个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        if (nums[0] != nums[1] &amp;&amp; nums[1] == nums[2]) return nums[0];</span><br><span class="line">        if (nums[nums.size()-1] != nums[nums.size()-2] &amp;&amp; nums[nums.size()-2] == nums[nums.size()-3]) return nums[nums.size()-1];</span><br><span class="line">        for (int i = 1; i&lt; nums.size()-1; i ++) &#123;</span><br><span class="line">            if (nums[i] != nums[i+1] &amp;&amp; nums[i] != nums[i-1]) return nums[i];</span><br><span class="line">        &#125; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-53-ii-0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#剑指-offer-53-ii-0~n-1中缺失的数字">#</a> <a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1 中缺失的数字</a></h4><p>难度简单 373 收藏分享切换为英文接收动态反馈</p><p>一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k:nums) cnt += k;</span><br><span class="line">        <span class="keyword">return</span> (nums.<span class="built_in">size</span>()+<span class="number">1</span>)*nums.<span class="built_in">size</span>()/<span class="number">2</span> - cnt; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点">#</a> <a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>难度简单 636 收藏分享切换为英文接收动态反馈</p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表 **：**</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p>昨天写过原题了，没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* ha = headA;</span><br><span class="line">        ListNode* hb = headB;</span><br><span class="line">        <span class="keyword">if</span> (!ha || !hb) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (ha != hb) &#123;</span><br><span class="line">            ha = ha ? ha-&gt;next : headB;</span><br><span class="line">            hb = hb ? hb-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写了四个简单题，下午面试被拷打的太惨了，写四个简单题找找自信吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day9</title>
      <link href="/2023/04/22/shuati/day9/"/>
      <url>/2023/04/22/shuati/day9/</url>
      
        <content type="html"><![CDATA[<h4 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表">#</a> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>难度简单 2076 收藏分享切换为英文接收动态反馈</p><p>给你两个单链表的头节点  <code>headA</code>  和  <code>headB</code>  ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回  <code>null</code>  。</p><p>图示两个链表在节点  <code>c1</code>  开始相交 **：**</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code>  - 相交的起始节点的值。如果不存在相交节点，这一值为  <code>0</code></li><li><code>listA</code>  - 第一个链表</li><li><code>listB</code>  - 第二个链表</li><li><code>skipA</code>  - 在  <code>listA</code>  中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code>  - 在  <code>listB</code>  中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点  <code>headA</code>  和  <code>headB</code>  传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p>关于这个题，用双指针</p><p>一个从 A 出发，一个从 B 出发</p><p>一个到头后从另外一个起点出发，相遇的点就是交点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *a = headA;</span><br><span class="line">        ListNode *b = headB;</span><br><span class="line">        <span class="comment">//if (a == nullptr || b == nullptr) return nullptr;</span></span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="543-二叉树的直径"><a class="markdownIt-Anchor" href="#543-二叉树的直径">#</a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><p>难度简单 1305 收藏分享切换为英文接收动态反馈</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br> 给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">depth</span>(rt-&gt;left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">depth</span>(rt-&gt;right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>今天下午网易笔试，做完脑子不好使了，今天就写这两题，还有三天连着面试，线程池稍微慢一点，这几天复习下面经，背下知识点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号量以及Any类型的实现</title>
      <link href="/2023/04/22/thread-pool/thread-pool5/"/>
      <url>/2023/04/22/thread-pool/thread-pool5/</url>
      
        <content type="html"><![CDATA[<h3 id="线程池实现任意类型的返回值"><a class="markdownIt-Anchor" href="#线程池实现任意类型的返回值">#</a> 线程池实现任意类型的返回值</h3><p>实现 C++17 中的 Any 类</p><p>任意的其他类型 template</p><p>基类类型指向派生类类型</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Any</span>(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp;) = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T data)</span> : base_(std::make_unique&lt;Derive&lt;T&gt;&gt;(data)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    T <span class="title">cast_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Derive&lt;T&gt; *pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (pd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;type is unmatch&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//基类类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Derive</span>(T data) : <span class="built_in">data_</span>(data) &#123;&#125;</span><br><span class="line">            T data_;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="信号量实现"><a class="markdownIt-Anchor" href="#信号量实现">#</a> 信号量实现</h3><p>因为线程池中的不同线程可能运行时间并不相同，因此实现线程池中的线程通信是十分有必要的。</p><p>在此不适应 C++20 中的，直接使用互斥锁和条件变量实现一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">semaphore</span>(<span class="type">int</span> Limit = <span class="number">0</span>) </span><br><span class="line">        : <span class="built_in">resLimit_</span>(Limit) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">semaphore</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//获取一个信号资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> resLimit_ &gt; <span class="number">0</span>;&#125;);</span><br><span class="line">        resLimit_ --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加一个信号资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        resLimit_ ++;</span><br><span class="line">        cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> resLimit_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线程池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周五总结</title>
      <link href="/2023/04/21/hhh/"/>
      <url>/2023/04/21/hhh/</url>
      
        <content type="html"><![CDATA[<p>点进来了捏！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逗你玩~ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day8</title>
      <link href="/2023/04/21/shuati/day8/"/>
      <url>/2023/04/21/shuati/day8/</url>
      
        <content type="html"><![CDATA[<h4 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和">#</a> <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><p>难度中等 2459 收藏分享切换为英文接收动态反馈</p><p>给你一个 <strong>无重复元素</strong> 的整数数组  <code>candidates</code>  和一个目标整数  <code>target</code>  ，找出  <code>candidates</code>  中可以使数字和为目标数  <code>target</code>  的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code>  中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为  <code>target</code>  的不同组合数少于  <code>150</code>  个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p>这个题首先想到的就是直接 dfs 写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d==candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[i], d + <span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ft</span><span class="params">(candidates.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是呢这样还是不符合题意的，因为题目还要求我们去重。</p><p>那么该如何去做呢？</p><p>关于去重，首先我是想到了哈希表，然后仔细想想不大行，太复杂了，因此考虑一下顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d==candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选当前元素</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, d+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//选当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[d] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(candidates[d]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[d], d);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ft</span><span class="params">(candidates.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>太困了脑子不好使，今天只写一题</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池中添加任务实现以及功能验证</title>
      <link href="/2023/04/20/thread-pool/thread-pool4/"/>
      <url>/2023/04/20/thread-pool/thread-pool4/</url>
      
        <content type="html"><![CDATA[<h3 id="向线程池中添加任务"><a class="markdownIt-Anchor" href="#向线程池中添加任务">#</a> 向线程池中添加任务：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="comment">//线程的通信 等待任务队列有空余 wait wait_for wait_until</span></span><br><span class="line">    <span class="comment">//wait 等到条件满足</span></span><br><span class="line">    <span class="comment">//wait_for 等一段时间</span></span><br><span class="line">    <span class="comment">//wait_until 等待到</span></span><br><span class="line">    <span class="comment">//notFull_.wait(lock, [&amp;]()-&gt;bool &#123;return taskQue_.size() &lt; taskQueMaxThreshHold_; &#125;);</span></span><br><span class="line">    <span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//表示notFull等待一秒钟，条件仍然没有满足</span></span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;task queue is full, submit task fail&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有余， 把任务放入任务队列</span></span><br><span class="line">    taskQue_.<span class="built_in">emplace</span>(sp);</span><br><span class="line">    taskSize_ ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为新放了任务，任务肯定非空，not_empty通知</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证线程池功能"><a class="markdownIt-Anchor" href="#验证线程池功能">#</a> 验证线程池功能：</h3><h4 id="只在里面添加一个任务"><a class="markdownIt-Anchor" href="#只在里面添加一个任务">#</a> 只在里面添加一个任务</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140243752814144</span><br><span class="line">任务获取成功 140243752814144</span><br><span class="line">tid 140243752814144begin  </span><br><span class="line">tid 140243752814144end  </span><br><span class="line">尝试获取任务 140243752814144</span><br><span class="line">尝试获取任务 140243761206848</span><br><span class="line">尝试获取任务 140243769599552</span><br><span class="line">尝试获取任务 140243777992256</span><br></pre></td></tr></table></figure><p>可知线程池成功运行</p><h4 id="在线程池中添加三个任务"><a class="markdownIt-Anchor" href="#在线程池中添加三个任务">#</a> 在线程池中添加三个任务</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">尝试获取任务 140607723173440</span><br><span class="line">尝试获取任务 140607731566144</span><br><span class="line">尝试获取任务 140607739958848</span><br></pre></td></tr></table></figure><p>发现在一个线程中就完成了所有任务</p><p>猜测是因为 任务体量太小，加一个睡眠函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140719386736192</span><br><span class="line">任务获取成功 140719386736192</span><br><span class="line">tid 140719386736192begin  </span><br><span class="line">尝试获取任务 140719395128896</span><br><span class="line">任务获取成功 140719395128896</span><br><span class="line">tid 140719395128896begin  </span><br><span class="line">尝试获取任务 140719403521600</span><br><span class="line">任务获取成功 140719403521600</span><br><span class="line">tid 140719403521600begin  </span><br><span class="line">尝试获取任务 140719411914304</span><br><span class="line">tid 140719386736192end  </span><br><span class="line">尝试获取任务 140719386736192</span><br><span class="line">tid 140719395128896end  </span><br><span class="line">尝试获取任务 140719395128896</span><br><span class="line">tid 140719403521600end  </span><br><span class="line">尝试获取任务 140719403521600</span><br></pre></td></tr></table></figure><p>成功</p><h4 id="添加6个任务"><a class="markdownIt-Anchor" href="#添加6个任务">#</a> 添加 6 个任务</h4><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 139810625140288</span><br><span class="line">任务获取成功 139810625140288</span><br><span class="line">tid 139810625140288begin  </span><br><span class="line">尝试获取任务 139810633532992</span><br><span class="line">任务获取成功 139810633532992</span><br><span class="line">tid 139810633532992begin  </span><br><span class="line">尝试获取任务 139810641925696</span><br><span class="line">任务获取成功 139810641925696</span><br><span class="line">tid 139810641925696begin  </span><br><span class="line">尝试获取任务 139810650318400</span><br><span class="line">任务获取成功 139810650318400</span><br><span class="line">tid 139810650318400begin  </span><br><span class="line">tid 139810625140288end  </span><br><span class="line">尝试获取任务 139810625140288</span><br><span class="line">任务获取成功 139810625140288</span><br><span class="line">tid 139810625140288begin  </span><br><span class="line">tid 139810633532992end  </span><br><span class="line">尝试获取任务 139810633532992</span><br><span class="line">任务获取成功 139810633532992</span><br><span class="line">tid 139810633532992begin  </span><br><span class="line">tid 139810641925696end  </span><br><span class="line">尝试获取任务 139810641925696</span><br><span class="line">tid 139810650318400end  </span><br><span class="line">尝试获取任务 139810650318400</span><br><span class="line">tid 139810625140288end  </span><br><span class="line">尝试获取任务 139810625140288</span><br><span class="line">tid 139810633532992end  </span><br><span class="line">尝试获取任务 139810633532992</span><br></pre></td></tr></table></figure><h4 id="综上所述"><a class="markdownIt-Anchor" href="#综上所述">#</a> 综上所述</h4><p>该线程池目前看来并无问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线程池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于线程池的一些设计以及问题排查</title>
      <link href="/2023/04/19/thread-pool/thread-pool3/"/>
      <url>/2023/04/19/thread-pool/thread-pool3/</url>
      
        <content type="html"><![CDATA[<h3 id="关于线程池的一些设计以及问题排查"><a class="markdownIt-Anchor" href="#关于线程池的一些设计以及问题排查">#</a> 关于线程池的一些设计以及问题排查</h3><p>关于任务队列，为了实现资源的高效管理，选用 shared_ptr 智能指针</p><p>使用 bind 函数实现类外定义的类能够访问本类所拥有的私有函数以及私有变量</p><h4 id="在验证线程池的时候发现打印出来的线程id都一样于是排查哪里出了问题"><a class="markdownIt-Anchor" href="#在验证线程池的时候发现打印出来的线程id都一样于是排查哪里出了问题">#</a> 在验证线程池的时候发现打印出来的线程 ID 都一样，于是排查哪里出了问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br></pre></td></tr></table></figure><p>所写线程池创建 ID</p><p>原代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; initThreadSize_; i ++) &#123;</span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,<span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; initThreadSize_; i ++) &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();<span class="comment">//执行线程函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_)</span></span>; </span><br><span class="line">    t.<span class="built_in">detach</span>();<span class="comment">//设置分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;end threadFunc tid &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细排查发现应该是这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;end threadFunc tid &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_)</span></span>; </span><br><span class="line">    t.<span class="built_in">detach</span>();<span class="comment">//设置分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">    :<span class="built_in">func_</span>(func)</span><br><span class="line">&#123;&#125;</span><br><span class="line">Thread:: ~<span class="built_in">Thread</span>()&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid 140554644977216</span><br><span class="line">end threadFunc tid 140554644977216</span><br><span class="line"></span><br><span class="line">begin threadFunc tid 140554653369920</span><br><span class="line">begin threadFunc tid 140554653369920</span><br></pre></td></tr></table></figure><p>但是明明线程池里有四个线程，为什么只运行了两个呢？</p><p>查阅资料发现，是主线程运行时间太快了，因此让主线程睡一会儿～</p><p>主线程加上 sleep (3) 后发现果然，成功！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid <span class="number">140566920504896</span></span><br><span class="line">end threadFunc tid <span class="number">140566920504896</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566928897600</span></span><br><span class="line">end threadFunc tid <span class="number">140566928897600</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566937290304</span></span><br><span class="line">end threadFunc tid <span class="number">140566937290304</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566945683008</span></span><br><span class="line">end threadFunc tid <span class="number">140566945683008</span></span><br></pre></td></tr></table></figure><h4 id="发现线程池中的线程用的是裸指针"><a class="markdownIt-Anchor" href="#发现线程池中的线程用的是裸指针">#</a> 发现线程池中的线程用的是裸指针</h4><p>修改为 unique_ptr 后然后发现以下问题</p><p ::new((void="" *)__p)="" _Up(std::forward&lt;_Args(__args)...);="">/usr/include/c++/11/ext/new_allocator.h:162:11: error: cannot convert ‘std::unique_ptr&lt;Thread, std::default_delete<Thread> &gt;’ to ‘Thread*’ in initialization<br>162 |        </p><p>左值引用问题</p><p>move 一下</p><p>然后还是错误</p><p>陷入沉思</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,<span class="keyword">this</span>));</span><br><span class="line">threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br></pre></td></tr></table></figure><p>逆天！</p><p>气死我了！</p><p>因为是远程连接 ECS 的原因，头文件没保存，</p><p>心中一万只草泥🐎奔腾！</p><p>所以修改成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> 线程池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2023/04/19/shuati/acw1/"/>
      <url>/2023/04/19/shuati/acw1/</url>
      
        <content type="html"><![CDATA[<ol start="241"><li>楼兰图腾</li></ol><p>在完成了分配任务之后，西部 314314 来到了楼兰古城的西部。</p><p>相传很久以前这片土地上 (比楼兰古城还早) 生活着两个部落，一个部落崇拜尖刀 ( <code>V</code> )，一个部落崇拜铁锹 ( <code>∧</code> )，他们分别用  <code>V</code>  和  <code>∧</code>  的形状来代表各自部落的图腾。</p><p>西部 314314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n  个点，经测量发现这 n 个点的水平位置和竖直位置是两两不同的。</p><p>西部 314314 认为这幅壁画所包含的信息与这 n  个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)(1, 1),(2, 2),…,( ,  )，其中 y1∼yn 1∼   是 11 到 n  的一个排列。</p><p>西部 314314 打算研究这幅壁画中包含着多少个图腾。</p><p>如果三个点 (i,yi),(j,yj),(k,yk)( ,  ),( ,  ),( ,  ) 满足 1≤i&lt;j&lt;k≤n1≤ &lt; &lt; ≤  且 yi&gt;yj,yj<yk  >  ,  &lt;  ，则称这三个点构成  <code>V</code>  图腾；</p><p>如果三个点 (i,yi),(j,yj),(k,yk)( ,  ),( ,  ),( ,  ) 满足 1≤i&lt;j&lt;k≤n1≤ &lt; &lt; ≤  且 yi&lt;yj,yj&gt;yk  &lt;  ,  &gt;  ，则称这三个点构成  <code>∧</code>  图腾；</p><p>西部 314314 想知道，这 n  个点中两个部落图腾的数目。</p><p>因此，你需要编写一个程序来求出  <code>V</code>  的个数和  <code>∧</code>  的个数。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行一个数 n 。</p><p>第二行是 n  个数，分别代表 y1，y2,…,yn 1， 2,…,  。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>两个数，中间用空格隔开，依次为  <code>V</code>  的个数和  <code>∧</code>  的个数。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>对于所有数据，n≤200000 ≤200000，且输出答案不会超过 int64   64。<br>y1∼yn 1∼   是 11 到 n  的一个排列。</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 2 4</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure><p>此题用树状数组，对于每一个点找出其左边比该点值大的，右边亦如此，两个数相乘，最后得到的数就是该点中 V 的图腾个数，n 正好相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> Greater[N], lower[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        Greater[i] = <span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y);</span><br><span class="line">        lower[i] = <span class="built_in">sum</span>(y - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">    LL res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * (LL)(<span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y));</span><br><span class="line">        res2 += lower[i] * (LL)(<span class="built_in">sum</span>(y - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, res1, res2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day7</title>
      <link href="/2023/04/19/shuati/day7/"/>
      <url>/2023/04/19/shuati/day7/</url>
      
        <content type="html"><![CDATA[<h4 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和">#</a> <a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>难度中等 5885 收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组  <code>nums</code>  ，判断是否存在三元组  <code>[nums[i], nums[j], nums[k]]</code>  满足  <code>i != j</code> 、 <code>i != k</code>  且  <code>j != k</code>  ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code>  。请</p><p>你返回所有和为  <code>0</code>  且不重复的三元组。</p><p>** 注意：** 答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p>三树之和，经典老题了。</p><p>先将数组排序，随后用双指针，从头到尾，slow 的话从 i+1 开始，fast 从末尾开始。</p><p>如果 nums [i] + nums [slow] + nums [fast] &lt; 0</p><p>将 slow 右移</p><p>如果上面那个值大于 0</p><p>将 fast 左移</p><p>每次移动避开相同的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> slow = i + <span class="number">1</span>, fast = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (slow &lt; fast) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[slow]+nums[fast]+nums[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    slow ++;</span><br><span class="line">                    <span class="comment">//while (nums[slow] == nums[slow-1] &amp;&amp; slow &lt; fast) slow ++;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nums[slow]+nums[fast]+nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    fast --;</span><br><span class="line">                    <span class="comment">//while (nums[fast] == nums[fast+1] &amp;&amp; slow &lt; fast) fast --;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[slow], nums[fast]&#125;);</span><br><span class="line">                    slow ++;</span><br><span class="line">                    <span class="keyword">while</span> (nums[slow] == nums[slow<span class="number">-1</span>] &amp;&amp; slow &lt; fast) slow ++;</span><br><span class="line">                    fast --;</span><br><span class="line">                    <span class="keyword">while</span> (nums[fast] == nums[fast+<span class="number">1</span>] &amp;&amp; slow &lt; fast) fast --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res.erase(unique(res.begin(), res.end()), res.end());</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表">#</a> <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><p>难度简单 3105 收藏分享切换为英文接收动态反馈</p><p>给你单链表的头节点  <code>head</code>  ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>此题 easy 题，用一个头节点即可轻松完成翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">while</span> (h) &#123;</span><br><span class="line">            ListNode* ne = h-&gt;next;</span><br><span class="line">            h-&gt;next = q;</span><br><span class="line">            q = h;</span><br><span class="line">            h = ne;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="538-把二叉搜索树转换为累加树"><a class="markdownIt-Anchor" href="#538-把二叉搜索树转换为累加树">#</a> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>难度中等 880 收藏分享切换为英文接收动态反馈</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点  <code>node</code>  的新值等于原树中大于或等于  <code>node.val</code>  的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p>** 注意：** 本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p>反向中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">            root-&gt;val = sum;</span><br><span class="line">            <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="241"><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day6</title>
      <link href="/2023/04/18/shuati/day6/"/>
      <url>/2023/04/18/shuati/day6/</url>
      
        <content type="html"><![CDATA[<h4 id="75-颜色分类"><a class="markdownIt-Anchor" href="#75-颜色分类">#</a> <a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h4><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>示例</mtext><mn>1</mn><mtext>：输入：</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo><mtext>输出：</mtext><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">示例 1：输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">例</span><span class="mord">1</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">：</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">：</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p>这个题，炒鸡简单。、</p><p>先把 0 放放前面，再把 1 放前面，就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> two = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏">#</a> <a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p>对每个点都求一下最大可到达距离，如果有点的能够大于等于 size-1，即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> r_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r_max) &#123;</span><br><span class="line">                r_max = <span class="built_in">max</span>(r_max, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (r_max &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#剑指-offer-34-二叉树中和为某一值的路径">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br> 输出：[[5,4,11,2],[5,8,4,5]]</p><p>这道题，对每一个节点进行 dfs 操作，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        r.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        target -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, target);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, target);</span><br><span class="line">        r.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="1252"><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池代码(整合版)</title>
      <link href="/2023/04/18/thread-pool/thread-pool2/"/>
      <url>/2023/04/18/thread-pool/thread-pool2/</url>
      
        <content type="html"><![CDATA[<p>关于线程池的设计，很多都和内存池差不多，在此贴上总体代码。</p><p>后续再挨个分析细节以及编写过程中的 Bug 调试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> TASK_MAX_THRESHHOLD = <span class="number">2</span>; <span class="comment">// INT32_MAX;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>; <span class="comment">// 单位：秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">PoolMode</span> &#123;</span><br><span class="line">MODE_FIXED,  <span class="comment">// 固定数量的线程</span></span><br><span class="line">MODE_CACHED, <span class="comment">// 线程数量可动态增长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程函数对象类型</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line"><span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">: <span class="built_in">func_</span>(func)</span><br><span class="line">, <span class="built_in">threadId_</span>(generateId_++)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">~<span class="built_in">Thread</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个线程来执行一个线程函数 pthread_create</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func_, threadId_)</span></span>;  <span class="comment">// C++11来说 线程对象t  和线程函数func_</span></span><br><span class="line">t.<span class="built_in">detach</span>(); <span class="comment">// 设置分离线程   pthread_detach  pthread_t设置成分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> threadId_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ThreadFunc func_;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> generateId_;</span><br><span class="line"><span class="type">int</span> threadId_;  <span class="comment">// 保存线程id</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line"><span class="built_in">ThreadPool</span>()</span><br><span class="line">: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">curThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">threadSizeThreshHold_</span>(THREAD_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED)</span><br><span class="line">, <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程池里面所有的线程返回  有两种状态：阻塞 &amp; 正在执行任务中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">poolMode_ = mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置task任务队列上线阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池cached模式下线程阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">&#123;</span><br><span class="line">threadSizeThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池提交任务</span></span><br><span class="line"><span class="comment">// 使用可变参模板编程，让submitTask可以接收任意任务函数和任意数量的参数</span></span><br><span class="line"><span class="comment">// pool.submitTask(sum1, 10, 20);   csdn  大秦坑王  右值引用+引用折叠原理</span></span><br><span class="line"><span class="comment">// 返回值future&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 打包任务，放入任务队列里面</span></span><br><span class="line"><span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">std::future&lt;RType&gt; result = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"><span class="comment">// 用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回</span></span><br><span class="line"><span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">[&amp;]()-&gt;<span class="type">bool</span> &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; (<span class="type">size_t</span>)taskQueMaxThreshHold_; &#125;)) &#123;</span><br><span class="line"><span class="comment">// 表示notFull_等待1s种，条件依然没有满足</span></span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;task queue is full, submit task fail.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">[]()-&gt;RType &#123; <span class="keyword">return</span> <span class="built_in">RType</span>(); &#125;);</span><br><span class="line">(*task)();</span><br><span class="line"><span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有空余，把任务放入任务队列中</span></span><br><span class="line"><span class="comment">// taskQue_.emplace(sp);  </span></span><br><span class="line"><span class="comment">// using Task = std::function&lt;void()&gt;;</span></span><br><span class="line">taskQue_.<span class="built_in">emplace</span>([task]() &#123;(*task)();&#125;);</span><br><span class="line">taskSize_++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为新放了任务，任务队列肯定不空了，在notEmpty_上进行通知，赶快分配线程执行任务</span></span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式 任务处理比较紧急 场景：小而快的任务 需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程出来</span></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">&amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">&amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line"><span class="comment">// 修改线程个数相关的变量</span></span><br><span class="line">curThreadSize_++;</span><br><span class="line">idleThreadSize_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回任务的Result对象</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启线程池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> initThreadSize = std::thread::hardware_concurrency())</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录初始线程个数</span></span><br><span class="line">initThreadSize_ = initThreadSize;</span><br><span class="line">curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line"><span class="comment">// 创建thread线程对象的时候，把线程函数给到thread线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// threads_.emplace_back(std::move(ptr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动所有线程  std::vector&lt;Thread*&gt; threads_;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line">threads_[i]-&gt;<span class="built_in">start</span>(); <span class="comment">// 需要去执行一个线程函数</span></span><br><span class="line">idleThreadSize_++;    <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有任务必须执行完成，线程池才可以回收所有线程资源</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Task task; &#123;</span><br><span class="line"><span class="comment">// 先获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line"><span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line"><span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line"><span class="comment">// 锁 + 双重判断</span></span><br><span class="line"><span class="keyword">while</span> (taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line"><span class="keyword">if</span> (!isPoolRunning_) &#123;</span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line">exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 线程函数结束，线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED) &#123;</span><br><span class="line"><span class="comment">// 条件变量，超时返回了</span></span><br><span class="line"><span class="keyword">if</span> (std::cv_status::timeout ==</span><br><span class="line">notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line"><span class="keyword">if</span> (dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">&amp;&amp; curThreadSize_ &gt; initThreadSize_) &#123;</span><br><span class="line"><span class="comment">// 开始回收当前线程</span></span><br><span class="line"><span class="comment">// 记录线程数量的相关变量的值修改</span></span><br><span class="line"><span class="comment">// 把线程对象从线程列表容器中删除   没有办法 threadFunc《=》thread对象</span></span><br><span class="line"><span class="comment">// threadid =&gt; thread对象 =&gt; 删除</span></span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">curThreadSize_--;</span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 等待notEmpty条件</span></span><br><span class="line">notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从任务队列种取一个任务出来</span></span><br><span class="line">task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">taskSize_--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果依然有剩余任务，继续通知其它得线程执行任务</span></span><br><span class="line"><span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出一个任务，进行通知，通知可以继续提交生产任务</span></span><br><span class="line">notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125; <span class="comment">// 就应该把锁释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程负责执行这个任务</span></span><br><span class="line"><span class="keyword">if</span> (task != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">task</span>(); <span class="comment">// 执行function&lt;void()&gt; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_++;</span><br><span class="line">lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">// 更新线程执行完任务的时间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查pool的运行状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isPoolRunning_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_; <span class="comment">// 线程列表</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initThreadSize_;  <span class="comment">// 初始的线程数量</span></span><br><span class="line"><span class="type">int</span> threadSizeThreshHold_; <span class="comment">// 线程数量上限阈值</span></span><br><span class="line">std::atomic_int curThreadSize_;<span class="comment">// 记录当前线程池里面线程的总数量</span></span><br><span class="line">std::atomic_int idleThreadSize_; <span class="comment">// 记录空闲线程的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task任务 =》 函数对象</span></span><br><span class="line"><span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">std::queue&lt;Task&gt; taskQue_; <span class="comment">// 任务队列</span></span><br><span class="line">std::atomic_int taskSize_; <span class="comment">// 任务的数量</span></span><br><span class="line"><span class="type">int</span> taskQueMaxThreshHold_;  <span class="comment">// 任务队列数量上限阈值</span></span><br><span class="line"></span><br><span class="line">std::mutex taskQueMtx_; <span class="comment">// 保证任务队列的线程安全</span></span><br><span class="line">std::condition_variable notFull_; <span class="comment">// 表示任务队列不满</span></span><br><span class="line">std::condition_variable notEmpty_; <span class="comment">// 表示任务队列不空</span></span><br><span class="line">std::condition_variable exitCond_; <span class="comment">// 等到线程资源全部回收</span></span><br><span class="line"></span><br><span class="line">PoolMode poolMode_; <span class="comment">// 当前线程池的工作模式</span></span><br><span class="line">std::atomic_bool isPoolRunning_; <span class="comment">// 表示当前线程池的启动状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线程池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池总体设计及相关概念</title>
      <link href="/2023/04/18/thread-pool/thread-pool1/"/>
      <url>/2023/04/18/thread-pool/thread-pool1/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池">#</a> 线程池</h2><h3 id="线程池-2"><a class="markdownIt-Anchor" href="#线程池-2">#</a> 线程池</h3><p>池也算是比较常用的降低时间开销的手段了吧，</p><p>在此总结一下写过的线程池，把每一步捋顺了，再稍微复习下多线程相关的知识。</p><h4 id="关于本线程池项目描述"><a class="markdownIt-Anchor" href="#关于本线程池项目描述">#</a> 关于本线程池项目描述：</h4><ul><li>基于可变参模板编程和引用折叠原理，实现线程池 submitTask 接口，支持任意任务函数和任意参数 的传递</li><li>使用 future 类型定制 submitTask 提交任务的返回值</li><li>使用 map 和 queue 容器管理线程对象和任务</li><li>基于条件变量 condition_variable 和互斥锁 mutex 实现任务提交线程和任务执行线程间</li><li>的通信机制</li><li>支持 fixed 和 cached 模式的线程池定制</li><li>gdb 调试分析定位死锁问题</li></ul><h4 id="线程的消耗"><a class="markdownIt-Anchor" href="#线程的消耗">#</a> 线程的消耗</h4><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好？</p><ul><li>线程的创建和销毁都是非常 &quot;重&quot; 的操作</li><li>线程栈本身占用大量内存</li><li>线程的上下文切换要占用大量时间</li><li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机</li></ul><h4 id="线程池的优势"><a class="markdownIt-Anchor" href="#线程池的优势">#</a> 线程池的优势</h4><p>操作系统上创建线程和销毁线程都是很 &quot;重&quot; 的操作，耗时耗性能都比较多，那么在服务执行的过程中， 如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能 降低，业务的处理能力也会降低。 线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线 程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 task 任务即可，task 执行 完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的 task 提供服务。</p><h4 id="fixed模式线程池"><a class="markdownIt-Anchor" href="#fixed模式线程池">#</a> fixed 模式线程池</h4><p>线程池里面的线程个数是固定不变的，一般是 ThreadPool 创建时根据当前机器的 CPU 核心数量进行指 定。</p><h4 id="cached模式线程池"><a class="markdownIt-Anchor" href="#cached模式线程池">#</a> cached 模式线程池</h4><p>线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程 数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了 60s 还没 有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。</p><ul><li><p>C++11</p><p>组合和继承，多态，STL，智能指针，函数对象，绑定器，可变参模板编程</p></li><li><p>C++11 多线程编程</p><p>thread,mutxe,atomic,condition_variable,unique_lock</p></li><li><p>C<ins>17 和 C</ins>20 的标准的一些内容</p><p>17 的 any， 20 的 semaphore</p></li><li><p>多线程理论</p><p>多线程基本知识，线程互斥，线程同步，原子操作，CAS</p></li></ul><h4 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行">#</a> 并发和并行</h4><ul><li>CPU 单核</li><li>CPU 多核、多 CPU</li></ul><h4 id="并发"><a class="markdownIt-Anchor" href="#并发">#</a> 并发</h4><p>单核上，多个线程占用不同的 CPU 时间片，物理上还是串行执行的，但是由于每个线程占用的 CPU 时间 片非常短（比如 10ms），看起来就像是多个线程都在共同执行一样，这样的场景称作并发 （concurrent）。</p><h4 id="并行"><a class="markdownIt-Anchor" href="#并行">#</a> 并行</h4><p>在多核或者多 CPU 上，多个线程是在真正的同时执行，这样的场景称作并行（parallel）。</p><h3 id="多线程的优势"><a class="markdownIt-Anchor" href="#多线程的优势">#</a> 多线程的优势</h3><p>多线程程序一定就好吗？不一定，要看具体的应用场景：</p><h4 id="io密集型"><a class="markdownIt-Anchor" href="#io密集型">#</a> IO 密集型</h4><p>程序里面指令的执行，涉及一些 IO 操作 (会阻塞)</p><p>无论是 CPU 单核、CPU 多核、多 CPU，都是比较适合多线程程序的</p><h4 id="cpu密集型"><a class="markdownIt-Anchor" href="#cpu密集型">#</a> CPU 密集型</h4><p>(程序里面的指令做计算用的)</p><ul><li><p>CPU 单核</p><p>多线程存在上下文切换，是额外的花销，线程越多上下文切换所花费的额外时间也越多，倒不如一个线 程一直进 行计算。</p></li><li><p>CPU 多核、多 CPU</p><p>多个线程可以并行执行，对 CPU 利用率好</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> 线程池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池压测</title>
      <link href="/2023/04/17/mysql-pool/yace/"/>
      <url>/2023/04/17/mysql-pool/yace/</url>
      
        <content type="html"><![CDATA[<h3 id="压测"><a class="markdownIt-Anchor" href="#压测">#</a> 压测：</h3><ul><li>50393us 数据库连接池 100</li><li>424062us 普通连接 100</li></ul><p>可以看出使用线程池后效果拔群！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库连接池实现</title>
      <link href="/2023/04/17/mysql-pool/mysql-mysql-poo2/"/>
      <url>/2023/04/17/mysql-pool/mysql-mysql-poo2/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库连接池"><a class="markdownIt-Anchor" href="#数据库连接池">#</a> 数据库连接池</h3><h4 id="数据库连接池-2"><a class="markdownIt-Anchor" href="#数据库连接池-2">#</a> 数据库连接池：</h4><h5 id="小tips"><a class="markdownIt-Anchor" href="#小tips">#</a> 小 tips：</h5><p>关于外部获取连接池中的空闲连接，在此可以使用智能指针来完成内存管理，能够方便许多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">connectpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取连接池对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> connectpool* <span class="title">getconnectpool</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;<span class="comment">//给外部提供一个接口，从连接池中获取一个可用的空闲连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadconfig</span><span class="params">()</span></span>;<span class="comment">//加载配置项</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span></span>;<span class="comment">//生产新连接 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connectpool</span>();<span class="comment">//构造函数私有化</span></span><br><span class="line">    string _ip;<span class="comment">//ip地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> _port;<span class="comment">//端口号</span></span><br><span class="line">    string _username;<span class="comment">//用户名</span></span><br><span class="line">    string _password;<span class="comment">//密码</span></span><br><span class="line">    string _dbname;<span class="comment">//db名字</span></span><br><span class="line">    <span class="type">int</span> _initsize; <span class="comment">//初始连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxsize;<span class="comment">//最大连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxIdleTime;<span class="comment">//连接池最大空闲时间</span></span><br><span class="line">    <span class="type">int</span> _connectTimeout;<span class="comment">//连接池获取连接的超时时间 </span></span><br><span class="line"></span><br><span class="line">    queue&lt;connection*&gt; _connectqueue; <span class="comment">//存储mysql的队列</span></span><br><span class="line">    mutex _queueMutex;<span class="comment">//维护连接队列的线程安全互斥锁</span></span><br><span class="line">    atomic_int connectCnt;<span class="comment">//记录连接创建的connect连接的数量</span></span><br><span class="line">    condition_variable cv;<span class="comment">//设置条件变量，用于连接生产者和消费者</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="数据库连接池的构造函数"><a class="markdownIt-Anchor" href="#数据库连接池的构造函数">#</a> 数据库连接池的构造函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connectpool::<span class="built_in">connectpool</span>() &#123;</span><br><span class="line">    <span class="built_in">loadconfig</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _initsize; i ++) &#123;</span><br><span class="line">        connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">        p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">        _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">        connectCnt ++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//启动一个新的线程，作为连接的生产者</span></span><br><span class="line">    <span class="function">thread <span class="title">produce</span><span class="params">(bind(&amp;connectpool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者函数"><a class="markdownIt-Anchor" href="#生产者函数">#</a> 生产者函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::produceConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock);<span class="comment">//队列不空，生产者进入等待状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接数量没到达上限，继续创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span>(connectCnt &lt; _maxsize) &#123;</span><br><span class="line">            connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">            p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">            _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">            connectCnt ++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知消费者线程，可以消费连接</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者函数"><a class="markdownIt-Anchor" href="#消费者函数">#</a> 消费者函数：</h4><p>智能指针加 lambda 表达式</p><p>注意 sleep 和 wait-for 的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;connection&gt; <span class="title">connectpool::getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv_status::timeout ==  cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(_connectTimeout))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="built_in">LOG</span>(<span class="string">&quot;获取空闲连接超时————失败！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 智能指针析构时，会把资源delete，需要自定义 ./run</span></span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">sp</span><span class="params">(_connectqueue.front(), </span></span></span><br><span class="line"><span class="params"><span class="function">            [&amp;](connection *pcon) &#123;<span class="comment">//要考虑线程安全</span></span></span></span><br><span class="line"><span class="params"><span class="function">                unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">                pcon-&gt;refreshAliveTime();<span class="comment">//刷新一下开始空闲起始时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                _connectqueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();<span class="comment">//空了再通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除超时连接"><a class="markdownIt-Anchor" href="#删除超时连接">#</a> 删除超时连接</h4><p>应当注意在上面的代码中，在每次创建完数据库连接时刷新一下定时器，或者消费者使用完的连接返还回数据库连接池时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::scanConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//通过sleep模拟定时效果</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(_maxIdleTime));</span><br><span class="line">        <span class="comment">//扫描整个队列，释放多余连接</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (connectCnt &gt; _initsize) &#123;</span><br><span class="line">            connection *p = _connectqueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;<span class="built_in">getAliceTime</span>() &gt;= (_maxIdleTime * <span class="number">1000</span>)) &#123;</span><br><span class="line">                _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">                connectCnt --;</span><br><span class="line">                <span class="keyword">delete</span> p;<span class="comment">//释放连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//队头的连接都没超时，后面更不会</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/04/17/shuati/acw/"/>
      <url>/2023/04/17/shuati/acw/</url>
      
        <content type="html"><![CDATA[<ol start="1250"><li><strong>格子游戏</strong></li></ol><p>Alice 和 Bob 玩了一个古老的游戏：首先画一个 n×n�×� 的点阵（下图 n=3�=3 ）。</p><p>接着，他们两个轮流在相邻的点之间画上红边和蓝边：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/12/11/19_9edbcf521b-1.png" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2019/12/11/19_9edbcf521b-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.png"></p><p>直到围成一个封闭的圈（面积不必为 11）为止，“封圈” 的那个人就是赢家。因为棋盘实在是太大了，他们的游戏实在是太长了！</p><p>他们甚至在游戏中都不知道谁赢得了游戏。</p><p>于是请你写一个程序，帮助他们计算他们是否结束了游戏？</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>输入数据第一行为两个整数 n 和 m。n 表示点阵的大小，m 表示一共画了 m 条线。</p><p>以后 m 行，每行首先有两个数字 (x,y)，代表了画线的起点坐标，接着用空格隔开一个字符，假如字符是 D，则是向下连一条边，如果是 R 就是向右连一条边。</p><p>输入数据不会有重复的边且保证正确。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出一行：在第几步的时候结束。</p><p>假如 m 步之后也没有结束，则输出一行 “draw”。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤2001≤≤200，<br>1≤m≤240001≤≤24000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 1 D</span><br><span class="line">1 1 R</span><br><span class="line">1 2 D</span><br><span class="line">2 1 R</span><br><span class="line">2 2 D</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>这个题目的思路是这样的：</p><p>就是用并查集的思路去做，这个题让我们判断是否成环，我们可以思考一下，怎么才能出现环呢？</p><p>那就是当要添加进去的两个点，都在一个集合里！</p><p>这样就会出现环，因此我们只需要将每次添加进去的点存在并查集里，然后对每个即将添加进去的两个点判断一下是否在一个并查集里即可，如果在成环且返回，如果不在，将两个点添加到一个并查集即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[x] != x) a[x] = <span class="built_in">find</span>(a[x]);</span><br><span class="line">    <span class="keyword">return</span> a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; i ++) a[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;</span><br><span class="line">        x --, y--;</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">get</span>(x, y);</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;D&#x27;</span>) d = <span class="built_in">get</span>(x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> d = <span class="built_in">get</span>(x,y+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="type">int</span> pd = <span class="built_in">find</span>(d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pb == pd) &#123;</span><br><span class="line">            res = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[pb] = pd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!res) cout&lt;&lt;<span class="string">&quot;draw&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="1252"><li>搭配购买</li></ol><p>Joe 觉得云朵很美，决定去山上的商店买一些云朵。</p><p>商店里有 n 朵云，云朵被编号为 1,2,…,n1,2,…,，并且每朵云都有一个价值。</p><p>但是商店老板跟他说，一些云朵要搭配来买才好，所以买一朵云则与这朵云有搭配的云都要买。</p><p>但是 Joe 的钱有限，所以他希望买的价值越多越好。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>第 11 行包含三个整数 n，m，w，表示有 n 朵云，m 个搭配，Joe 有 w 的钱。</p><p>第 2∼n+12∼+1 行，每行两个整数 ci，di 表示 i 朵云的价钱和价值。</p><p>第 n+2∼n+1+m +2∼ +1+  行，每行两个整数 ui，vi  ，  ，表示买 ui   就必须买 vi  ，同理，如果买 vi   就必须买 ui  。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>一行，表示可以获得的最大价值。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤n≤100001≤ ≤10000,<br>0≤m≤50000≤ ≤5000,<br>1≤w≤100001≤ ≤10000,<br>1≤ci≤50001≤  ≤5000,<br>1≤di≤1001≤  ≤100,<br>1≤ui,vi≤n1≤  ,  ≤</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 3 10</span><br><span class="line">3 10</span><br><span class="line">3 10</span><br><span class="line">3 10</span><br><span class="line">5 100</span><br><span class="line">10 1</span><br><span class="line">1 3</span><br><span class="line">3 2</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>这个题啊，思路也不难。</p><p>首先我们先读入数据，然后看看新加入的两朵云是否在一个并查集里面，如果在的话，暂且不管，如果不在的话，添加以下，价格价值也需要更新。</p><p>随后遍历所有的云，仅当 p [i]==i 时，选该云，化为一个 01 背包问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], p[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(x), pb = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb) &#123;</span><br><span class="line">            v[pb] += v[pa];</span><br><span class="line">            w[pb] += w[pa];</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = q; j &gt;= v[i]; j --) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[q]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day5</title>
      <link href="/2023/04/17/shuati/day5/"/>
      <url>/2023/04/17/shuati/day5/</url>
      
        <content type="html"><![CDATA[<h4 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p>这个题啊，对于一个节点，求出其左右孩子的贡献度，且仅当该贡献度大于 0 时，选该孩子，不然不参与贡献度计算，然后对于一个节点的贡献度，为其节点的值加上左右孩子节点的最大值，就行喽！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxgain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INT_MAX;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">maxgain</span>(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">maxgain</span>(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pp = r + l + root-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, pp);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l ,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxgain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="48-旋转图像"><a class="markdownIt-Anchor" href="#48-旋转图像">#</a> <a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h4><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>这个题啊，so easy</p><p>只需要对称一下，然后对角线翻转一下，直接拿捏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) <span class="built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day4</title>
      <link href="/2023/04/15/shuati/day4/"/>
      <url>/2023/04/15/shuati/day4/</url>
      
        <content type="html"><![CDATA[<h4 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换">#</a> <a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h4><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的</p><p>DP 法</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></msub><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mtext>其中</mtext><msub><mi>f</mi><mi>i</mi></msub><mtext>表示总金额为</mtext><mi>i</mi><mtext>时的最小硬币数</mtext><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mtext>为第</mtext><mi>i</mi><mtext>个硬币的金额数</mtext></mrow><annotation encoding="application/x-tex">f_{i} = f_{i-a[i]} + 1 \\其中f_{i}表示总金额为i时的最小硬币数,a_{i}为第i个硬币的金额数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">a</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span><span class="mord cjk_fallback">为</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">硬</span><span class="mord cjk_fallback">币</span><span class="mord cjk_fallback">数</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">硬</span><span class="mord cjk_fallback">币</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span><span class="mord cjk_fallback">数</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)coins.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合">#</a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>用 dfs 来做就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; board = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//表示按到了键盘上的第几个键</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board[num].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(board[num][i]);  </span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, digits);  <span class="comment">//递归下一层</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();      <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库连接实现</title>
      <link href="/2023/04/15/mysql-pool/mysql-pool1/"/>
      <url>/2023/04/15/mysql-pool/mysql-pool1/</url>
      
        <content type="html"><![CDATA[<h4 id="mysql数据库连接实现"><a class="markdownIt-Anchor" href="#mysql数据库连接实现">#</a> MySQL 数据库连接实现</h4><h4 id="connecth"><a class="markdownIt-Anchor" href="#connecth">#</a> connect.h</h4><p>实现连接，更新，查询，可以后续添加很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">connection</span>(<span class="comment">/* args */</span>);</span><br><span class="line">    ~<span class="built_in">connection</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(string ip,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">short</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                string user,</span></span></span><br><span class="line"><span class="params"><span class="function">                string hash_password,</span></span></span><br><span class="line"><span class="params"><span class="function">                string dbname</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line">    <span class="function">MYSQL_RES* <span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    MYSQL * _conn;<span class="comment">//表示MYSQL Server的一条连接</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>connect.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connect.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//g++ -o run  main.cpp connect.cpp -I /usr/include/mysql -lmysqlclient</span></span><br><span class="line">connection::<span class="built_in">connection</span>() &#123;</span><br><span class="line">    _conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection::~<span class="built_in">connection</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_conn) <span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::connect</span><span class="params">(string ip,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">short</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                string user,</span></span></span><br><span class="line"><span class="params"><span class="function">                string hash_password,</span></span></span><br><span class="line"><span class="params"><span class="function">                string dbname)</span> </span>&#123;</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, ip.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),</span><br><span class="line">    hash_password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::update</span><span class="params">(std::string sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">         <span class="built_in">LOG</span>(<span class="string">&quot;更新失败:&quot;</span> + sql);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_RES* <span class="title">connection::query</span><span class="params">(string sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">&quot;查询失败:&quot;</span> + sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_use_result</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池框架构建</title>
      <link href="/2023/04/15/mysql-pool/mysql-pool/"/>
      <url>/2023/04/15/mysql-pool/mysql-pool/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库连接池框架构建"><a class="markdownIt-Anchor" href="#数据库连接池框架构建">#</a> 数据库连接池框架构建</h3><p>技术点：</p><p>MySQL 数据库编程、单例模式、queue 队列容器、C++11 多线程、线程互斥、线程同步和 unique_lock、基于 CAS 的原子整形、智能指针 shared_ptr、lambda 表达式、生产者消费者线程模型</p><p>在高并发情况下，大量的 TCP 三次握手，MySQL Server 连接认证、关闭连接回收资源和 TCP 四次挥手耗费的性能时间很明显，增加连接词就是为了减少这一部分的性能损耗。</p><p><strong>实现功能：</strong></p><p><strong>初始连接量</strong></p><p><strong>最大连接量</strong></p><p><strong>最大空闲时间</strong></p><p><strong>连接超时时间</strong></p><p>主要实现上述四个功能</p><p><strong>设计思路：</strong></p><ul><li>连接池只需要一个实例，所以 ConnectionPool 以单例模式设计</li><li>从 ConnectionPool 中可以获得和 MySQL 连接的 Connection</li><li>空闲连接 Connection 全部维护在一个线程安全地 Connection 队列中，使用线程互斥锁保证队列的线程安全</li><li>如果 Connection 队列为空，需要再获取连接，此时动态创建连接，上限数量是 maxSize</li><li>队列中空闲连接时间超过 maxIdleTime 的就要被释放掉，只保留初始的 initSize 就可以了，这个功能交由独立的线程去做</li><li>如果 Connection 队列为空，而此时连接的数量已达上线 maxSize，那么等待 Connection TimeOut 时间如果还获取不到空闲的连接，那么获取连接失败，此处 Connection 队列获取空闲连接，可以使用带超时时间的 mutex 互斥锁来实现连接超时时间</li><li>用户获取的连接用 shared_ptr 智能指针来管理，用 lambda 表达式定制连接释放的功能</li><li>连接的生产和连接的消费采用生产者消费者线程模型设计，使用线程间的同步通信机制条件变量和互斥锁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据库连接池遇到的一些问题</title>
      <link href="/2023/04/15/problem/problem1/"/>
      <url>/2023/04/15/problem/problem1/</url>
      
        <content type="html"><![CDATA[<h3 id="关于数据库连接池遇到的一些问题"><a class="markdownIt-Anchor" href="#关于数据库连接池遇到的一些问题">#</a> 关于数据库连接池遇到的一些问题</h3><p>首先，要记得绑 mysql 的库。</p><p>g++ -o run  main.cpp connect.cpp -I /usr/include/mysql -lmysqlclient</p><p>否则会出现一些问题，仅仅能导入是不行的。</p><p>其次是关于 mysql 的指令学习。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">CREATE DATABASES;</span><br><span class="line">USE test_db;</span><br><span class="line">CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];</span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>因为不熟悉 mysql 搞了好多低级错误，哭晕。</p><h3 id="关于破bug"><a class="markdownIt-Anchor" href="#关于破bug">#</a> 关于破 bug</h3><h4 id="segmentation-fault-core-dumped"><a class="markdownIt-Anchor" href="#segmentation-fault-core-dumped">#</a> Segmentation fault (core dumped)</h4><p>在本问题在中是指针出问题了 qaq</p><p>排查了半天</p><p>通过查资料学到了 gdb 调试的一些方法来判断是什么问题</p><h4 id="然后就是不知道为什么运行之后一直阻塞"><a class="markdownIt-Anchor" href="#然后就是不知道为什么运行之后一直阻塞">#</a> 然后就是不知道为什么运行之后一直阻塞</h4><p>排查到这个地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();<span class="comment">//空了再通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这可不行！<br>居然把返回值放到函数里面了我的错我的错</p><p>排查半天，难受死！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unix_fifo</title>
      <link href="/2023/04/14/some-tips/unix-fifo/"/>
      <url>/2023/04/14/some-tips/unix-fifo/</url>
      
        <content type="html"><![CDATA[<h3 id="管道和fifo"><a class="markdownIt-Anchor" href="#管道和fifo">#</a> 管道和 FIFO</h3><p><strong>从图 4-3 到 4-4。如果子进程没有执行 close (fd [1])，会发生什么？</strong></p><img src="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410194658129.png" class="lazyload placeholder" data-srcset="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410194658129.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410194658129" style="zoom:50%;" /><img src="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410195558952.png" class="lazyload placeholder" data-srcset="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410195558952.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410195558952" style="zoom:50%;" /><p>当父进程终止时，如果子进程中 fd [1] 处于打开状态，那么子进程对 fd [0] 的 read 不会返回文件结束符，因为 fd [1] 在子进程中仍然打开。在子进程中关闭 fd [1] 保证一旦父进程终止，它的所有描述符即关闭，从而使得子进程对 fd [0] 的 read 返回 0.</p><p><strong>如果要打开一个已有的 FIFO 或者创建一个新的 FIFO，应该调用 mkfifo，检查是否返回 EEXIST 错误，若是调用 open, 如果先调用 open，当不在所期望的 FIFO 时，再调用 mkfifo，会发生什么？</strong></p><p>如果调用关系反了，另外某个进程就有可能在本进程的 opne 和 makifo 之间创建本进程需要的 FIFO, 结果导致本进程的 FIFO 创建失败。</p><p><strong>调用 open 时，如果其中执行命令的 shell 碰到错误，那么会发生什么情况？</strong></p><img src="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410201230603.png" class="lazyload placeholder" data-srcset="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410201230603.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410201230603"  /><p><strong>针对服务器的 FIFO 的 open 去掉，验证一下这导致当不再有客户存在时，服务器即终止</strong></p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201315663.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201315663.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410201315663"></p><p><strong>在图 4-23 中，当服务器启动后，它阻塞在自己的第一个 open 调用中，知道客户的第一个 open 打开同一个 FIFO 用于写为止。我们应该怎么才能绕过这样的阻塞，使得两个 open 都立即返回，转而阻塞在首次调用 readline 上？</strong></p><p>将第一个 open 调用改位非阻塞</p><p><strong>如果图 4-24 中的客户程序对换其两个 open 调用的顺序，那么会发生什么情况？</strong></p><p>会发生死锁</p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201329799.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201329799.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410201329799"></p><p><strong>为什么在读进程关闭管道或 FIFO 之后给写进程产生一个信号，而不会在写进程关闭管道或 FIFO 之后给读进程产生一个信号？</strong></p><p>写进程关闭管道或 FIFO 的信息通过文件结束符传递给读进程。</p><p><strong>编写一个程序，确定 fstat 是否以 stat 结构的 st_size 成员的形式返回当前在某个 FIFO 中的数据字节数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 编写一个程序，确定fstat是否以stat结构的st_size成员的形</span></span><br><span class="line"><span class="comment">// 式返回当前在某个FIFO中的数据字节数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> info;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* data */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> argv[] = <span class="string">&quot;sb&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mkfifo</span>(argv, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create fifo error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd[<span class="number">0</span>] = <span class="built_in">open</span>(argv, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    fd[<span class="number">1</span>] = <span class="built_in">open</span>(argv, O_WRONLY | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">0</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[0]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">1</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[1]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;buff, <span class="built_in">sizeof</span>(buff));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">0</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[0]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">1</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[1]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 ulimit -a 查看得到</p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212714481.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212714481.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230414212714481"></p><p>代码运行得到</p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212735466.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212735466.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230414212735466"></p><p>因此并不是某个 FIFO 中的数据字节数</p><p>create fifo error 是因为之前以及创建过了。</p><p><strong>编写一个程序，以确定在为一个读出端已关闭的管道描述符选择可写条件时 select 返回的内容。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>], n;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    fd_set wset;</span><br><span class="line">    <span class="built_in">pipe</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> ( (childpid == fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child closing pipe read description \n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;wset);</span><br><span class="line">    <span class="built_in">FD_SET</span>(fd[<span class="number">1</span>], &amp;wset);</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">select</span>(fd[<span class="number">1</span>]+<span class="number">1</span>, <span class="literal">NULL</span>, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;select returned %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fd[<span class="number">1</span>], &amp;wset)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd[1] writable\n&quot;</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414214217555.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414214217555.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230414214217555"></p>]]></content>
      
      
      
        <tags>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day3</title>
      <link href="/2023/04/14/shuati/day3/"/>
      <url>/2023/04/14/shuati/day3/</url>
      
        <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历">#</a> <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点  <code>root</code>  ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p>没什么好说的，开干！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">middle_sort</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">middle_sort</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">middle_sort</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">middle_sort</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="114-二叉树展开为链表"><a class="markdownIt-Anchor" href="#114-二叉树展开为链表">#</a> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode* l = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (l) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l-&gt;right) l = l-&gt;right;</span><br><span class="line">            l-&gt;right = root-&gt;right;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个题啊，先将左子树拿到右边，再对右边递归即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qndxx</title>
      <link href="/2023/04/13/some-tips/qndxx/"/>
      <url>/2023/04/13/some-tips/qndxx/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> anti_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line">openId = <span class="string">&quot;&quot;</span></span><br><span class="line">current_path = os.getcwd()</span><br><span class="line">f = <span class="built_in">open</span>(current_path + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;log.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeHeader</span>(<span class="params">openid=openId</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/javascript, */*; q=0.01&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh-Hans;q=0.9&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;JSESSIONID=&#x27;</span> + secrets.token_urlsafe(<span class="number">40</span>),</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.jxqingtuan.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;http://www.jxqingtuan.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://www.jxqingtuan.cn/html/h5_index.html&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: UserAgent(platform=<span class="string">&quot;iphone&quot;</span>).wechat,</span><br><span class="line">        <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkConfig</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cardNo) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cardNo对应第五行数据，不可为空&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nid) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cardNo是团委组织ID，不可为空&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="comment"># info = json.dumps(getIDInfo())</span></span><br><span class="line">    res = getIDInfo()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) != <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;团委组织id异常，您似乎获取错了&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIDInfo</span>():</span><br><span class="line">    url = <span class="string">&quot;http://www.jxqingtuan.cn/pub/vol/config/organization?pid=&quot;</span> + nid</span><br><span class="line">    res = json.loads(requests.get(url, headers=makeHeader()).text)</span><br><span class="line">    <span class="keyword">if</span> res.get(<span class="string">&quot;status&quot;</span>) == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> res.get(<span class="string">&quot;result&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查询组织导致未知错误：&quot;</span> + res.text)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getCourse</span>():</span><br><span class="line">    url = <span class="string">&quot;http://www.jxqingtuan.cn/pub/vol/volClass/current&quot;</span></span><br><span class="line">    CourseJson = requests.get(url, headers=makeHeader()).json()</span><br><span class="line">    Course = CourseJson.get(<span class="string">&quot;result&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;课程id：&quot;</span> + Course.get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">        f.write(<span class="string">&quot;课程id：&quot;</span> + Course.get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;课程名称：&quot;</span> + Course.get(<span class="string">&quot;title&quot;</span>))</span><br><span class="line">        f.write(<span class="string">&quot;课程名称：&quot;</span> + Course.get(<span class="string">&quot;title&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> Course.get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查询课程致未知错误&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;查询课程致未知错误&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getStudy</span>(<span class="params">course, nid, subOrg, cardNo</span>):</span><br><span class="line">    url = <span class="string">&quot;http://www.jxqingtuan.cn/pub/vol/volClass/join?accessToken=&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subOrg) &gt; <span class="number">0</span>:</span><br><span class="line">        data = &#123;<span class="string">&quot;course&quot;</span>: course, <span class="string">&quot;subOrg&quot;</span>: subOrg, <span class="string">&quot;nid&quot;</span>: nid, <span class="string">&quot;cardNo&quot;</span>: cardNo&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = &#123;<span class="string">&quot;course&quot;</span>: course, <span class="string">&quot;subOrg&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;nid&quot;</span>: nid, <span class="string">&quot;cardNo&quot;</span>: cardNo&#125;</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    res = json.loads(</span><br><span class="line">        (requests.post(url=url, data=json.dumps(data, ensure_ascii=<span class="literal">False</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>), headers=makeHeader())).text)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="keyword">if</span> res.get(<span class="string">&quot;status&quot;</span>) == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(cardNo + <span class="string">&quot;大学习成功！&quot;</span>)</span><br><span class="line">        f.write(cardNo + <span class="string">&quot;大学习成功！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;提交大学习导致未知错误：&quot;</span> + res.text)</span><br><span class="line">        f.write(<span class="string">&quot;提交大学习导致未知错误：&quot;</span> + res.text)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">face = [<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    nid = <span class="string">&quot;N0013000110151019&quot;</span></span><br><span class="line">    subOrg = <span class="string">&quot;&quot;</span></span><br><span class="line">    cardNo = <span class="built_in">str</span>(face[i])</span><br><span class="line">    openId = <span class="string">&quot;&quot;</span></span><br><span class="line">    checkConfig()</span><br><span class="line">    getStudy(getCourse(), nid, subOrg, cardNo)   </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>python 实现的完成青年大学习的脚本喽</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青年大学习打卡py </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NCU校园网自动登录</title>
      <link href="/2023/04/13/some-tips/ncuxyw/"/>
      <url>/2023/04/13/some-tips/ncuxyw/</url>
      
        <content type="html"><![CDATA[<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> username,password,IE</span><br><span class="line">username = <span class="string">&quot;&quot;</span> <span class="keyword">REM</span>此处引号填入学号</span><br><span class="line">password = <span class="string">&quot;&quot;</span>  <span class="keyword">REM</span>此处引号填入密码</span><br><span class="line"><span class="keyword">Set</span> IE =<span class="built_in">CreateObject</span>(<span class="string">&quot;InternetExplorer.Application&quot;</span>)</span><br><span class="line">ie.FullScreen=<span class="number">0</span></span><br><span class="line">IE.Visible = <span class="literal">True</span></span><br><span class="line">IE.Navigate <span class="string">&quot;http://222.204.3.154/srun_portal_pc?ac_id=5&amp;srun_wait=1&amp;theme=basic1&quot;</span>  </span><br><span class="line"><span class="keyword">Do</span> <span class="keyword">while</span> IE.ReadyState&lt;&gt; <span class="number">4</span> <span class="keyword">or</span> IE.busy</span><br><span class="line">wscript.sleep <span class="number">2000</span> </span><br><span class="line"><span class="keyword">loop</span></span><br><span class="line">IE.document.querySelector(<span class="string">&quot;#username&quot;</span>).value=username  </span><br><span class="line">IE.document.querySelector(<span class="string">&quot;#password&quot;</span>).value=password</span><br><span class="line">ie.document.getElementsByName(<span class="string">&quot;domain&quot;</span>)(<span class="number">0</span>).children(<span class="number">1</span>).selected=trueREM     children <span class="keyword">REM</span>括号里的数字移动<span class="number">1</span>电信<span class="number">3</span>联通<span class="number">4</span></span><br><span class="line"><span class="keyword">Set</span> btn =ie.Document.getElementById(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">btn.click <span class="keyword">REM</span>将将文件后缀名改为.vbs点击即可运行</span><br></pre></td></tr></table></figure><p>用简单 vbs 脚本实现南昌大学校园网自动登录，设置开机自启动后就行了，放桌面上点一下也是没问题的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NCU校园网自动登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day2</title>
      <link href="/2023/04/13/shuati/day2/"/>
      <url>/2023/04/13/shuati/day2/</url>
      
        <content type="html"><![CDATA[<h4 id="day2"><a class="markdownIt-Anchor" href="#day2">#</a> day2</h4><h4 id="236-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#236-二叉树的最近公共祖先">#</a> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> l = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="type">bool</span> r = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((l &amp;&amp; r) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (l || r))) res = root;</span><br><span class="line">        <span class="keyword">return</span> l || r || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs 喽，把握住什么是最近公共祖先就行了！</p><p>今天有点忏愧，有点摆了。</p><p>早上寝室断电，大雨也不好充，晚上又看了好久小说，今天就这样吧，刷一道题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试中的小bug</title>
      <link href="/2023/04/13/problem/problem/"/>
      <url>/2023/04/13/problem/problem/</url>
      
        <content type="html"><![CDATA[<h4 id="在自定义widget的时候出现如下错误field-w-has-incomplete-type"><a class="markdownIt-Anchor" href="#在自定义widget的时候出现如下错误field-w-has-incomplete-type">#</a> 在自定义 Widget 的时候出现如下错误 field w has incomplete type</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Widget w;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wwrite</span><span class="params">(QString s, QWidget *widget)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">savestabuyEditinfo</span><span class="params">(QLineEdit *lineEditPass, QString tex)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是因为头文件对类或者结构体进行了前向声明，后面使用了该类定义了对象，导致编译报错。</p><p>原因在于前向声明类或者结构体，此时编译器还不知道定义，无法知道类内部成员，所以无法构造实例对象，因此前向声明的类或者结构体只能用来定义指针或者引用。</p><h4 id="cannot-call-member-function-without-object-处理"><a class="markdownIt-Anchor" href="#cannot-call-member-function-without-object-处理">#</a> cannot call member function ‘ ‘ without object 处理</h4><p>应该先初始化一个类哦这个</p><p><strong>莫名其妙的注释掉的函数也会出现提示我未初始化，这个时候需要将整个项目重构</strong></p><h4 id="no-such-slot-widgetsavestabuyeditinfolineedit-text-in"><a class="markdownIt-Anchor" href="#no-such-slot-widgetsavestabuyeditinfolineedit-text-in">#</a> No such slot Widget::savestabuyEditinfo(lineEdit, text) in</h4><p>奇怪，明明以及在 Widget 里 public slots 声明了，却仍然有问题</p><h4 id="qiodevicewrite-qfile-dqtprojectaguaguimage"><a class="markdownIt-Anchor" href="#qiodevicewrite-qfile-dqtprojectaguaguimage">#</a> QIODevice::write (QFile, &quot;D:qtprojectaguaguimage</h4><h4 id="es-device-not-open"><a class="markdownIt-Anchor" href="#es-device-not-open">#</a> es&quot;): device not open</h4><p>服了，qt 读取 txt 并不用和 image 一样，还得加到工程看里</p><p>信号槽的问题，一直检测不到</p><p>文件读写的问题，一直写不上</p><p>吐了吐了</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day1</title>
      <link href="/2023/04/12/shuati/lc/"/>
      <url>/2023/04/12/shuati/lc/</url>
      
        <content type="html"><![CDATA[<h4 id="238-除自身以外数组的乘积"><a class="markdownIt-Anchor" href="#238-除自身以外数组的乘积">#</a> <a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer [i] 等于 nums 中除 nums [i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums 之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O (n) 时间复杂度内完成此题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p>遍历两边</p><p>用 l 记录该点左侧所有数的成绩，</p><p>随后倒过来再算右边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        l[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            l[i] = l[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            l[i] = l[i] * r;</span><br><span class="line">            r *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量">#</a> <a href="https://leetcode.cn/problems/task-scheduler/">[200. 岛屿数量]</a></h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和 / 或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(x == grid.size() &amp;&amp; y == grid[0].size()) return ;</span></span><br><span class="line">        grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x<span class="number">-1</span>][y] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(y<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span> &lt; grid.<span class="built_in">size</span>() &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(y+<span class="number">1</span> &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x, y+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对岛屿问题，深搜即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秋招学习器基础功能</title>
      <link href="/2023/04/12/autum-study/dayi/"/>
      <url>/2023/04/12/autum-study/dayi/</url>
      
        <content type="html"><![CDATA[<h2 id="day1"><a class="markdownIt-Anchor" href="#day1">#</a> day1</h2><p>今天实现如下功能：</p><ul><li><p>mainwindow 添加菜单栏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar *bar = <span class="built_in">menuBar</span>();<span class="comment">//创建菜单栏</span></span><br><span class="line"><span class="comment">//中间各种操作</span></span><br><span class="line"><span class="built_in">setMenuBar</span>(bar);</span><br></pre></td></tr></table></figure></li><li><p>点击相应菜单栏中的每个按钮可以跳转到另外一个页面</p><p>使用 connect</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处需要在类中如下</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openNewWindow</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//实现如下</span></span><br><span class="line">QAction *action1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;八股&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">bar-&gt;<span class="built_in">addAction</span>(action1);</span><br><span class="line"><span class="built_in">connect</span>(action1, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">openNewWindow</span>()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openNewWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QWidget *newWindow = <span class="keyword">new</span> QWidget;</span><br><span class="line">    newWindow-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;New Window&quot;</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">bkgnd</span><span class="params">(<span class="string">&quot;:/new/prefix1/10.png&quot;</span>)</span></span>;</span><br><span class="line">    bkgnd = bkgnd.<span class="built_in">scaled</span>(<span class="keyword">this</span>-&gt;<span class="built_in">size</span>(), Qt::IgnoreAspectRatio);</span><br><span class="line">    QPalette palette;</span><br><span class="line">    palette.<span class="built_in">setBrush</span>(QPalette::Background, bkgnd);</span><br><span class="line">    newWindow-&gt;<span class="built_in">setPalette</span>(palette);</span><br><span class="line">    newWindow-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>背景图</p><p>此处需要首先在工程中添加 resource 文件，再向其中添加图片，否则就算路径正确也会读取不出来图片</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">bkgnd</span><span class="params">(<span class="string">&quot;:/new/prefix1/6.png&quot;</span>)</span></span>;</span><br><span class="line">bkgnd = bkgnd.<span class="built_in">scaled</span>(<span class="keyword">this</span>-&gt;<span class="built_in">size</span>(), Qt::IgnoreAspectRatio);</span><br><span class="line">QPalette palette;</span><br><span class="line">palette.<span class="built_in">setBrush</span>(QPalette::Background, bkgnd);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(palette);</span><br></pre></td></tr></table></figure></li></ul><p>明日计划：</p><p>实现打开的页面中能够读取 txt，写入 txt, 以及答案匹配，实现基础问答形式。</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 秋招学习器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/11/hello-world/"/>
      <url>/2023/04/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start">#</a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post">#</a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server">#</a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files">#</a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
