<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题day6</title>
      <link href="/2023/04/18/day6/"/>
      <url>/2023/04/18/day6/</url>
      
        <content type="html"><![CDATA[<h4 id="75-颜色分类"><a class="markdownIt-Anchor" href="#75-颜色分类">#</a> <a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h4><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>示例</mtext><mn>1</mn><mtext>：输入：</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo><mtext>输出：</mtext><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">示例 1：输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">例</span><span class="mord">1</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">：</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">：</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p>这个题，炒鸡简单。、</p><p>先把 0 放放前面，再把 1 放前面，就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> two = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏">#</a> <a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p>对每个点都求一下最大可到达距离，如果有点的能够大于等于 size-1，即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> r_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r_max) &#123;</span><br><span class="line">                r_max = <span class="built_in">max</span>(r_max, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (r_max &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#剑指-offer-34-二叉树中和为某一值的路径">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br> 输出：[[5,4,11,2],[5,8,4,5]]</p><p>这道题，对每一个节点进行 dfs 操作，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        r.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        target -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, target);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, target);</span><br><span class="line">        r.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="1252"><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池代码(整合版)</title>
      <link href="/2023/04/18/thread-pool2/"/>
      <url>/2023/04/18/thread-pool2/</url>
      
        <content type="html"><![CDATA[<p>关于线程池的设计，很多都和内存池差不多，在此贴上总体代码。</p><p>后续再挨个分析细节以及编写过程中的 Bug 调试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> TASK_MAX_THRESHHOLD = <span class="number">2</span>; <span class="comment">// INT32_MAX;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>; <span class="comment">// 单位：秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">PoolMode</span> &#123;</span><br><span class="line">MODE_FIXED,  <span class="comment">// 固定数量的线程</span></span><br><span class="line">MODE_CACHED, <span class="comment">// 线程数量可动态增长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程函数对象类型</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line"><span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">: <span class="built_in">func_</span>(func)</span><br><span class="line">, <span class="built_in">threadId_</span>(generateId_++)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">~<span class="built_in">Thread</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个线程来执行一个线程函数 pthread_create</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func_, threadId_)</span></span>;  <span class="comment">// C++11来说 线程对象t  和线程函数func_</span></span><br><span class="line">t.<span class="built_in">detach</span>(); <span class="comment">// 设置分离线程   pthread_detach  pthread_t设置成分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> threadId_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ThreadFunc func_;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> generateId_;</span><br><span class="line"><span class="type">int</span> threadId_;  <span class="comment">// 保存线程id</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line"><span class="built_in">ThreadPool</span>()</span><br><span class="line">: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">curThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">threadSizeThreshHold_</span>(THREAD_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED)</span><br><span class="line">, <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程池里面所有的线程返回  有两种状态：阻塞 &amp; 正在执行任务中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">poolMode_ = mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置task任务队列上线阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池cached模式下线程阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">&#123;</span><br><span class="line">threadSizeThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池提交任务</span></span><br><span class="line"><span class="comment">// 使用可变参模板编程，让submitTask可以接收任意任务函数和任意数量的参数</span></span><br><span class="line"><span class="comment">// pool.submitTask(sum1, 10, 20);   csdn  大秦坑王  右值引用+引用折叠原理</span></span><br><span class="line"><span class="comment">// 返回值future&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 打包任务，放入任务队列里面</span></span><br><span class="line"><span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">std::future&lt;RType&gt; result = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"><span class="comment">// 用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回</span></span><br><span class="line"><span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">[&amp;]()-&gt;<span class="type">bool</span> &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; (<span class="type">size_t</span>)taskQueMaxThreshHold_; &#125;)) &#123;</span><br><span class="line"><span class="comment">// 表示notFull_等待1s种，条件依然没有满足</span></span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;task queue is full, submit task fail.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">[]()-&gt;RType &#123; <span class="keyword">return</span> <span class="built_in">RType</span>(); &#125;);</span><br><span class="line">(*task)();</span><br><span class="line"><span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有空余，把任务放入任务队列中</span></span><br><span class="line"><span class="comment">// taskQue_.emplace(sp);  </span></span><br><span class="line"><span class="comment">// using Task = std::function&lt;void()&gt;;</span></span><br><span class="line">taskQue_.<span class="built_in">emplace</span>([task]() &#123;(*task)();&#125;);</span><br><span class="line">taskSize_++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为新放了任务，任务队列肯定不空了，在notEmpty_上进行通知，赶快分配线程执行任务</span></span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式 任务处理比较紧急 场景：小而快的任务 需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程出来</span></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">&amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">&amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line"><span class="comment">// 修改线程个数相关的变量</span></span><br><span class="line">curThreadSize_++;</span><br><span class="line">idleThreadSize_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回任务的Result对象</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启线程池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> initThreadSize = std::thread::hardware_concurrency())</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录初始线程个数</span></span><br><span class="line">initThreadSize_ = initThreadSize;</span><br><span class="line">curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line"><span class="comment">// 创建thread线程对象的时候，把线程函数给到thread线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// threads_.emplace_back(std::move(ptr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动所有线程  std::vector&lt;Thread*&gt; threads_;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line">threads_[i]-&gt;<span class="built_in">start</span>(); <span class="comment">// 需要去执行一个线程函数</span></span><br><span class="line">idleThreadSize_++;    <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有任务必须执行完成，线程池才可以回收所有线程资源</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Task task; &#123;</span><br><span class="line"><span class="comment">// 先获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line"><span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line"><span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line"><span class="comment">// 锁 + 双重判断</span></span><br><span class="line"><span class="keyword">while</span> (taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line"><span class="keyword">if</span> (!isPoolRunning_) &#123;</span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line">exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 线程函数结束，线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED) &#123;</span><br><span class="line"><span class="comment">// 条件变量，超时返回了</span></span><br><span class="line"><span class="keyword">if</span> (std::cv_status::timeout ==</span><br><span class="line">notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line"><span class="keyword">if</span> (dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">&amp;&amp; curThreadSize_ &gt; initThreadSize_) &#123;</span><br><span class="line"><span class="comment">// 开始回收当前线程</span></span><br><span class="line"><span class="comment">// 记录线程数量的相关变量的值修改</span></span><br><span class="line"><span class="comment">// 把线程对象从线程列表容器中删除   没有办法 threadFunc《=》thread对象</span></span><br><span class="line"><span class="comment">// threadid =&gt; thread对象 =&gt; 删除</span></span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">curThreadSize_--;</span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 等待notEmpty条件</span></span><br><span class="line">notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从任务队列种取一个任务出来</span></span><br><span class="line">task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">taskSize_--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果依然有剩余任务，继续通知其它得线程执行任务</span></span><br><span class="line"><span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出一个任务，进行通知，通知可以继续提交生产任务</span></span><br><span class="line">notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125; <span class="comment">// 就应该把锁释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程负责执行这个任务</span></span><br><span class="line"><span class="keyword">if</span> (task != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">task</span>(); <span class="comment">// 执行function&lt;void()&gt; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_++;</span><br><span class="line">lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">// 更新线程执行完任务的时间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查pool的运行状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isPoolRunning_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_; <span class="comment">// 线程列表</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initThreadSize_;  <span class="comment">// 初始的线程数量</span></span><br><span class="line"><span class="type">int</span> threadSizeThreshHold_; <span class="comment">// 线程数量上限阈值</span></span><br><span class="line">std::atomic_int curThreadSize_;<span class="comment">// 记录当前线程池里面线程的总数量</span></span><br><span class="line">std::atomic_int idleThreadSize_; <span class="comment">// 记录空闲线程的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task任务 =》 函数对象</span></span><br><span class="line"><span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">std::queue&lt;Task&gt; taskQue_; <span class="comment">// 任务队列</span></span><br><span class="line">std::atomic_int taskSize_; <span class="comment">// 任务的数量</span></span><br><span class="line"><span class="type">int</span> taskQueMaxThreshHold_;  <span class="comment">// 任务队列数量上限阈值</span></span><br><span class="line"></span><br><span class="line">std::mutex taskQueMtx_; <span class="comment">// 保证任务队列的线程安全</span></span><br><span class="line">std::condition_variable notFull_; <span class="comment">// 表示任务队列不满</span></span><br><span class="line">std::condition_variable notEmpty_; <span class="comment">// 表示任务队列不空</span></span><br><span class="line">std::condition_variable exitCond_; <span class="comment">// 等到线程资源全部回收</span></span><br><span class="line"></span><br><span class="line">PoolMode poolMode_; <span class="comment">// 当前线程池的工作模式</span></span><br><span class="line">std::atomic_bool isPoolRunning_; <span class="comment">// 表示当前线程池的启动状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线程池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池总体设计及相关概念</title>
      <link href="/2023/04/18/thread-pool1/"/>
      <url>/2023/04/18/thread-pool1/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池">#</a> 线程池</h2><h3 id="线程池-2"><a class="markdownIt-Anchor" href="#线程池-2">#</a> 线程池</h3><p>池也算是比较常用的降低时间开销的手段了吧，</p><p>在此总结一下写过的线程池，把每一步捋顺了，再稍微复习下多线程相关的知识。</p><h4 id="关于本线程池项目描述"><a class="markdownIt-Anchor" href="#关于本线程池项目描述">#</a> 关于本线程池项目描述：</h4><ul><li>基于可变参模板编程和引用折叠原理，实现线程池 submitTask 接口，支持任意任务函数和任意参数 的传递</li><li>使用 future 类型定制 submitTask 提交任务的返回值</li><li>使用 map 和 queue 容器管理线程对象和任务</li><li>基于条件变量 condition_variable 和互斥锁 mutex 实现任务提交线程和任务执行线程间</li><li>的通信机制</li><li>支持 fixed 和 cached 模式的线程池定制</li><li>gdb 调试分析定位死锁问题</li></ul><h4 id="线程的消耗"><a class="markdownIt-Anchor" href="#线程的消耗">#</a> 线程的消耗</h4><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好？</p><ul><li>线程的创建和销毁都是非常 &quot;重&quot; 的操作</li><li>线程栈本身占用大量内存</li><li>线程的上下文切换要占用大量时间</li><li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机</li></ul><h4 id="线程池的优势"><a class="markdownIt-Anchor" href="#线程池的优势">#</a> 线程池的优势</h4><p>操作系统上创建线程和销毁线程都是很 &quot;重&quot; 的操作，耗时耗性能都比较多，那么在服务执行的过程中， 如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能 降低，业务的处理能力也会降低。 线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线 程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 task 任务即可，task 执行 完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的 task 提供服务。</p><h4 id="fixed模式线程池"><a class="markdownIt-Anchor" href="#fixed模式线程池">#</a> fixed 模式线程池</h4><p>线程池里面的线程个数是固定不变的，一般是 ThreadPool 创建时根据当前机器的 CPU 核心数量进行指 定。</p><h4 id="cached模式线程池"><a class="markdownIt-Anchor" href="#cached模式线程池">#</a> cached 模式线程池</h4><p>线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程 数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了 60s 还没 有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。</p><ul><li><p>C++11</p><p>组合和继承，多态，STL，智能指针，函数对象，绑定器，可变参模板编程</p></li><li><p>C++11 多线程编程</p><p>thread,mutxe,atomic,condition_variable,unique_lock</p></li><li><p>C<ins>17 和 C</ins>20 的标准的一些内容</p><p>17 的 any， 20 的 semaphore</p></li><li><p>多线程理论</p><p>多线程基本知识，线程互斥，线程同步，原子操作，CAS</p></li></ul><h4 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行">#</a> 并发和并行</h4><ul><li>CPU 单核</li><li>CPU 多核、多 CPU</li></ul><h4 id="并发"><a class="markdownIt-Anchor" href="#并发">#</a> 并发</h4><p>单核上，多个线程占用不同的 CPU 时间片，物理上还是串行执行的，但是由于每个线程占用的 CPU 时间 片非常短（比如 10ms），看起来就像是多个线程都在共同执行一样，这样的场景称作并发 （concurrent）。</p><h4 id="并行"><a class="markdownIt-Anchor" href="#并行">#</a> 并行</h4><p>在多核或者多 CPU 上，多个线程是在真正的同时执行，这样的场景称作并行（parallel）。</p><h3 id="多线程的优势"><a class="markdownIt-Anchor" href="#多线程的优势">#</a> 多线程的优势</h3><p>多线程程序一定就好吗？不一定，要看具体的应用场景：</p><h4 id="io密集型"><a class="markdownIt-Anchor" href="#io密集型">#</a> IO 密集型</h4><p>程序里面指令的执行，涉及一些 IO 操作 (会阻塞)</p><p>无论是 CPU 单核、CPU 多核、多 CPU，都是比较适合多线程程序的</p><h4 id="cpu密集型"><a class="markdownIt-Anchor" href="#cpu密集型">#</a> CPU 密集型</h4><p>(程序里面的指令做计算用的)</p><ul><li><p>CPU 单核</p><p>多线程存在上下文切换，是额外的花销，线程越多上下文切换所花费的额外时间也越多，倒不如一个线 程一直进 行计算。</p></li><li><p>CPU 多核、多 CPU</p><p>多个线程可以并行执行，对 CPU 利用率好</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 线程池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池压测</title>
      <link href="/2023/04/17/yace/"/>
      <url>/2023/04/17/yace/</url>
      
        <content type="html"><![CDATA[<h3 id="压测"><a class="markdownIt-Anchor" href="#压测">#</a> 压测：</h3><ul><li>50393us 数据库连接池 100</li><li>424062us 普通连接 100</li></ul><p>可以看出使用线程池后效果拔群！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库连接池实现</title>
      <link href="/2023/04/17/mysql-mysql-poo2/"/>
      <url>/2023/04/17/mysql-mysql-poo2/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库连接池"><a class="markdownIt-Anchor" href="#数据库连接池">#</a> 数据库连接池</h3><h4 id="数据库连接池-2"><a class="markdownIt-Anchor" href="#数据库连接池-2">#</a> 数据库连接池：</h4><h5 id="小tips"><a class="markdownIt-Anchor" href="#小tips">#</a> 小 tips：</h5><p>关于外部获取连接池中的空闲连接，在此可以使用智能指针来完成内存管理，能够方便许多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">connectpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取连接池对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> connectpool* <span class="title">getconnectpool</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;<span class="comment">//给外部提供一个接口，从连接池中获取一个可用的空闲连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadconfig</span><span class="params">()</span></span>;<span class="comment">//加载配置项</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span></span>;<span class="comment">//生产新连接 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connectpool</span>();<span class="comment">//构造函数私有化</span></span><br><span class="line">    string _ip;<span class="comment">//ip地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> _port;<span class="comment">//端口号</span></span><br><span class="line">    string _username;<span class="comment">//用户名</span></span><br><span class="line">    string _password;<span class="comment">//密码</span></span><br><span class="line">    string _dbname;<span class="comment">//db名字</span></span><br><span class="line">    <span class="type">int</span> _initsize; <span class="comment">//初始连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxsize;<span class="comment">//最大连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxIdleTime;<span class="comment">//连接池最大空闲时间</span></span><br><span class="line">    <span class="type">int</span> _connectTimeout;<span class="comment">//连接池获取连接的超时时间 </span></span><br><span class="line"></span><br><span class="line">    queue&lt;connection*&gt; _connectqueue; <span class="comment">//存储mysql的队列</span></span><br><span class="line">    mutex _queueMutex;<span class="comment">//维护连接队列的线程安全互斥锁</span></span><br><span class="line">    atomic_int connectCnt;<span class="comment">//记录连接创建的connect连接的数量</span></span><br><span class="line">    condition_variable cv;<span class="comment">//设置条件变量，用于连接生产者和消费者</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="数据库连接池的构造函数"><a class="markdownIt-Anchor" href="#数据库连接池的构造函数">#</a> 数据库连接池的构造函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connectpool::<span class="built_in">connectpool</span>() &#123;</span><br><span class="line">    <span class="built_in">loadconfig</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _initsize; i ++) &#123;</span><br><span class="line">        connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">        p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">        _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">        connectCnt ++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//启动一个新的线程，作为连接的生产者</span></span><br><span class="line">    <span class="function">thread <span class="title">produce</span><span class="params">(bind(&amp;connectpool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者函数"><a class="markdownIt-Anchor" href="#生产者函数">#</a> 生产者函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::produceConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock);<span class="comment">//队列不空，生产者进入等待状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接数量没到达上限，继续创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span>(connectCnt &lt; _maxsize) &#123;</span><br><span class="line">            connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">            p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">            _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">            connectCnt ++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知消费者线程，可以消费连接</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者函数"><a class="markdownIt-Anchor" href="#消费者函数">#</a> 消费者函数：</h4><p>智能指针加 lambda 表达式</p><p>注意 sleep 和 wait-for 的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;connection&gt; <span class="title">connectpool::getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv_status::timeout ==  cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(_connectTimeout))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="built_in">LOG</span>(<span class="string">&quot;获取空闲连接超时————失败！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 智能指针析构时，会把资源delete，需要自定义 ./run</span></span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">sp</span><span class="params">(_connectqueue.front(), </span></span></span><br><span class="line"><span class="params"><span class="function">            [&amp;](connection *pcon) &#123;<span class="comment">//要考虑线程安全</span></span></span></span><br><span class="line"><span class="params"><span class="function">                unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">                pcon-&gt;refreshAliveTime();<span class="comment">//刷新一下开始空闲起始时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                _connectqueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();<span class="comment">//空了再通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除超时连接"><a class="markdownIt-Anchor" href="#删除超时连接">#</a> 删除超时连接</h4><p>应当注意在上面的代码中，在每次创建完数据库连接时刷新一下定时器，或者消费者使用完的连接返还回数据库连接池时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::scanConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//通过sleep模拟定时效果</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(_maxIdleTime));</span><br><span class="line">        <span class="comment">//扫描整个队列，释放多余连接</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (connectCnt &gt; _initsize) &#123;</span><br><span class="line">            connection *p = _connectqueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;<span class="built_in">getAliceTime</span>() &gt;= (_maxIdleTime * <span class="number">1000</span>)) &#123;</span><br><span class="line">                _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">                connectCnt --;</span><br><span class="line">                <span class="keyword">delete</span> p;<span class="comment">//释放连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//队头的连接都没超时，后面更不会</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/04/17/acw/"/>
      <url>/2023/04/17/acw/</url>
      
        <content type="html"><![CDATA[<ol start="1250"><li><strong>格子游戏</strong></li></ol><p>Alice 和 Bob 玩了一个古老的游戏：首先画一个 n×n�×� 的点阵（下图 n=3�=3 ）。</p><p>接着，他们两个轮流在相邻的点之间画上红边和蓝边：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/12/11/19_9edbcf521b-1.png" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2019/12/11/19_9edbcf521b-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.png"></p><p>直到围成一个封闭的圈（面积不必为 11）为止，“封圈” 的那个人就是赢家。因为棋盘实在是太大了，他们的游戏实在是太长了！</p><p>他们甚至在游戏中都不知道谁赢得了游戏。</p><p>于是请你写一个程序，帮助他们计算他们是否结束了游戏？</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>输入数据第一行为两个整数 n 和 m。n 表示点阵的大小，m 表示一共画了 m 条线。</p><p>以后 m 行，每行首先有两个数字 (x,y)，代表了画线的起点坐标，接着用空格隔开一个字符，假如字符是 D，则是向下连一条边，如果是 R 就是向右连一条边。</p><p>输入数据不会有重复的边且保证正确。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出一行：在第几步的时候结束。</p><p>假如 m 步之后也没有结束，则输出一行 “draw”。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤2001≤≤200，<br>1≤m≤240001≤≤24000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 1 D</span><br><span class="line">1 1 R</span><br><span class="line">1 2 D</span><br><span class="line">2 1 R</span><br><span class="line">2 2 D</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>这个题目的思路是这样的：</p><p>就是用并查集的思路去做，这个题让我们判断是否成环，我们可以思考一下，怎么才能出现环呢？</p><p>那就是当要添加进去的两个点，都在一个集合里！</p><p>这样就会出现环，因此我们只需要将每次添加进去的点存在并查集里，然后对每个即将添加进去的两个点判断一下是否在一个并查集里即可，如果在成环且返回，如果不在，将两个点添加到一个并查集即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[x] != x) a[x] = <span class="built_in">find</span>(a[x]);</span><br><span class="line">    <span class="keyword">return</span> a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; i ++) a[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;</span><br><span class="line">        x --, y--;</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">get</span>(x, y);</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;D&#x27;</span>) d = <span class="built_in">get</span>(x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> d = <span class="built_in">get</span>(x,y+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="type">int</span> pd = <span class="built_in">find</span>(d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pb == pd) &#123;</span><br><span class="line">            res = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[pb] = pd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!res) cout&lt;&lt;<span class="string">&quot;draw&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="1252"><li>搭配购买</li></ol><p>Joe 觉得云朵很美，决定去山上的商店买一些云朵。</p><p>商店里有 n 朵云，云朵被编号为 1,2,…,n1,2,…,，并且每朵云都有一个价值。</p><p>但是商店老板跟他说，一些云朵要搭配来买才好，所以买一朵云则与这朵云有搭配的云都要买。</p><p>但是 Joe 的钱有限，所以他希望买的价值越多越好。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>第 11 行包含三个整数 n，m，w，表示有 n 朵云，m 个搭配，Joe 有 w 的钱。</p><p>第 2∼n+12∼+1 行，每行两个整数 ci，di 表示 i 朵云的价钱和价值。</p><p>第 n+2∼n+1+m +2∼ +1+  行，每行两个整数 ui，vi  ，  ，表示买 ui   就必须买 vi  ，同理，如果买 vi   就必须买 ui  。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>一行，表示可以获得的最大价值。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤n≤100001≤ ≤10000,<br>0≤m≤50000≤ ≤5000,<br>1≤w≤100001≤ ≤10000,<br>1≤ci≤50001≤  ≤5000,<br>1≤di≤1001≤  ≤100,<br>1≤ui,vi≤n1≤  ,  ≤</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 3 10</span><br><span class="line">3 10</span><br><span class="line">3 10</span><br><span class="line">3 10</span><br><span class="line">5 100</span><br><span class="line">10 1</span><br><span class="line">1 3</span><br><span class="line">3 2</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>这个题啊，思路也不难。</p><p>首先我们先读入数据，然后看看新加入的两朵云是否在一个并查集里面，如果在的话，暂且不管，如果不在的话，添加以下，价格价值也需要更新。</p><p>随后遍历所有的云，仅当 p [i]==i 时，选该云，化为一个 01 背包问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], p[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(x), pb = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb) &#123;</span><br><span class="line">            v[pb] += v[pa];</span><br><span class="line">            w[pb] += w[pa];</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = q; j &gt;= v[i]; j --) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[q]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day5</title>
      <link href="/2023/04/17/day5/"/>
      <url>/2023/04/17/day5/</url>
      
        <content type="html"><![CDATA[<h4 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p>这个题啊，对于一个节点，求出其左右孩子的贡献度，且仅当该贡献度大于 0 时，选该孩子，不然不参与贡献度计算，然后对于一个节点的贡献度，为其节点的值加上左右孩子节点的最大值，就行喽！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxgain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INT_MAX;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">maxgain</span>(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">maxgain</span>(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pp = r + l + root-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, pp);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l ,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxgain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="48-旋转图像"><a class="markdownIt-Anchor" href="#48-旋转图像">#</a> <a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h4><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>这个题啊，so easy</p><p>只需要对称一下，然后对角线翻转一下，直接拿捏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) <span class="built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day4</title>
      <link href="/2023/04/15/day4/"/>
      <url>/2023/04/15/day4/</url>
      
        <content type="html"><![CDATA[<h4 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换">#</a> <a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h4><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的</p><p>DP 法</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></msub><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mtext>其中</mtext><msub><mi>f</mi><mi>i</mi></msub><mtext>表示总金额为</mtext><mi>i</mi><mtext>时的最小硬币数</mtext><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mtext>为第</mtext><mi>i</mi><mtext>个硬币的金额数</mtext></mrow><annotation encoding="application/x-tex">f_{i} = f_{i-a[i]} + 1 \\其中f_{i}表示总金额为i时的最小硬币数,a_{i}为第i个硬币的金额数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">a</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span><span class="mord cjk_fallback">为</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">硬</span><span class="mord cjk_fallback">币</span><span class="mord cjk_fallback">数</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">硬</span><span class="mord cjk_fallback">币</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span><span class="mord cjk_fallback">数</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)coins.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合">#</a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>用 dfs 来做就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; board = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//表示按到了键盘上的第几个键</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board[num].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(board[num][i]);  </span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, digits);  <span class="comment">//递归下一层</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();      <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库连接实现</title>
      <link href="/2023/04/15/mysql-pool1/"/>
      <url>/2023/04/15/mysql-pool1/</url>
      
        <content type="html"><![CDATA[<h4 id="mysql数据库连接实现"><a class="markdownIt-Anchor" href="#mysql数据库连接实现">#</a> MySQL 数据库连接实现</h4><h4 id="connecth"><a class="markdownIt-Anchor" href="#connecth">#</a> connect.h</h4><p>实现连接，更新，查询，可以后续添加很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">connection</span>(<span class="comment">/* args */</span>);</span><br><span class="line">    ~<span class="built_in">connection</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(string ip,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">short</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                string user,</span></span></span><br><span class="line"><span class="params"><span class="function">                string hash_password,</span></span></span><br><span class="line"><span class="params"><span class="function">                string dbname</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line">    <span class="function">MYSQL_RES* <span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    MYSQL * _conn;<span class="comment">//表示MYSQL Server的一条连接</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>connect.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connect.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//g++ -o run  main.cpp connect.cpp -I /usr/include/mysql -lmysqlclient</span></span><br><span class="line">connection::<span class="built_in">connection</span>() &#123;</span><br><span class="line">    _conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection::~<span class="built_in">connection</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_conn) <span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::connect</span><span class="params">(string ip,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">short</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                string user,</span></span></span><br><span class="line"><span class="params"><span class="function">                string hash_password,</span></span></span><br><span class="line"><span class="params"><span class="function">                string dbname)</span> </span>&#123;</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, ip.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),</span><br><span class="line">    hash_password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::update</span><span class="params">(std::string sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">         <span class="built_in">LOG</span>(<span class="string">&quot;更新失败:&quot;</span> + sql);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_RES* <span class="title">connection::query</span><span class="params">(string sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">&quot;查询失败:&quot;</span> + sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_use_result</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池框架构建</title>
      <link href="/2023/04/15/mysql-pool/"/>
      <url>/2023/04/15/mysql-pool/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库连接池框架构建"><a class="markdownIt-Anchor" href="#数据库连接池框架构建">#</a> 数据库连接池框架构建</h3><p>技术点：</p><p>MySQL 数据库编程、单例模式、queue 队列容器、C++11 多线程、线程互斥、线程同步和 unique_lock、基于 CAS 的原子整形、智能指针 shared_ptr、lambda 表达式、生产者消费者线程模型</p><p>在高并发情况下，大量的 TCP 三次握手，MySQL Server 连接认证、关闭连接回收资源和 TCP 四次挥手耗费的性能时间很明显，增加连接词就是为了减少这一部分的性能损耗。</p><p><strong>实现功能：</strong></p><p><strong>初始连接量</strong></p><p><strong>最大连接量</strong></p><p><strong>最大空闲时间</strong></p><p><strong>连接超时时间</strong></p><p>主要实现上述四个功能</p><p><strong>设计思路：</strong></p><ul><li>连接池只需要一个实例，所以 ConnectionPool 以单例模式设计</li><li>从 ConnectionPool 中可以获得和 MySQL 连接的 Connection</li><li>空闲连接 Connection 全部维护在一个线程安全地 Connection 队列中，使用线程互斥锁保证队列的线程安全</li><li>如果 Connection 队列为空，需要再获取连接，此时动态创建连接，上限数量是 maxSize</li><li>队列中空闲连接时间超过 maxIdleTime 的就要被释放掉，只保留初始的 initSize 就可以了，这个功能交由独立的线程去做</li><li>如果 Connection 队列为空，而此时连接的数量已达上线 maxSize，那么等待 Connection TimeOut 时间如果还获取不到空闲的连接，那么获取连接失败，此处 Connection 队列获取空闲连接，可以使用带超时时间的 mutex 互斥锁来实现连接超时时间</li><li>用户获取的连接用 shared_ptr 智能指针来管理，用 lambda 表达式定制连接释放的功能</li><li>连接的生产和连接的消费采用生产者消费者线程模型设计，使用线程间的同步通信机制条件变量和互斥锁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库连接池实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据库连接池遇到的一些问题</title>
      <link href="/2023/04/15/problem1/"/>
      <url>/2023/04/15/problem1/</url>
      
        <content type="html"><![CDATA[<h3 id="关于数据库连接池遇到的一些问题"><a class="markdownIt-Anchor" href="#关于数据库连接池遇到的一些问题">#</a> 关于数据库连接池遇到的一些问题</h3><p>首先，要记得绑 mysql 的库。</p><p>g++ -o run  main.cpp connect.cpp -I /usr/include/mysql -lmysqlclient</p><p>否则会出现一些问题，仅仅能导入是不行的。</p><p>其次是关于 mysql 的指令学习。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">CREATE DATABASES;</span><br><span class="line">USE test_db;</span><br><span class="line">CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];</span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>因为不熟悉 mysql 搞了好多低级错误，哭晕。</p><h3 id="关于破bug"><a class="markdownIt-Anchor" href="#关于破bug">#</a> 关于破 bug</h3><h4 id="segmentation-fault-core-dumped"><a class="markdownIt-Anchor" href="#segmentation-fault-core-dumped">#</a> Segmentation fault (core dumped)</h4><p>在本问题在中是指针出问题了 qaq</p><p>排查了半天</p><p>通过查资料学到了 gdb 调试的一些方法来判断是什么问题</p><h4 id="然后就是不知道为什么运行之后一直阻塞"><a class="markdownIt-Anchor" href="#然后就是不知道为什么运行之后一直阻塞">#</a> 然后就是不知道为什么运行之后一直阻塞</h4><p>排查到这个地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();<span class="comment">//空了再通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这可不行！<br>居然把返回值放到函数里面了我的错我的错</p><p>排查半天，难受死！</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unix_fifo</title>
      <link href="/2023/04/14/unix-fifo/"/>
      <url>/2023/04/14/unix-fifo/</url>
      
        <content type="html"><![CDATA[<h3 id="管道和fifo"><a class="markdownIt-Anchor" href="#管道和fifo">#</a> 管道和 FIFO</h3><p><strong>从图 4-3 到 4-4。如果子进程没有执行 close (fd [1])，会发生什么？</strong></p><img src="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410194658129.png" class="lazyload placeholder" data-srcset="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410194658129.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410194658129" style="zoom:50%;" /><img src="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410195558952.png" class="lazyload placeholder" data-srcset="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410195558952.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410195558952" style="zoom:50%;" /><p>当父进程终止时，如果子进程中 fd [1] 处于打开状态，那么子进程对 fd [0] 的 read 不会返回文件结束符，因为 fd [1] 在子进程中仍然打开。在子进程中关闭 fd [1] 保证一旦父进程终止，它的所有描述符即关闭，从而使得子进程对 fd [0] 的 read 返回 0.</p><p><strong>如果要打开一个已有的 FIFO 或者创建一个新的 FIFO，应该调用 mkfifo，检查是否返回 EEXIST 错误，若是调用 open, 如果先调用 open，当不在所期望的 FIFO 时，再调用 mkfifo，会发生什么？</strong></p><p>如果调用关系反了，另外某个进程就有可能在本进程的 opne 和 makifo 之间创建本进程需要的 FIFO, 结果导致本进程的 FIFO 创建失败。</p><p><strong>调用 open 时，如果其中执行命令的 shell 碰到错误，那么会发生什么情况？</strong></p><img src="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410201230603.png" class="lazyload placeholder" data-srcset="C:\Users\15597\AppData\Roaming\Typora\typora-user-images\image-20230410201230603.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410201230603"  /><p><strong>针对服务器的 FIFO 的 open 去掉，验证一下这导致当不再有客户存在时，服务器即终止</strong></p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201315663.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201315663.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410201315663"></p><p><strong>在图 4-23 中，当服务器启动后，它阻塞在自己的第一个 open 调用中，知道客户的第一个 open 打开同一个 FIFO 用于写为止。我们应该怎么才能绕过这样的阻塞，使得两个 open 都立即返回，转而阻塞在首次调用 readline 上？</strong></p><p>将第一个 open 调用改位非阻塞</p><p><strong>如果图 4-24 中的客户程序对换其两个 open 调用的顺序，那么会发生什么情况？</strong></p><p>会发生死锁</p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201329799.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230410201329799.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230410201329799"></p><p><strong>为什么在读进程关闭管道或 FIFO 之后给写进程产生一个信号，而不会在写进程关闭管道或 FIFO 之后给读进程产生一个信号？</strong></p><p>写进程关闭管道或 FIFO 的信息通过文件结束符传递给读进程。</p><p><strong>编写一个程序，确定 fstat 是否以 stat 结构的 st_size 成员的形式返回当前在某个 FIFO 中的数据字节数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 编写一个程序，确定fstat是否以stat结构的st_size成员的形</span></span><br><span class="line"><span class="comment">// 式返回当前在某个FIFO中的数据字节数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> info;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* data */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> argv[] = <span class="string">&quot;sb&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mkfifo</span>(argv, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create fifo error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd[<span class="number">0</span>] = <span class="built_in">open</span>(argv, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    fd[<span class="number">1</span>] = <span class="built_in">open</span>(argv, O_WRONLY | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">0</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[0]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">1</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[1]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;buff, <span class="built_in">sizeof</span>(buff));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">0</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[0]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line">    <span class="built_in">fstat</span>(fd[<span class="number">1</span>], &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[1]: st_size = %ld\n&quot;</span>, (<span class="type">long</span>) info.st_size);</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 ulimit -a 查看得到</p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212714481.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212714481.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230414212714481"></p><p>代码运行得到</p><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212735466.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414212735466.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230414212735466"></p><p>因此并不是某个 FIFO 中的数据字节数</p><p>create fifo error 是因为之前以及创建过了。</p><p><strong>编写一个程序，以确定在为一个读出端已关闭的管道描述符选择可写条件时 select 返回的内容。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>], n;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    fd_set wset;</span><br><span class="line">    <span class="built_in">pipe</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> ( (childpid == fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child closing pipe read description \n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;wset);</span><br><span class="line">    <span class="built_in">FD_SET</span>(fd[<span class="number">1</span>], &amp;wset);</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">select</span>(fd[<span class="number">1</span>]+<span class="number">1</span>, <span class="literal">NULL</span>, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;select returned %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fd[<span class="number">1</span>], &amp;wset)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd[1] writable\n&quot;</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414214217555.png" class="lazyload placeholder" data-srcset="C:%5CUsers%5C15597%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230414214217555.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230414214217555"></p>]]></content>
      
      
      
        <tags>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day3</title>
      <link href="/2023/04/14/day3/"/>
      <url>/2023/04/14/day3/</url>
      
        <content type="html"><![CDATA[<h4 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历">#</a> <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点  <code>root</code>  ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p>没什么好说的，开干！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">middle_sort</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">middle_sort</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">middle_sort</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">middle_sort</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="114-二叉树展开为链表"><a class="markdownIt-Anchor" href="#114-二叉树展开为链表">#</a> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode* l = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (l) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l-&gt;right) l = l-&gt;right;</span><br><span class="line">            l-&gt;right = root-&gt;right;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个题啊，先将左子树拿到右边，再对右边递归即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qndxx</title>
      <link href="/2023/04/13/qndxx/"/>
      <url>/2023/04/13/qndxx/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> anti_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line">openId = <span class="string">&quot;&quot;</span></span><br><span class="line">current_path = os.getcwd()</span><br><span class="line">f = <span class="built_in">open</span>(current_path + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;log.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeHeader</span>(<span class="params">openid=openId</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/javascript, */*; q=0.01&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh-Hans;q=0.9&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;JSESSIONID=&#x27;</span> + secrets.token_urlsafe(<span class="number">40</span>),</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.jxqingtuan.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;http://www.jxqingtuan.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://www.jxqingtuan.cn/html/h5_index.html&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: UserAgent(platform=<span class="string">&quot;iphone&quot;</span>).wechat,</span><br><span class="line">        <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkConfig</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cardNo) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cardNo对应第五行数据，不可为空&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nid) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cardNo是团委组织ID，不可为空&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="comment"># info = json.dumps(getIDInfo())</span></span><br><span class="line">    res = getIDInfo()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) != <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;团委组织id异常，您似乎获取错了&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIDInfo</span>():</span><br><span class="line">    url = <span class="string">&quot;http://www.jxqingtuan.cn/pub/vol/config/organization?pid=&quot;</span> + nid</span><br><span class="line">    res = json.loads(requests.get(url, headers=makeHeader()).text)</span><br><span class="line">    <span class="keyword">if</span> res.get(<span class="string">&quot;status&quot;</span>) == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> res.get(<span class="string">&quot;result&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查询组织导致未知错误：&quot;</span> + res.text)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getCourse</span>():</span><br><span class="line">    url = <span class="string">&quot;http://www.jxqingtuan.cn/pub/vol/volClass/current&quot;</span></span><br><span class="line">    CourseJson = requests.get(url, headers=makeHeader()).json()</span><br><span class="line">    Course = CourseJson.get(<span class="string">&quot;result&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;课程id：&quot;</span> + Course.get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">        f.write(<span class="string">&quot;课程id：&quot;</span> + Course.get(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;课程名称：&quot;</span> + Course.get(<span class="string">&quot;title&quot;</span>))</span><br><span class="line">        f.write(<span class="string">&quot;课程名称：&quot;</span> + Course.get(<span class="string">&quot;title&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> Course.get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;查询课程致未知错误&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;查询课程致未知错误&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getStudy</span>(<span class="params">course, nid, subOrg, cardNo</span>):</span><br><span class="line">    url = <span class="string">&quot;http://www.jxqingtuan.cn/pub/vol/volClass/join?accessToken=&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subOrg) &gt; <span class="number">0</span>:</span><br><span class="line">        data = &#123;<span class="string">&quot;course&quot;</span>: course, <span class="string">&quot;subOrg&quot;</span>: subOrg, <span class="string">&quot;nid&quot;</span>: nid, <span class="string">&quot;cardNo&quot;</span>: cardNo&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = &#123;<span class="string">&quot;course&quot;</span>: course, <span class="string">&quot;subOrg&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;nid&quot;</span>: nid, <span class="string">&quot;cardNo&quot;</span>: cardNo&#125;</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    res = json.loads(</span><br><span class="line">        (requests.post(url=url, data=json.dumps(data, ensure_ascii=<span class="literal">False</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>), headers=makeHeader())).text)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="keyword">if</span> res.get(<span class="string">&quot;status&quot;</span>) == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(cardNo + <span class="string">&quot;大学习成功！&quot;</span>)</span><br><span class="line">        f.write(cardNo + <span class="string">&quot;大学习成功！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;提交大学习导致未知错误：&quot;</span> + res.text)</span><br><span class="line">        f.write(<span class="string">&quot;提交大学习导致未知错误：&quot;</span> + res.text)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">face = [<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    nid = <span class="string">&quot;N0013000110151019&quot;</span></span><br><span class="line">    subOrg = <span class="string">&quot;&quot;</span></span><br><span class="line">    cardNo = <span class="built_in">str</span>(face[i])</span><br><span class="line">    openId = <span class="string">&quot;&quot;</span></span><br><span class="line">    checkConfig()</span><br><span class="line">    getStudy(getCourse(), nid, subOrg, cardNo)   </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>python 实现的完成青年大学习的脚本喽</p>]]></content>
      
      
      
        <tags>
            
            <tag> 青年大学习打卡py </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NCU校园网自动登录</title>
      <link href="/2023/04/13/ncuxyw/"/>
      <url>/2023/04/13/ncuxyw/</url>
      
        <content type="html"><![CDATA[<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> username,password,IE</span><br><span class="line">username = <span class="string">&quot;&quot;</span> <span class="keyword">REM</span>此处引号填入学号</span><br><span class="line">password = <span class="string">&quot;&quot;</span>  <span class="keyword">REM</span>此处引号填入密码</span><br><span class="line"><span class="keyword">Set</span> IE =<span class="built_in">CreateObject</span>(<span class="string">&quot;InternetExplorer.Application&quot;</span>)</span><br><span class="line">ie.FullScreen=<span class="number">0</span></span><br><span class="line">IE.Visible = <span class="literal">True</span></span><br><span class="line">IE.Navigate <span class="string">&quot;http://222.204.3.154/srun_portal_pc?ac_id=5&amp;srun_wait=1&amp;theme=basic1&quot;</span>  </span><br><span class="line"><span class="keyword">Do</span> <span class="keyword">while</span> IE.ReadyState&lt;&gt; <span class="number">4</span> <span class="keyword">or</span> IE.busy</span><br><span class="line">wscript.sleep <span class="number">2000</span> </span><br><span class="line"><span class="keyword">loop</span></span><br><span class="line">IE.document.querySelector(<span class="string">&quot;#username&quot;</span>).value=username  </span><br><span class="line">IE.document.querySelector(<span class="string">&quot;#password&quot;</span>).value=password</span><br><span class="line">ie.document.getElementsByName(<span class="string">&quot;domain&quot;</span>)(<span class="number">0</span>).children(<span class="number">1</span>).selected=trueREM     children <span class="keyword">REM</span>括号里的数字移动<span class="number">1</span>电信<span class="number">3</span>联通<span class="number">4</span></span><br><span class="line"><span class="keyword">Set</span> btn =ie.Document.getElementById(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">btn.click <span class="keyword">REM</span>将将文件后缀名改为.vbs点击即可运行</span><br></pre></td></tr></table></figure><p>用简单 vbs 脚本实现南昌大学校园网自动登录，设置开机自启动后就行了，放桌面上点一下也是没问题的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NCU校园网自动登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day2</title>
      <link href="/2023/04/13/day2/"/>
      <url>/2023/04/13/day2/</url>
      
        <content type="html"><![CDATA[<h4 id="day2"><a class="markdownIt-Anchor" href="#day2">#</a> day2</h4><h4 id="236-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#236-二叉树的最近公共祖先">#</a> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> l = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="type">bool</span> r = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((l &amp;&amp; r) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (l || r))) res = root;</span><br><span class="line">        <span class="keyword">return</span> l || r || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs 喽，把握住什么是最近公共祖先就行了！</p><p>今天有点忏愧，有点摆了。</p><p>早上寝室断电，大雨也不好充，晚上又看了好久小说，今天就这样吧，刷一道题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试中的小bug</title>
      <link href="/2023/04/13/problem/"/>
      <url>/2023/04/13/problem/</url>
      
        <content type="html"><![CDATA[<h4 id="在自定义widget的时候出现如下错误field-w-has-incomplete-type"><a class="markdownIt-Anchor" href="#在自定义widget的时候出现如下错误field-w-has-incomplete-type">#</a> 在自定义 Widget 的时候出现如下错误 field w has incomplete type</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Widget w;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wwrite</span><span class="params">(QString s, QWidget *widget)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">savestabuyEditinfo</span><span class="params">(QLineEdit *lineEditPass, QString tex)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是因为头文件对类或者结构体进行了前向声明，后面使用了该类定义了对象，导致编译报错。</p><p>原因在于前向声明类或者结构体，此时编译器还不知道定义，无法知道类内部成员，所以无法构造实例对象，因此前向声明的类或者结构体只能用来定义指针或者引用。</p><h4 id="cannot-call-member-function-without-object-处理"><a class="markdownIt-Anchor" href="#cannot-call-member-function-without-object-处理">#</a> cannot call member function ‘ ‘ without object 处理</h4><p>应该先初始化一个类哦这个</p><p><strong>莫名其妙的注释掉的函数也会出现提示我未初始化，这个时候需要将整个项目重构</strong></p><h4 id="no-such-slot-widgetsavestabuyeditinfolineedit-text-in"><a class="markdownIt-Anchor" href="#no-such-slot-widgetsavestabuyeditinfolineedit-text-in">#</a> No such slot Widget::savestabuyEditinfo(lineEdit, text) in</h4><p>奇怪，明明以及在 Widget 里 public slots 声明了，却仍然有问题</p><h4 id="qiodevicewrite-qfile-dqtprojectaguaguimage"><a class="markdownIt-Anchor" href="#qiodevicewrite-qfile-dqtprojectaguaguimage">#</a> QIODevice::write (QFile, &quot;D:qtprojectaguaguimage</h4><h4 id="es-device-not-open"><a class="markdownIt-Anchor" href="#es-device-not-open">#</a> es&quot;): device not open</h4><p>服了，qt 读取 txt 并不用和 image 一样，还得加到工程看里</p><p>信号槽的问题，一直检测不到</p><p>文件读写的问题，一直写不上</p><p>吐了吐了</p>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题day1</title>
      <link href="/2023/04/12/lc/"/>
      <url>/2023/04/12/lc/</url>
      
        <content type="html"><![CDATA[<h4 id="238-除自身以外数组的乘积"><a class="markdownIt-Anchor" href="#238-除自身以外数组的乘积">#</a> <a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer [i] 等于 nums 中除 nums [i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums 之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O (n) 时间复杂度内完成此题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p>遍历两边</p><p>用 l 记录该点左侧所有数的成绩，</p><p>随后倒过来再算右边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        l[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            l[i] = l[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            l[i] = l[i] * r;</span><br><span class="line">            r *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量">#</a> <a href="https://leetcode.cn/problems/task-scheduler/">[200. 岛屿数量]</a></h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和 / 或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(x == grid.size() &amp;&amp; y == grid[0].size()) return ;</span></span><br><span class="line">        grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x<span class="number">-1</span>][y] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(y<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span> &lt; grid.<span class="built_in">size</span>() &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(y+<span class="number">1</span> &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x, y+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对岛屿问题，深搜即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dayi</title>
      <link href="/2023/04/12/dayi/"/>
      <url>/2023/04/12/dayi/</url>
      
        <content type="html"><![CDATA[<h2 id="day1"><a class="markdownIt-Anchor" href="#day1">#</a> day1</h2><p>今天实现如下功能：</p><ul><li><p>mainwindow 添加菜单栏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar *bar = <span class="built_in">menuBar</span>();<span class="comment">//创建菜单栏</span></span><br><span class="line"><span class="comment">//中间各种操作</span></span><br><span class="line"><span class="built_in">setMenuBar</span>(bar);</span><br></pre></td></tr></table></figure></li><li><p>点击相应菜单栏中的每个按钮可以跳转到另外一个页面</p><p>使用 connect</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处需要在类中如下</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openNewWindow</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//实现如下</span></span><br><span class="line">QAction *action1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;八股&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">bar-&gt;<span class="built_in">addAction</span>(action1);</span><br><span class="line"><span class="built_in">connect</span>(action1, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">openNewWindow</span>()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openNewWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QWidget *newWindow = <span class="keyword">new</span> QWidget;</span><br><span class="line">    newWindow-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;New Window&quot;</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">bkgnd</span><span class="params">(<span class="string">&quot;:/new/prefix1/10.png&quot;</span>)</span></span>;</span><br><span class="line">    bkgnd = bkgnd.<span class="built_in">scaled</span>(<span class="keyword">this</span>-&gt;<span class="built_in">size</span>(), Qt::IgnoreAspectRatio);</span><br><span class="line">    QPalette palette;</span><br><span class="line">    palette.<span class="built_in">setBrush</span>(QPalette::Background, bkgnd);</span><br><span class="line">    newWindow-&gt;<span class="built_in">setPalette</span>(palette);</span><br><span class="line">    newWindow-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>背景图</p><p>此处需要首先在工程中添加 resource 文件，再向其中添加图片，否则就算路径正确也会读取不出来图片</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">bkgnd</span><span class="params">(<span class="string">&quot;:/new/prefix1/6.png&quot;</span>)</span></span>;</span><br><span class="line">bkgnd = bkgnd.<span class="built_in">scaled</span>(<span class="keyword">this</span>-&gt;<span class="built_in">size</span>(), Qt::IgnoreAspectRatio);</span><br><span class="line">QPalette palette;</span><br><span class="line">palette.<span class="built_in">setBrush</span>(QPalette::Background, bkgnd);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(palette);</span><br></pre></td></tr></table></figure></li></ul><p>明日计划：</p><p>实现打开的页面中能够读取 txt，写入 txt, 以及答案匹配，实现基础问答形式。</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 秋招学习器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/11/hello-world/"/>
      <url>/2023/04/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start">#</a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post">#</a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server">#</a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files">#</a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
