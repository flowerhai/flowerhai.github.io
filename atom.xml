<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚迷离</title>
  
  
  <link href="https://flowerhai.github.io/atom.xml" rel="self"/>
  
  <link href="https://flowerhai.github.io/"/>
  <updated>2023-05-09T12:45:50.162Z</updated>
  <id>https://flowerhai.github.io/</id>
  
  <author>
    <name>恍惚迷离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刷题记录-第23天</title>
    <link href="https://flowerhai.github.io/2023/05/09/day23/"/>
    <id>https://flowerhai.github.io/2023/05/09/day23/</id>
    <published>2023-05-09T12:45:13.000Z</published>
    <updated>2023-05-09T12:45:50.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="池塘计数"><a class="markdownIt-Anchor" href="#池塘计数">#</a> 池塘计数</h3><p>农夫约翰有一片 N∗M ∗  的矩形土地。</p><p>最近，由于降雨的原因，部分土地被水淹没了。</p><p>现在用一个字符矩阵来表示他的土地。</p><p>每个单元格内，如果包含雨水，则用”W” 表示，如果不含雨水，则用”.” 表示。</p><p>现在，约翰想知道他的土地中形成了多少片池塘。</p><p>每组相连的积水单元格集合可以看作是一片池塘。</p><p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p><p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W” 块。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含两个整数 N  和 M 。</p><p>接下来 N  行，每行包含 M  个字符，字符为”W” 或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出一个整数，表示池塘数目。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤N,M≤10001≤ , ≤1000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>经典连通块问题喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    f[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//上、下、左、右、左上、右上、左下、右下</span></span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; f[x+<span class="number">1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (y+<span class="number">1</span>&lt;m &amp;&amp; f[x][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x<span class="number">-1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x+<span class="number">1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="type">char</span> a;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;W&#x27;</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;.&#x27;</span>) f[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热浪"><a class="markdownIt-Anchor" href="#热浪">#</a> 热浪</h3><p>德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！</p><p>他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。</p><p>农夫 John 此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p><p>John 已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。</p><p>这些路线包括起始点和终点一共有 T  个城镇，为了方便标号为 11 到 T 。</p><p>除了起点和终点外的每个城镇都由 <strong>双向道路</strong> 连向至少两个其它的城镇。</p><p>每条道路有一个通过费用（包括油费，过路费等等）。</p><p>给定一个地图，包含 C  条直接连接 22 个城镇的道路。</p><p>每条道路由道路的起点 Rs  ，终点 Re   和花费 Ci   组成。</p><p>求从起始的城镇 Ts   到终点的城镇 Te   最小的总费用。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>第一行: 44 个由空格隔开的整数: T,C,Ts,Te , ,  ,  ;</p><p>第 22 到第 C+1 +1 行：第 i+1 +1 行描述第 i  条道路，包含 33 个由空格隔开的整数: Rs,Re,Ci  ,  ,  。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>一个单独的整数表示从 Ts   到 Te   的最小总费用。</p><p>数据保证至少存在一条道路。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤T≤25001≤ ≤2500,<br>1≤C≤62001≤ ≤6200,<br>1≤Ts,Te,Rs,Re≤T1≤  ,  ,  ,  ≤ ,<br>1≤Ci≤10001≤  ≤1000</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><p>dijkstra 算法板子题算是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,c, nbeg, nend;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[nbeg] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c&gt;&gt;nbeg&gt;&gt;nend;</span><br><span class="line">    <span class="keyword">while</span> (c --) &#123;</span><br><span class="line">        <span class="type">int</span> k, p, l;</span><br><span class="line">        cin&gt;&gt;k&gt;&gt;p&gt;&gt;l;</span><br><span class="line">        g[k][p] = g[p][k] = <span class="built_in">min</span>(g[k][p], l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout&lt;&lt;dist[nend];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dijkstra 的整体思路比较清晰<br>即进行 n（n 为 n 的个数）次迭代去确定每个点到起点的最小值 最后输出的终点的即为我们要找的最短路的距离</p><p>所以按照这个思路除了存储图外我们还需要存储两个量</p><p>dist [n] // 用于存储每个点到起点的最短距离<br> st [n]   // 用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新</p><p>每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点<br>（至于为什么是这样那么这就涉及到 Dijkstra 算法的具体数学证明了 有兴趣的同学可以百度一下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t=<span class="number">-1</span>;       <span class="comment">//将t设置为-1 因为Dijkstra算法适用于不存在负权边的图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j])    <span class="comment">//该步骤即寻找还未确定最短路的点中路径最短的点</span></span><br><span class="line">        t=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述操作当前我们的 t 代表就是剩余未确定最短路的点中 路径最短的点<br>而与此同时该点的最短路径也已经确定我们将该点标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st[t]=true;</span><br></pre></td></tr></table></figure><p>然后用这个去更新其余未确定点的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离</span></span><br><span class="line"><span class="comment">//但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响</span></span><br><span class="line"><span class="comment">//当然你也可以在循环判断条件里加上if(!st[i])</span></span><br><span class="line"><span class="comment">//这里j从1开始只是为了代码的简洁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行 n 次迭代后最后就可以确定每个点的最短距离</p><h4 id="面试题-0101-判定字符是否唯一"><a class="markdownIt-Anchor" href="#面试题-0101-判定字符是否唯一">#</a> <a href="https://leetcode.cn/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一</a></h4><p>实现一个算法，确定一个字符串  <code>s</code>  的所有字符是否全都不同。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;</span><br><span class="line">输出: false </span><br></pre></td></tr></table></figure><p>题目说了全是小写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; astr.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[astr[i]-<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            a[astr[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍">#</a> <a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>典</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">max</span>(f[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(f[<span class="number">0</span>], f[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], <span class="built_in">max</span>(nums[i]+f[i<span class="number">-2</span>],f[i<span class="number">-1</span>]));</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="面试题-0202-返回倒数第-k-个节点"><a class="markdownIt-Anchor" href="#面试题-0202-返回倒数第-k-个节点">#</a> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></h4><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p>** 注意：** 本题相对原题稍作改动</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p>双指针喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">while</span> (h!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast ++;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;池塘计数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#池塘计数&quot;&gt;#&lt;/a&gt; 池塘计数&lt;/h3&gt;
&lt;p&gt;农夫约翰有一片 N∗M ∗  的矩形土地。&lt;/p&gt;
&lt;p&gt;最近，由于降雨的原因，部分土地被水淹没了。&lt;/p&gt;
&lt;p&gt;现在用一个字符</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day22</title>
    <link href="https://flowerhai.github.io/2023/05/08/shuati/day22/"/>
    <id>https://flowerhai.github.io/2023/05/08/shuati/day22/</id>
    <published>2023-05-08T13:32:35.000Z</published>
    <updated>2023-05-08T13:33:05.491Z</updated>
    
    <content type="html"><![CDATA[<h4 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站">#</a> <a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h4><p>在一条环路上有  <code>n</code>  个加油站，其中第  <code>i</code>  个加油站有汽油  <code>gas[i]</code>  升。</p><p>你有一辆油箱容量无限的的汽车，从第  <code>i</code>  个加油站开往第  <code>i+1</code>  个加油站需要消耗汽油  <code>cost[i]</code>  升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组  <code>gas</code>  和  <code>cost</code>  ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回  <code>-1</code>  。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p>贪心即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">                start = i + <span class="number">1</span>;  </span><br><span class="line">                curSum = <span class="number">0</span>;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="135-分发糖果"><a class="markdownIt-Anchor" href="#135-分发糖果">#</a> <a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h4><p><code>n</code>  个孩子站成一排。给你一个整数数组  <code>ratings</code>  表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到  <code>1</code>  个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure><p>从左向右，从右向左，各来一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="860-柠檬水找零"><a class="markdownIt-Anchor" href="#860-柠檬水找零">#</a> <a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h4><p>在柠檬水摊上，每一杯柠檬水的售价为  <code>5</code>  美元。顾客排队购买你的产品，（按账单  <code>bills</code>  支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付  <code>5</code>  美元、 <code>10</code>  美元或  <code>20</code>  美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付  <code>5</code>  美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组  <code>bills</code>  ，其中  <code>bills[i]</code>  是第  <code>i</code>  位顾客付的账。如果你能给每位顾客正确找零，返回  <code>true</code>  ，否则返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bill : bills) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="comment">// 情况二</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况三</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着</span></span><br><span class="line">                <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                    twenty++; <span class="comment">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                    twenty++; <span class="comment">// 同理，这行代码也可以删了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="406-根据身高重建队列"><a class="markdownIt-Anchor" href="#406-根据身高重建队列">#</a> <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><p>假设有打乱顺序的一群人站成一个队列，数组  <code>people</code>  表示队列中一些人的属性（不一定按顺序）。每个  <code>people[i] = [hi, ki]</code>  表示第  <code>i</code>  个人的身高为  <code>hi</code>  ，前面 <strong>正好</strong> 有  <code>ki</code>  个身高大于或等于  <code>hi</code>  的人。</p><p>请你重新构造并返回输入数组  <code>people</code>  所表示的队列。返回的队列应该格式化为数组  <code>queue</code>  ，其中  <code>queue[j] = [hj, kj]</code>  是队列中第  <code>j</code>  个人的属性（ <code>queue[0]</code>  是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 身高从大到小排（身高相同k小的站前面）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span> (people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que; <span class="comment">// list底层是链表实现，插入效率比vector高的多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>]; <span class="comment">// 插入到下标为position的位置</span></span><br><span class="line">            std::list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (position--) &#123; <span class="comment">// 寻找在插入位置</span></span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(it, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>感觉有时候贪心和动态规划有时候好像。</p><p>很想用动态规划上去结题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;134-加油站&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#134-加油站&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/gas-station/&quot;&gt;134. 加油站&lt;/a&gt;&lt;/h4&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>Lab 2:the TCP receiver</title>
    <link href="https://flowerhai.github.io/2023/05/08/cs144/cs144lab2/"/>
    <id>https://flowerhai.github.io/2023/05/08/cs144/cs144lab2/</id>
    <published>2023-05-08T12:54:52.000Z</published>
    <updated>2023-05-10T02:45:59.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#lab-2-the-tcp-receiver">#</a> Lab 2: the TCP receiver</h1><p>在 Lab2，我们将实现一个 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p>TCPReceiver 除了将读入的数据写入至 ByteStream 中以外，它还需要<strong>告诉发送者两个属性</strong>：</p><ul><li>第一个未组装的字节索引，称为<strong>确认号 ackno</strong>，它是接收者需要的第一个字节的索引。</li><li><strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的距离，称为 <strong>窗口长度 window size</strong>。</li></ul><p>ackno 和 window size 共同描述了接收者当前的<strong>接收窗口</strong>。接收窗口是 发送者允许发送数据的一个范围，通常 TCP 接收方使用接收窗口来进行<strong>流量控制</strong>，限制发送方发送数据。</p><p>总的来说，我们将要实现的 TCPReceiver 需要做以下几件事情：</p><ul><li>接收 TCP segment</li><li>重新组装字节流（包括 EOF）</li><li>确定应该发回给发送者的信号，以进行数据确认和流量控制</li></ul><h2 id="索引转换"><a class="markdownIt-Anchor" href="#索引转换">#</a> 索引转换</h2><p>TCP 报文中用来描述 ** 当前数据首字节的索引（序列号 seqno）** 是 32 位类型的，这意味着在处理上增加了一些需要考虑的东西：</p><p>在传输的 TCP 报文头部中，由于空间限制，字节序列号只能用 32 位的索引来表示。但是 32 位可能无法完全一一对应一串字节流，所以需要我们在接收端人为将索引转换为 64 位以保证不会溢出。</p><ul><li><p>由于 32 位类型最大能表达的值是 4GB，存在上溢的可能。因此当 32 位的 seqno 上溢后，下一个字节的 seqno 就重新从 0 开始。</p></li><li><p>处于安全性考虑，以及避免与之前的 TCP 报文混淆，TCP 需要让每个 seqno 都不可被猜测到，并且降低重复的可能性。因此 TCP seqno 不会从 0 开始，而是从一个 32 位随机数起步（称为<strong>初始序列号 ISN</strong>）。</p><p>而 ISN 是表示 SYN 包（用以表示 TCP 流的开始）的序列号。</p></li><li><p>TCP 流的<strong>逻辑开始数据包</strong>和<strong>逻辑结束数据包</strong>各占用一个 seqno。除了确保<strong>接收到所有字节的数据</strong>以外，TCP 还需要确保接收到<strong>流的开头和结尾</strong>。 因此，在 TCP 中，SYN（流开始）和 FIN（流结束）控制标志将会被分别分配一个序列号（SYN 标志占用的序列号就是 ISN）。</p><p>流中的每个数据字节也占用一个序列号。</p><p>但需要注意的是，SYN 和 FIN 不是流本身的一部分，也不是传输的字节数据。它们只是代表字节流本身的开始和结束。</p></li></ul><p>字节索引类型一多就容易乱。当前总共有三种索引：</p><ul><li>序列号 seqno。<strong>从 ISN 起步</strong>，包含 SYN 和 FIN，<strong>32 位循环</strong>计数</li><li>绝对序列号 absolute seqno。<strong>从 0 起步</strong>，包含 SYN 和 FIN，<strong>64 位非循环</strong>计数</li><li>流索引 stream index。<strong>从 0 起步</strong>，<strong>排除 SYN 和 FIN</strong>，<strong>64 位非循环</strong>计数。</li></ul><p>这是一个简单浅显的例子，用于区分开三种索引的区别：</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" class="lazyload placeholder" data-srcset="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211107105751818"></p><p>序列号和<strong>绝对</strong>序列号之间相互转换稍微有点麻烦，因为序列号是<strong>循环计数</strong>的。在该实验中，CS144 使用自定义类型 WrappingInt32 表示序列号，并编写了它与绝对序列号之间的转换。</p><p>这个实现稍微有点麻烦，而且实现的时候也最好避免各类循环，减少使用条件判断的次数，以提高执行效率。</p><h4 id="wrap"><a class="markdownIt-Anchor" href="#wrap">#</a> wrap</h4><p>该函数时将 64 位转化为 64 位，还是比较容易</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn); </span></span><br><span class="line">    <span class="comment">// return WrappingInt32&#123;0&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(isn.<span class="built_in">raw_value</span>() + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="unwrap"><a class="markdownIt-Anchor" href="#unwrap">#</a> unwrap</h4><p>该函数将 32 位转化为 64 位，需要动点脑子</p><p>因为 64 位变成 32 位肯定会有些数字代表的并不是一个，可能是多个 64 位的数据，所以这个时候就需要 checkpoint 来告诉我们是哪个</p><p>离得近就是！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn, checkpoint);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">uint64_t</span> offset = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n.<span class="built_in">raw_value</span>()-isn.<span class="built_in">raw_value</span>());</span><br><span class="line">    <span class="type">uint64_t</span> mod = checkpoint&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> ii  = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add = ii&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add_1 = offset + add*mod;</span><br><span class="line">    <span class="type">uint64_t</span> add_2 = offset + add*(mod+<span class="number">1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> add_3 = offset + add*(mod<span class="number">-1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> r_1 = add_1 &gt; checkpoint ? add_1 - checkpoint : checkpoint - add_1;</span><br><span class="line">    <span class="type">uint64_t</span> r_2 = add_2 &gt; checkpoint ? add_2 - checkpoint : checkpoint - add_2;</span><br><span class="line">    <span class="type">uint64_t</span> r_3 = add_3 &gt; checkpoint ? add_3 - checkpoint : checkpoint - add_3;</span><br><span class="line">    r_3 ++;</span><br><span class="line">    r_3 --;</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="number">0</span>) r_3 = INT64_MAX;</span><br><span class="line">    <span class="type">uint64_t</span> min_off = <span class="built_in">min</span>(<span class="built_in">min</span>(r_1, r_2), r_3);</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_1) <span class="keyword">return</span> add_1;</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_2) <span class="keyword">return</span> add_2;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> add_3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 1: t_wrapping_ints_cmp</span><br><span class="line">1/3 Test #1: t_wrapping_ints_cmp ..............   Passed    0.01 sec</span><br><span class="line">    Start 2: t_wrapping_ints_unwrap</span><br><span class="line">2/3 Test #2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span><br><span class="line">    Start 3: t_wrapping_ints_wrap</span><br><span class="line">3/3 Test #3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 3</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.02 sec</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-2-the-tcp-receiver&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-2-the-tcp-receiver&quot;&gt;#&lt;/a&gt; Lab 2: the TCP receiver&lt;/h1&gt;
&lt;p&gt;在 Lab2，我们将</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144- 太可恶了!</title>
    <link href="https://flowerhai.github.io/2023/05/08/cs144/css144/"/>
    <id>https://flowerhai.github.io/2023/05/08/cs144/css144/</id>
    <published>2023-05-08T04:08:07.000Z</published>
    <updated>2023-05-09T08:54:04.643Z</updated>
    
    <content type="html"><![CDATA[<p>强烈声讨</p><p>CS144lab2cmake文件</p><p>库文件写错了，一直只会给出not found</p><p>搞得我还以为自己没安装成功</p><p>头痛一上午</p><p>寻找了各种方法</p><p>mmp</p><p>最后忍不了了直接查看cmake文件</p><p>好啊</p><p>原来是你在那个地方一直给了一个not found</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;强烈声讨&lt;/p&gt;
&lt;p&gt;CS144lab2cmake文件&lt;/p&gt;
&lt;p&gt;库文件写错了，一直只会给出not found&lt;/p&gt;
&lt;p&gt;搞得我还以为自己没安装成功&lt;/p&gt;
&lt;p&gt;头痛一上午&lt;/p&gt;
&lt;p&gt;寻找了各种方法&lt;/p&gt;
&lt;p&gt;mmp&lt;/p&gt;
&lt;p&gt;最后忍不了了直接查看c</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>new-malloc-free-delete</title>
    <link href="https://flowerhai.github.io/2023/05/07/c-basic/new-malloc/"/>
    <id>https://flowerhai.github.io/2023/05/07/c-basic/new-malloc/</id>
    <published>2023-05-07T13:44:07.000Z</published>
    <updated>2023-05-07T13:44:55.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-delete"><a class="markdownIt-Anchor" href="#new-delete">#</a> new delete</h3><h3 id="new-和malloc的区别"><a class="markdownIt-Anchor" href="#new-和malloc的区别">#</a> new 和 malloc 的区别</h3><p>new 不仅可以开辟内存还可以初始化</p><p>malloc 开辟内存失败，是通过返回值和 nullptr 做比较的；而 new 开辟内存失败，是通过抛出 bad_alloc 类型的异常来判断的。</p><h3 id="delete和free的区别"><a class="markdownIt-Anchor" href="#delete和free的区别">#</a> delete 和 free 的区别</h3><p>malloc 和 free，C 的库函数</p><p>new 和 delete 运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">*p =<span class="number">20</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure><p>关于 delete 数组的时候</p><p>需要 delete [] p</p><p>如果不加的话只删第一个 (<strong>why?</strong>)</p><p>数组是一片连续的内存，释放时候你传递的数组名，也仅是一个指针，。<br>C++ 规定，delete p 时，仅删除指针指向的第一块内存。<br>delete [] p 才能把指针指向的一片连续内存都删除，因为在底层有一个变量，保存着需要删除的对象的数目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-delete&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#new-delete&quot;&gt;#&lt;/a&gt; new delete&lt;/h3&gt;
&lt;h3 id=&quot;new-和malloc的区别&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    
    <category term="C++基础" scheme="https://flowerhai.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>刷题day21</title>
    <link href="https://flowerhai.github.io/2023/05/07/shuati/day21/"/>
    <id>https://flowerhai.github.io/2023/05/07/shuati/day21/</id>
    <published>2023-05-07T12:59:45.000Z</published>
    <updated>2023-05-07T13:00:11.024Z</updated>
    
    <content type="html"><![CDATA[<p>今天是贪心专题 KMP 暂且缓缓 调试 lab1 花了太久太久</p><h3 id="贪心本质局部最优推出全局最优"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优">#</a> 贪心本质：局部最优推出全局最优。</h3><h4 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干">#</a> <a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子  <code>i</code> ，都有一个胃口值  <code>g[i]</code> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干  <code>j</code> ，都有一个尺寸  <code>s[j]</code>  。如果  <code>s[j] &gt;= g[i]</code> ，我们可以将这个饼干  <code>j</code>  分配给孩子  <code>i</code>  ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gl = <span class="number">0</span>, sl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (gl &lt; g.<span class="built_in">size</span>() &amp;&amp; sl &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sl] &gt;= g[gl]) &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">                gl ++;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="376-摆动序列"><a class="markdownIt-Anchor" href="#376-摆动序列">#</a> <a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 ** 摆动序列 。** 第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如，  <code>[1, 7, 4, 9, 2, 5]</code>  是一个 <strong>摆动序列</strong> ，因为差值  <code>(6, -3, 5, -7, 3)</code>  是正负交替出现的。</li><li>相反， <code>[1, 4, 7, 2, 5]</code>  和  <code>[1, 7, 4, 5, 5]</code>  不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组  <code>nums</code>  ，返回  <code>nums</code>  中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p>这题可以用 DP，当然今天是贪心专题，贪心做法就是去掉连续上升值中然后制造峰值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201126%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E5%91%A8">https://www.programmercarl.com/ 周总结 / 20201126 贪心周末总结.html# 周</a></p><h3 id="贪心本质局部最优推出全局最优-2"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优-2">#</a> 贪心本质：局部最优推出全局最优。</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是贪心专题 KMP 暂且缓缓 调试 lab1 花了太久太久&lt;/p&gt;
&lt;h3 id=&quot;贪心本质局部最优推出全局最优&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#贪心本质局部最优推出全局最优&quot;&gt;#&lt;/a&gt; 贪心本质：局部最优推出全局最优。&lt;/h</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>CS144Lab 1:stitching substrings into a byte stream</title>
    <link href="https://flowerhai.github.io/2023/05/07/cs144/cs144lab1/"/>
    <id>https://flowerhai.github.io/2023/05/07/cs144/cs144lab1/</id>
    <published>2023-05-07T12:17:15.000Z</published>
    <updated>2023-05-07T12:18:06.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#lab-1-stitching-substrings-into-a-byte-stream">#</a> Lab 1: stitching substrings into a byte stream</h1><h4 id="putting-substrings-in-sequence"><a class="markdownIt-Anchor" href="#putting-substrings-in-sequence">#</a> Putting substrings in sequence</h4><p>刚开始似乎思路出现了一些小小的偏差</p><p>想着用 unordered_map&lt;int,char&gt; 去直接把所有的信息都存进去。</p><p>实践发现，不太合适。</p><p>一直都是只能过 66.7%.</p><p>因为如果用 unordered_map 的话，其实不是很好把握住区间关系，虽然刚开始我是像借用数字寻找 char，然后就算是重复区间利用哈希表的特性完成问题，但是老是有意想不到的意外发生。</p><p>其实时间复杂度也不会低。</p><p>而且前后顺序出现问题是不能很好的解决的。</p><p>所以最后还是看了下别人写的，使用了两个 deque 来存，其实不用 deque 也可以的，这样也好吧，vector 也行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">char</span>&gt; buffer ;</span><br><span class="line">   std::deque&lt;<span class="type">bool</span>&gt; bufer_state ;</span><br><span class="line">   <span class="type">size_t</span> _unassembled_bytes = <span class="number">0</span>;<span class="comment">//已到地方索引</span></span><br><span class="line">   <span class="type">size_t</span> eof_index = <span class="number">0</span>;<span class="comment">//结束索引</span></span><br><span class="line">   <span class="type">bool</span> eof_ = <span class="literal">false</span>;</span><br><span class="line">   ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">   <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就是具体的实现了</p><p>因为数据发送方可能是乱序发送的数据，所以这里需要注意下前后顺序啊，然后对区间进行截取。</p><p>相当于实现了 tcp 协议中的对数据流进行排序</p><p>气死我了 调试了一天不知道问题所在，忘记初始化</p><p>以及如果实在函数外初始化切记要按照定义先后顺序初始化，否则大坑</p><p>然后像这种取交集啊，一般都是左取大，右取小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DUMMY_CODE(data, index, eof);</span></span><br><span class="line">    <span class="type">size_t</span> first_unassembled_bytes = _output.<span class="built_in">bytes_written</span>();</span><br><span class="line">    <span class="type">size_t</span> first_unaccept = first_unassembled_bytes + _capacity;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= first_unaccept || index+data.<span class="built_in">size</span>() &lt; first_unassembled_bytes) <span class="keyword">return</span> ;<span class="comment">//两端之外，去掉</span></span><br><span class="line">    <span class="comment">//左取大，右取小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> first_begin = <span class="built_in">max</span>(first_unassembled_bytes, index);</span><br><span class="line">    <span class="type">size_t</span> first_end = <span class="built_in">min</span>(first_unaccept, index+data.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向buffer里写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = first_begin; i &lt; first_end; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !bufer_state[i-first_unassembled_bytes]) &#123;</span><br><span class="line">            buffer[i-first_unassembled_bytes] = data[i-index];</span><br><span class="line">            _unassembled_bytes++;</span><br><span class="line">            bufer_state[i-first_unassembled_bytes] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (bufer_state.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        res += buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">        bufer_state.<span class="built_in">pop_front</span>();</span><br><span class="line">        buffer.<span class="built_in">emplace_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">        bufer_state.<span class="built_in">emplace_back</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stream_out</span>().<span class="built_in">write</span>(res);</span><br><span class="line">        _unassembled_bytes -= res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        eof_ = <span class="literal">true</span>;</span><br><span class="line">        eof_index = first_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eof_ &amp;&amp; _output.<span class="built_in">bytes_written</span>() == eof_index) _output.<span class="built_in">end_input</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调了一天，终于过了，再多调一下就会爆炸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Testing the stream reassembler...</span></span><br><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">      Start 15: t_strm_reassem_single</span><br><span class="line"> 1/16 Test #15: t_strm_reassem_single ............   Passed    0.00 sec</span><br><span class="line">      Start 16: t_strm_reassem_seq</span><br><span class="line"> 2/16 Test #16: t_strm_reassem_seq ...............   Passed    0.00 sec</span><br><span class="line">      Start 17: t_strm_reassem_dup</span><br><span class="line"> 3/16 Test #17: t_strm_reassem_dup ...............   Passed    0.01 sec</span><br><span class="line">      Start 18: t_strm_reassem_holes</span><br><span class="line"> 4/16 Test #18: t_strm_reassem_holes .............   Passed    0.00 sec</span><br><span class="line">      Start 19: t_strm_reassem_many</span><br><span class="line"> 5/16 Test #19: t_strm_reassem_many ..............   Passed    0.11 sec</span><br><span class="line">      Start 20: t_strm_reassem_overlapping</span><br><span class="line"> 6/16 Test #20: t_strm_reassem_overlapping .......   Passed    0.00 sec</span><br><span class="line">      Start 21: t_strm_reassem_win</span><br><span class="line"> 7/16 Test #21: t_strm_reassem_win ...............   Passed    0.12 sec</span><br><span class="line">      Start 22: t_byte_stream_construction</span><br><span class="line"> 8/16 Test #22: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">      Start 23: t_byte_stream_one_write</span><br><span class="line"> 9/16 Test #23: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">      Start 24: t_byte_stream_two_writes</span><br><span class="line">10/16 Test #24: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">      Start 25: t_byte_stream_capacity</span><br><span class="line">11/16 Test #25: t_byte_stream_capacity ...........   Passed    0.00 sec</span><br><span class="line">      Start 26: t_byte_stream_many_writes</span><br><span class="line">12/16 Test #26: t_byte_stream_many_writes ........   Passed    0.01 sec</span><br><span class="line">      Start 27: t_webget</span><br><span class="line">13/16 Test #27: t_webget .........................   Passed    0.47 sec</span><br><span class="line">      Start 47: t_address_dt</span><br><span class="line">14/16 Test #47: t_address_dt .....................   Passed    0.01 sec</span><br><span class="line">      Start 48: t_parser_dt</span><br><span class="line">15/16 Test #48: t_parser_dt ......................   Passed    0.00 sec</span><br><span class="line">      Start 49: t_socket_dt</span><br><span class="line">16/16 Test #49: t_socket_dt ......................   Passed    0.01 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 16</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-1-stitching-substrings-into-a-byte-stream&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-1-stitching-substrings-into-a-byte-stream&quot;&gt;#&lt;</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144 Lab Checkpoint 0:networking warmup</title>
    <link href="https://flowerhai.github.io/2023/05/06/cs144/cs144lab0/"/>
    <id>https://flowerhai.github.io/2023/05/06/cs144/cs144lab0/</id>
    <published>2023-05-06T15:20:47.000Z</published>
    <updated>2023-05-06T15:22:12.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144-lab-checkpoint-0-networking-warmup"><a class="markdownIt-Anchor" href="#cs144-lab-checkpoint-0-networking-warmup">#</a> CS144 Lab Checkpoint 0: networking warmup</h1><p>visit  <a href="http://cs144.keithw.org/hello">http://cs144.keithw.org/hello</a></p><p>the result is Hello, CS144!</p><h4 id="on-ecs"><a class="markdownIt-Anchor" href="#on-ecs">#</a> on ECS</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet cs144.keithw.org http</span><br><span class="line"></span><br><span class="line">Trying 104.196.238.229...</span><br><span class="line">Connected to cs144.keithw.org.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /hello HTTP/1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="listening-and-connecting"><a class="markdownIt-Anchor" href="#listening-and-connecting">#</a> Listening and connecting</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netcat -v -l -p 9090</span><br><span class="line">telnet localhost 9090</span><br></pre></td></tr></table></figure><h3 id="writing-a-network-program-using-an-os-stream-socket"><a class="markdownIt-Anchor" href="#writing-a-network-program-using-an-os-stream-socket">#</a> Writing a network program using an OS stream socket</h3><p>我真蠢，真的，配了一天环境。</p><h4 id="writing-webget"><a class="markdownIt-Anchor" href="#writing-webget">#</a> Writing webget</h4><p>这个还是比较简单的，轻松就可以拿下</p><p>是让我们实现 get_url 这个函数，就是向指定地址发送一个 http 请求，然后做出响应即可。</p><p>注意讲义的要求就可以完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line">    TCPSocket socket;</span><br><span class="line">    socket.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    socket.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span>+path+<span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span>+host+<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    socket.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    <span class="keyword">while</span>(!socket.<span class="built_in">eof</span>())&#123;</span><br><span class="line">        cout&lt;&lt;socket.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    socket.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 06 May 2023 03:25:15 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT</span><br><span class="line">ETag: &quot;e-57ce93446cb64&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 14</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Hello, CS144!</span><br></pre></td></tr></table></figure><p>运行测试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 27: t_webget</span><br><span class="line">1/1 Test #27: t_webget .........................   Passed    0.54 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 1</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.55 sec</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target check_webget</span></span><br></pre></td></tr></table></figure><h4 id="an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#an-in-memory-reliable-byte-stream">#</a> An in-memory reliable byte stream</h4><p>这个也还行，就是中间修改完一直忘记重新 make 了，一直 66.7%, 不知道脑子在抽风什么。</p><p>我这个人 remake 得了</p><p>对 ByteStream 定义如下私有变量</p><p>缓冲区就选 deque，因为这是双端的，实验其实要求就是一端读，一端写，正好 deque 符合啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; buffer= &#123;&#125;;<span class="comment">//缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> Capacity_ ;<span class="comment">//容量</span></span><br><span class="line">    <span class="type">size_t</span> Read_Cnt_ = <span class="number">0</span>;<span class="comment">//读计数</span></span><br><span class="line">    <span class="type">size_t</span> Write_Cnt_ = <span class="number">0</span>;<span class="comment">//写计数</span></span><br><span class="line">    <span class="type">bool</span> Input_End_flag_= <span class="literal">false</span>;<span class="comment">//输入终止标识</span></span><br><span class="line">    <span class="type">bool</span> _error = <span class="literal">false</span>;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br></pre></td></tr></table></figure><p>然后就是写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(data);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">min</span>(data.<span class="built_in">size</span>(), Capacity_ - buffer.<span class="built_in">size</span>());</span><br><span class="line">    Write_Cnt_ += len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        buffer.<span class="built_in">emplace_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的一看便知，lab0 还是蛮 easy 的，只要把环境调试好，别搞太多幺蛾子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(len);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">min</span>(len, buffer.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(buffer.<span class="built_in">begin</span>(), buffer.<span class="built_in">begin</span>() + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">min</span>(len, buffer.<span class="built_in">size</span>());</span><br><span class="line">    Read_Cnt_ += length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i ++) buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Input_End_flag_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Input_End_flag_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; <span class="built_in">input_ended</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Write_Cnt_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Read_Cnt_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Capacity_ - <span class="built_in">buffer_size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 22: t_byte_stream_construction</span><br><span class="line">1/9 Test #22: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">    Start 23: t_byte_stream_one_write</span><br><span class="line">2/9 Test #23: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">    Start 24: t_byte_stream_two_writes</span><br><span class="line">3/9 Test #24: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">    Start 25: t_byte_stream_capacity</span><br><span class="line">4/9 Test #25: t_byte_stream_capacity ...........   Passed    0.00 sec</span><br><span class="line">    Start 26: t_byte_stream_many_writes</span><br><span class="line">5/9 Test #26: t_byte_stream_many_writes ........   Passed    0.01 sec</span><br><span class="line">    Start 27: t_webget</span><br><span class="line">6/9 Test #27: t_webget .........................   Passed    0.89 sec</span><br><span class="line">    Start 47: t_address_dt</span><br><span class="line">7/9 Test #47: t_address_dt .....................   Passed    0.01 sec</span><br><span class="line">    Start 48: t_parser_dt</span><br><span class="line">8/9 Test #48: t_parser_dt ......................   Passed    0.01 sec</span><br><span class="line">    Start 49: t_socket_dt</span><br><span class="line">9/9 Test #49: t_socket_dt ......................   Passed    0.01 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 9</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.95 sec</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target check_lab0</span></span><br></pre></td></tr></table></figure><p>lab0 还是比较 easy，只要把环境配置好，然后注意下 Git 以及 Cmake。</p><p>其余问题不大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144-lab-checkpoint-0-networking-warmup&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144-lab-checkpoint-0-networking-warmup&quot;&gt;#&lt;/a&gt; CS144 </summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>刷题day20</title>
    <link href="https://flowerhai.github.io/2023/05/06/shuati/day20/"/>
    <id>https://flowerhai.github.io/2023/05/06/shuati/day20/</id>
    <published>2023-05-06T13:20:38.000Z</published>
    <updated>2023-05-06T13:20:59.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="131-分割回文串"><a class="markdownIt-Anchor" href="#131-分割回文串">#</a> <a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h4><p>给你一个字符串  <code>s</code> ，请你将  <code>s</code>  分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回  <code>s</code>  所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; r;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d;i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ishuiwen</span>(s, d, i)) &#123;</span><br><span class="line">                string str = s.<span class="built_in">substr</span>(d, i-d+<span class="number">1</span>);</span><br><span class="line">                r.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ishuiwen</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="93-复原-ip-地址"><a class="markdownIt-Anchor" href="#93-复原-ip-地址">#</a> <a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于  <code>0</code>  到  <code>255</code>  之间组成，且不能含有前导  <code>0</code> ），整数之间用  <code>'.'</code>  分隔。</p><ul><li>例如： <code>&quot;0.1.2.201&quot;</code>  和 <code> &quot;192.168.1.1&quot;</code>  是 <strong>有效</strong> IP 地址，但是  <code>&quot;0.011.255.245&quot;</code> 、 <code>&quot;192.168.1.312&quot;</code>  和  <code>&quot;192.168@1.1&quot;</code>  是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串  <code>s</code>  ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在  <code>s</code>  中插入  <code>'.'</code>  来形成。你 <strong>不能</strong> 重新排序或删除  <code>s</code>  中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isrule</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; l != r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt;<span class="string">&#x27;0&#x27;</span> || s[i] &gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = n * <span class="number">10</span> + s[i] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s, d, s.<span class="built_in">size</span>()<span class="number">-1</span>)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s,d,i)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>); </span><br><span class="line">                p ++;</span><br><span class="line">                <span class="built_in">dfs</span>(s, i+<span class="number">2</span>, p);</span><br><span class="line">                p --;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> res; </span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集">#</a> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p>给你一个整数数组  <code>nums</code>  ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (d == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不在状态，困死惹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;131-分割回文串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#131-分割回文串&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/palindrome-partitioning/&quot;&gt;131.</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day19</title>
    <link href="https://flowerhai.github.io/2023/05/05/shuati/day19/"/>
    <id>https://flowerhai.github.io/2023/05/05/shuati/day19/</id>
    <published>2023-05-05T11:40:52.000Z</published>
    <updated>2023-05-05T11:41:16.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合">#</a> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数  <code>n</code>  和  <code>k</code> ，返回范围  <code>[1, n]</code>  中所有可能的  <code>k</code>  个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= n; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="216-组合总和-iii"><a class="markdownIt-Anchor" href="#216-组合总和-iii">#</a> <a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><p>找出所有相加之和为  <code>n</code>  的  <code>k</code>  个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k, <span class="type">int</span> tar, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == tar) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; tar) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= <span class="number">9</span>-(k-r.<span class="built_in">size</span>())+<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k, tar, sum);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合">#</a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; board = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//表示按到了键盘上的第几个键</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board[num].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(board[num][i]);  </span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, digits);  <span class="comment">//递归下一层</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();      <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28-找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#28-找出字符串中第一个匹配项的下标">#</a> <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><p>给你两个字符串  <code>haystack</code>  和  <code>needle</code>  ，请你在  <code>haystack</code>  字符串中找出  <code>needle</code>  字符串的第一个匹配项的下标（下标从 0 开始）。如果  <code>needle</code>  不是  <code>haystack</code>  的一部分，则返回  <code>-1</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pipei</span><span class="params">(string haystack, string needle, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle[y] == haystack[x] &amp;&amp; y == needle.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> haystack[x] == needle[y] &amp;&amp; <span class="built_in">pipei</span>(haystack, needle, x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pipei</span>(haystack, needle, i, <span class="number">0</span>)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP 优化版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置哨兵</span></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//预处理next数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="459-重复的子字符串"><a class="markdownIt-Anchor" href="#459-重复的子字符串">#</a> <a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><p>给定一个非空的字符串  <code>s</code>  ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; query, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = query.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是 KMP，掌握不是很熟练，明日重点 KMP.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;77-组合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#77-组合&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/combinations/&quot;&gt;77. 组合&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给定两个</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://flowerhai.github.io/2023/05/04/c/"/>
    <id>https://flowerhai.github.io/2023/05/04/c/</id>
    <published>2023-05-04T13:57:46.000Z</published>
    <updated>2023-05-04T13:58:33.755Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内联函数和普通函数的区别"><a class="markdownIt-Anchor" href="#内联函数和普通函数的区别">#</a> 内联函数和普通函数的区别</h4><p>省去函数调用开销</p><h4 id="c为什么支持函数重载c语言不支持"><a class="markdownIt-Anchor" href="#c为什么支持函数重载c语言不支持">#</a> C++ 为什么支持函数重载，C 语言不支持</h4><p>C++ 产生函数符号的时候，是由函数名 + 参数列表类型组成</p><p>C 代码是由函数名来决定的</p><h4 id="函数重载需要注意什么"><a class="markdownIt-Anchor" href="#函数重载需要注意什么">#</a> 函数重载需要注意什么</h4><h4 id="c和c语言代码之间如何调用"><a class="markdownIt-Anchor" href="#c和c语言代码之间如何调用">#</a> C++ 和 C 语言代码之间如何调用</h4><p><strong>extern &quot;C&quot; 的主要作用就是为了能够正确实现 C<ins> 代码调用其他 C 语言代码。加上 extern &quot;C&quot; 后，会指示编译器这部分代码按 C 语言（而不是 C</ins>）的方式进行编译。由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</strong></p><p>这个功能十分有用处，因为在 C<ins> 出现以前，很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，** 为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C</ins> 中尽可能的支持 C，而 extern &quot;C&quot; 就是其中的一个策略。**</p><p><strong>这个功能主要用在下面的情况：</strong></p><ol><li><strong>C++ 代码调用 C 语言代码</strong></li><li><strong>在 C++ 的头文件中使用</strong></li><li><strong>在多个人协同开发时，可能有的人比较擅长 C 语言，而有的人擅长 C++，这样的情况下也会有用到</strong></li></ol><p>看一个简单的例子：</p><p>有 moduleA、moduleB 两个模块，B 调用 A 中的代码，其中 A 是用 C 语言实现的，而 B 是利用 C++ 实现的，下面给出一种实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//moduleA头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MODULE_A_H <span class="comment">//对于模块A来说，这个宏是为了防止头文件的重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_A_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleA实现文件moduleA.C //模块A的实现部分并没有改变</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB头文件</span></span><br><span class="line"><span class="meta">#idndef __MODULE_B_H <span class="comment">//很明显这一部分也是为了防止重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">//而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件， extern &quot;C&quot;&#123; //因为cpp文件默认定义了该宏),则采用C语言方式进行编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">… <span class="comment">//其他代码</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB实现文件 moduleB.cpp //B模块的实现也没有改变，只是头文件的设计变化了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleB.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充介绍：</p><p>由于 C、C<ins> 编译器对函数的编译处理是不完全相同的，尤其对于 C</ins> 来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。</p><p>例如函数<strong> void fun (int, int)，编译后的可能是_fun_int_int (不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而 C 语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun 这样的名字。</strong></p><p>看下面的一个面试题：为什么标准头文件都有类似的结构？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __INCvxWorksh <span class="comment">/*防止该头文件被重复引用*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INCvxWorksh</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus             <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*…*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*end of __INCvxWorksh*/</span></span></span><br></pre></td></tr></table></figure><p><strong>extern &quot;C&quot; 包含双重含义</strong>，从字面上可以知道，首先，被它修饰的目标是 &quot;extern&quot; 的；其次，被它修饰的目标代码是 &quot;C&quot; 的。</p><ul><li>被 extern &quot;C&quot; 限定的函数或变量是 extern 类型的</li></ul><p>extern 是 C/C++ 语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。</p><p><strong>记住</strong>，语句：<strong>extern int a; 仅仅是一个变量的声明，其并不是在定义变量 a，也并未为 a 分配空间。变量 a 在所有模块中作为一种全局变量只能被定义一次，否则会出错。</strong></p><p>通常来说 **，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字 extern 生命。** 例如，如果模块 B 要引用模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但并不会报错；它会在链接阶段从模块 A 编译生成的目标代码中找到该函数。</p><p><strong>extern 对应的关键字是 static，static 表明变量或者函数只能在本模块中使用，因此，被 static 修饰的变量或者函数不可能被 extern C 修饰。</strong></p><ul><li><strong>被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式进行编译和链接的：这点很重要！！！！</strong></li></ul><p>上面也提到过，由于 C<ins> 支持函数重载，而 C 语言不支持，因此函数被 C</ins> 编译后在<strong>符号库</strong>中的名字是与 C 语言不同的；C++ 编译后的函数需要加上参数的类型才能唯一标定重载后的函数，而加上 extern &quot;C&quot; 后，是为了向编译器指明这段代码按照 C 语言的方式进行编译</p><p>未加 extern &quot;C&quot; 声明时的链接方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//模块A头文件 moduleA.h</span><br><span class="line">#idndef _MODULE_A_H</span><br><span class="line">#define _MODULE_A_H</span><br><span class="line"> </span><br><span class="line">int foo(int x, int y);</span><br><span class="line">#endif　</span><br></pre></td></tr></table></figure><p>在模块 B 中调用该函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//模块B实现文件 moduleB.cpp</span><br><span class="line">#include&quot;moduleA.h&quot;</span><br><span class="line">foo(2,3);　</span><br></pre></td></tr></table></figure><p>实际上，<strong>在链接阶段，链接器会从模块 A 生成的目标文件 moduleA.obj 中找_foo_int_int 这样的符号，显然这是不可能找到的，因为 foo () 函数被编译成了_foo 的符号，因此会出现链接错误。</strong></p><p><strong>extern &quot;C&quot; 的使用要点总结</strong></p><p>1，可以是如下的单一语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; double sqrt(double);</span><br></pre></td></tr></table></figure><p>2，可以是复合语句，相当于复合语句中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">      double sqrt(double);</span><br><span class="line">      int min(int, int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，可以包含头文件，相当于头文件中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    ＃include &lt;cmath&gt;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure><ul><li>不可以将 extern “C” 添加在函数内部</li><li>如果函数有多个声明，可以都加 extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。</li><li>除 extern “C”, 还有 extern “FORTRAN” 等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内联函数和普通函数的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内联函数和普通函数的区别&quot;&gt;#&lt;/a&gt; 内联函数和普通函数的区别&lt;/h4&gt;
&lt;p&gt;省去函数调用开销&lt;/p&gt;
&lt;h4 id=&quot;c为什么支持函数重载c语言不支持&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="C++" scheme="https://flowerhai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>day18</title>
    <link href="https://flowerhai.github.io/2023/05/04/shuati/day18/"/>
    <id>https://flowerhai.github.io/2023/05/04/shuati/day18/</id>
    <published>2023-05-04T13:38:01.000Z</published>
    <updated>2023-05-04T13:38:22.182Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列">#</a> <a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><p>开个数组记录一下不重复，开一个哈希表避免结果里有重复元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; jud;</span><br><span class="line">    unordered_map &lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,  <span class="type">int</span> d, <span class="type">int</span> n, string r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == n &amp;&amp; m.<span class="built_in">count</span>(r) == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">            m[r] == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jud[i]) &#123;</span><br><span class="line">                r.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                jud[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s, d + <span class="number">1</span>, n, r);</span><br><span class="line">                r.<span class="built_in">pop_back</span>();</span><br><span class="line">                jud[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        jud.<span class="built_in">resize</span>(<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">        string r;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>(), r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-43-1~n-整数中-1-出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-43-1~n-整数中-1-出现的次数">#</a> <a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p>输入一个整数  <code>n</code>  ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。</p><p>例如，输入 12，1～12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mulk = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; n &gt;= mulk; ++k) &#123;</span><br><span class="line">            ans += (n / (mulk * <span class="number">10</span>)) * mulk + <span class="built_in">min</span>(<span class="built_in">max</span>(n % (mulk * <span class="number">10</span>) - mulk + <span class="number">1</span>, <span class="number">0LL</span>), mulk);</span><br><span class="line">            mulk *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="541-反转字符串-ii"><a class="markdownIt-Anchor" href="#541-反转字符串-ii">#</a> <a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串  <code>s</code>  和一个整数  <code>k</code> ，从字符串开头算起，每计数至  <code>2k</code>  个字符，就反转这  <code>2k</code>  字符中的前  <code>k</code>  个字符。</p><ul><li>如果剩余字符少于  <code>k</code>  个，则将剩余字符全部反转。</li><li>如果剩余字符小于  <code>2k</code>  但大于或等于  <code>k</code>  个，则反转前  <code>k</code>  个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; i += 2 * k) &#123;</span><br><span class="line">            reverse(s.begin() + i, s.begin() + min(i + k, n));</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-05-替换空格"><a class="markdownIt-Anchor" href="#剑指-offer-05-替换空格">#</a> <a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串  <code>s</code>  中的每个空格替换成 &quot;%20&quot;。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a class="markdownIt-Anchor" href="#151-反转字符串中的单词">#</a> <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><p>给你一个字符串  <code>s</code>  ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。 <code>s</code>  中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>** 注意：** 输入字符串  <code>s</code>  中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p>好几种写法，用了下双端队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span>) ++left;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">&#x27; &#x27;</span>) --right;</span><br><span class="line">        deque&lt;string&gt; d;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[left];</span><br><span class="line">            <span class="keyword">if</span> (word.<span class="built_in">size</span>() &amp;&amp; c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += c;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += d.<span class="built_in">front</span>();</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-38-字符串的排列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-38-字符串的排列&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/zi-fu-chuan-</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://flowerhai.github.io/2023/05/04/qmi/"/>
    <id>https://flowerhai.github.io/2023/05/04/qmi/</id>
    <published>2023-05-04T03:34:11.000Z</published>
    <updated>2023-05-04T03:34:31.463Z</updated>
    
    <content type="html"><![CDATA[<p>\875. 快速幂</p><p>给定 n  组 ai,bi,pi  ,  ,  ，对于每组数据，求出 abiimodpi    mod   的值。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含整数 n 。</p><p>接下来 n  行，每行包含三个整数 ai,bi,pi  ,  ,  。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>对于每组数据，输出一个结果，表示 abiimodpi    mod   的值。</p><p>每个结果占一行。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤1000001≤ ≤100000,<br>1≤ai,bi,pi≤2×1091≤  , ≤2×109</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 2 5</span><br><span class="line">4 3 9</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>快速幂，类似于二进制优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * t % p;</span><br><span class="line">        t = (<span class="type">long</span> <span class="type">long</span>) t * t % p;</span><br><span class="line">        k &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">qmi</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;\875. 快速幂&lt;/p&gt;
&lt;p&gt;给定 n  组 ai,bi,pi  ,  ,  ，对于每组数据，求出 abiimodpi    mod   的值。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#输入格式&quot;&gt;#&lt;</summary>
      
    
    
    
    
    <category term="快速幂" scheme="https://flowerhai.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>刷题day17</title>
    <link href="https://flowerhai.github.io/2023/05/03/shuati/day17/"/>
    <id>https://flowerhai.github.io/2023/05/03/shuati/day17/</id>
    <published>2023-05-03T13:43:00.000Z</published>
    <updated>2023-05-03T13:43:46.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-60-n个骰子的点数"><a class="markdownIt-Anchor" href="#剑指-offer-60-n个骰子的点数">#</a> <a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n 个骰子的点数</a></h4><p>把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure><p>Dp，找到状态转移方程就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">70</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i ++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">6</span>*i; j &gt;= i; j --) &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> cur = <span class="number">1</span>; cur &lt;= <span class="number">6</span>; cur ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - cur &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] += dp[j-cur];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> all = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= <span class="number">6</span> * n; i ++) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(dp[i] * <span class="number">1.0</span> / all);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润">#</a> <a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p>一个维护最大值，一个维护最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i]-m);</span><br><span class="line">            m = <span class="built_in">min</span>(m, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-66-构建乘积数组"><a class="markdownIt-Anchor" href="#剑指-offer-66-构建乘积数组">#</a> <a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p>给定一个数组  <code>A[0,1,…,n-1]</code> ，请构建一个数组  <code>B[0,1,…,n-1]</code> ，其中  <code>B[i]</code>  的值是数组  <code>A</code>  中除了下标  <code>i</code>  以外的元素的积，即  <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code> 。不能使用除法。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><p>各开一个数组记录左右乘积</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            l[i] = l[i<span class="number">-1</span>]*a[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            r[i] = r[i+<span class="number">1</span>]*a[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            b[i] *= l[i];</span><br><span class="line">            b[i] *= r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#剑指-offer-46-把数字翻译成字符串">#</a> <a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><p>爬楼梯进阶版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num); </span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="type">int</span> t = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>)    </span><br><span class="line">                    f[i] += f[i - <span class="number">2</span>];     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#剑指-offer-45-把数组排成最小的数">#</a> <a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p>排序就行，自定义一下排序规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">            string s1 = <span class="built_in">to_string</span>(n1), s2 = <span class="built_in">to_string</span>(n2);</span><br><span class="line">            <span class="built_in">return</span> (s1 + s2) &lt; (s2 + s1);</span><br><span class="line">        &#125;);</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) ret += <span class="built_in">to_string</span>(e);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-44-数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#剑指-offer-44-数字序列中某一位的数字">#</a> <a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p>数字以 0123456789101112131415… 的格式序列化到一个字符序列中。在这个序列中，第 5 位（从下标 0 开始计数）是 5，第 13 位是 1，第 19 位是 4，等等。</p><p>请写一个函数，求任意第 n 位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; (<span class="type">long</span>) d * count) &#123;</span><br><span class="line">            n -= d * count;</span><br><span class="line">            d++;</span><br><span class="line">            count *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start = (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> num = start + index / d;</span><br><span class="line">        <span class="type">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="type">int</span> digit = (num / (<span class="type">int</span>) (<span class="built_in">pow</span>(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-60-n个骰子的点数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-60-n个骰子的点数&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/nge-tou-zi</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day16</title>
    <link href="https://flowerhai.github.io/2023/04/30/shuati/day16/"/>
    <id>https://flowerhai.github.io/2023/04/30/shuati/day16/</id>
    <published>2023-04-30T14:40:16.000Z</published>
    <updated>2023-04-30T14:41:30.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#剑指-offer-33-二叉搜索树的后序遍历序列">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回  <code>true</code> ，否则返回  <code>false</code> 。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>注意下二叉搜索树的性质即可快速求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p ++;</span><br><span class="line">        <span class="type">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, i, m - <span class="number">1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, j - <span class="number">1</span>) &amp;&amp; (p == j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的大小顺序排列是：左中右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串">#</a> <a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>动态规划</p><p>哈希表 + 动态规划</p><p>开一个哈希表存上次出现的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        mp[s[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> j = mp[s[i]];</span><br><span class="line">                <span class="keyword">if</span> (i-j &gt; f[i<span class="number">-1</span>]) f[i] = f[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i] = i-j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])==<span class="number">0</span>) &#123;</span><br><span class="line">                f[i] = f[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-56-i-数组中数字出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-56-i-数组中数字出现的次数">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组  <code>nums</code>  里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O (n)，空间复杂度是 O (1)。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p>此题甚妙</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-33-二叉搜索树的后序遍历序列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-33-二叉搜索树的后序遍历序列&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法实现</title>
    <link href="https://flowerhai.github.io/2023/04/30/lru/"/>
    <id>https://flowerhai.github.io/2023/04/30/lru/</id>
    <published>2023-04-30T08:05:27.000Z</published>
    <updated>2023-04-30T08:05:55.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现lru算法"><a class="markdownIt-Anchor" href="#实现lru算法">#</a> 实现 LRU 算法</h3><p>LRU-least recently used - 最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</p><p>可以使用双向链表加哈希表</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现LRU缓存机制</span></span><br><span class="line"><span class="comment">//LRU-least recently used-最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_lru.<span class="built_in">count</span>(x)==<span class="number">0</span>) &#123; <span class="comment">//此事时没有这个key</span></span><br><span class="line">            <span class="keyword">if</span> (size_lru &lt; v) &#123;<span class="comment">//此时LRU未满</span></span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">                size_lru ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> front_node = node_lru.<span class="built_in">front</span>();</span><br><span class="line">                hash_lru.<span class="built_in">erase</span>(front_node);</span><br><span class="line">                node_lru.<span class="built_in">pop_front</span>();</span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//存在这个</span></span><br><span class="line">            node_lru.<span class="built_in">remove</span>(x);</span><br><span class="line">            node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash_lru[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = node_lru.<span class="built_in">back</span>();</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k:node_lru) cout&lt;&lt;k&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LRU</span>(<span class="type">int</span> x,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">v</span>(x), <span class="built_in">size_lru</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash_lru;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; node_lru;</span><br><span class="line">    <span class="type">int</span> size_lru;<span class="comment">//当前节点数量</span></span><br><span class="line">    <span class="type">int</span> v;<span class="comment">//容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">0 </span><br><span class="line">3 </span><br><span class="line">0 </span><br><span class="line">4 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">7 0 </span><br><span class="line">0 1 </span><br><span class="line">1 2 </span><br><span class="line">2 0 </span><br><span class="line">0 3 </span><br><span class="line">3 0 </span><br><span class="line">0 4 </span><br></pre></td></tr></table></figure><p>7<br>7 0<br>7 0 1<br>0 1 2<br>1 2 0<br>2 0 3<br>2 3 0<br>3 0 4</p><p>没问题，表现良好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现lru算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现lru算法&quot;&gt;#&lt;/a&gt; 实现 LRU 算法&lt;/h3&gt;
&lt;p&gt;LRU-least recently used - 最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内</summary>
      
    
    
    
    
    <category term="LRU算法实现" scheme="https://flowerhai.github.io/tags/LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://flowerhai.github.io/2023/04/29/weiyuansuan/"/>
    <id>https://flowerhai.github.io/2023/04/29/weiyuansuan/</id>
    <published>2023-04-29T14:56:35.000Z</published>
    <updated>2023-04-29T14:57:51.478Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1位运算概述"><a class="markdownIt-Anchor" href="#1位运算概述">#</a> 1. 位运算概述</h3><p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*、/) 都是叫位运算，即将符号位共同参与运算的运算。</p><p>口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 35;</span><br><span class="line">int b = 47;</span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure><p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">35:  0 0 1 0 0 0 1 1</span><br><span class="line">47:  0 0 1 0 1 1 1 1</span><br><span class="line">————————————————————</span><br><span class="line">82:  0 1 0 1 0 0 1 0</span><br></pre></td></tr></table></figure><p>所以，相比在代码中直接使用 (+、-、*、/) 运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。</p><h3 id="2位运算概览"><a class="markdownIt-Anchor" href="#2位运算概览">#</a> 2. 位运算概览</h3><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th><th style="text-align:left">运算规则</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">与</td><td style="text-align:left">两个位都为 1 时，结果才为 1</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">或</td><td style="text-align:left">两个位都为 0 时，结果才为 0</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">异或</td><td style="text-align:left">两个位相同为 0，相异为 1</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">取反</td><td style="text-align:left">0 变 1，1 变 0</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移</td><td style="text-align:left">各二进位全部左移若干位，高位丢弃，低位补 0</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移</td><td style="text-align:left">各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）</td></tr></tbody></table><h3 id="3按位与运算符"><a class="markdownIt-Anchor" href="#3按位与运算符">#</a> 3. 按位与运算符（&amp;）#</h3><p><strong>定义</strong>：参加运算的两个数据，按二进制位进行 &quot;与&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&amp;0=0  0&amp;1=0  1&amp;0=0  1&amp;1=1</span><br></pre></td></tr></table></figure><p>总结：两位同时为 1，结果才为 1，否则结果为 0。</p><p>例如：3&amp;5 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得 1。</p><p>注意：负数按补码形式参加按位与运算。</p><p><strong>与运算的用途：</strong></p><p>1）清零</p><p>如果想将一个单元清零，即使其全部二进制位为 0，只要与一个各位都为零的数值相与，结果为零。</p><p>2）取一个数的指定位</p><p>比如取数 X=1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位与运算（X&amp;Y=0000 1110）即可得到 X 的指定位。</p><p>3）判断奇偶</p><p>只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a &amp; 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。</p><p>4. 按位或运算符（|）</p><p>定义：参加运算的两个对象，按二进制位进行 &quot;或&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0|0=0  0|1=1  1|0=1  1|1=1</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为 1，其值为 1。</p><p>例如：3|5 即 0000 0011| 0000 0101 = 0000 0111，因此，3|5 的值得 7。</p><p>注意：负数按补码形式参加按位或运算。</p><p>或运算的用途：</p><p>1）常用来对一个数据的某些位设置为 1</p><p>比如将数 X=1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位或运算（X|Y=1010 1111）即可得到。</p><p>5. 异或运算符（^）</p><p>定义：参加运算的两个数据，按二进制位进行 &quot;异或&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0^0=0  0^1=1  1^0=1  1^1=0</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为 0，相异为 1。</p><p>异或的几条性质:</p><ul><li>1、交换律</li><li>2、结合律 (a<sup>b)</sup>c == a<sup>(b</sup>c)</li><li>3、对于任何数 x，都有 x<sup>x=0，x</sup>0=x</li><li>4、自反性: a<sup>b</sup>b=a^0=a;</li></ul><p>异或运算的用途：</p><p>1）翻转指定位</p><p>比如将数 X=1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行异或运算（X^Y=1010 0001）即可得到。</p><p>2）与 0 相异或值不变</p><p>例如：1010 1110 ^ 0000 0000 = 1010 1110</p><p>3）交换两个数</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例">#</a> 实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a != b)&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6. 取反运算符 (~)</p><p>定义：参加运算的一个数据，按二进制进行 &quot;取反&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~1=0</span><br><span class="line">~0=1</span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将 0 变 1，1 变 0。</p><p>异或运算的用途：</p><p>1）使一个数的最低位为零</p><p>使 a 的最低位为 0，可以表示为：a &amp; <sub>1。</sub>1 的值为 1111 1111 1111 1110，再按 &quot;与&quot; 运算，最低位一定为 0。因为 &quot;~&quot; 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p><p>7. 左移运算符（&lt;&lt;）</p><p>定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。</p><p>设 a=1010 1110，a = a&lt;&lt; 2 将 a 的二进制位左移 2 位、右补 0，即得 a=1011 1000。</p><p>若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2。</p><p>8. 右移运算符（&gt;&gt;）</p><p>定义：将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。</p><p>例如：a=a&gt;&gt;2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以 2。</p><p>10. 复合赋值运算符</p><p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;=        例：a&amp;=b    相当于     a=a&amp;b</span><br><span class="line"></span><br><span class="line">|=        例：a|=b    相当于     a=a|b</span><br><span class="line"></span><br><span class="line">&gt;&gt;=      例：a&gt;&gt;=b   相当于     a=a&gt;&gt;b</span><br><span class="line"></span><br><span class="line">&lt;&lt;=      例：a&lt;&lt;=b     相当于      a=a&lt;&lt;b</span><br><span class="line"></span><br><span class="line">^=        例：a^=b    相当于   a=a^b</span><br></pre></td></tr></table></figure><p>运算规则：和前面讲的复合赋值运算符的运算规则相似。</p><p>不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p><p>以 &quot;与运算&quot; 为例说明如下：我们知道在 C 语言中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行 &quot;与运算&quot;，右端对齐后，左边不足的位依下面三种情况补足，</p><ul><li><p>1）如果整型数据为正数，左边补 16 个 0。</p></li><li><p>2）如果整型数据为负数，左边补 16 个 1。</p></li><li><p>3）如果整形数据为无符号数，左边也补 16 个 0。</p></li><li><p>如：long a=123；int b=1；计算 a&amp; b。</p></li><li></li><li><p>如：long a=123；int b=-1；计算 a&amp; b。</p></li><li><p>如：long a=123；unsigned intb=1；计算 a &amp; b。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1位运算概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1位运算概述&quot;&gt;#&lt;/a&gt; 1. 位运算概述&lt;/h3&gt;
&lt;p&gt;从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*</summary>
      
    
    
    
    
    <category term="位运算" scheme="https://flowerhai.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题day15</title>
    <link href="https://flowerhai.github.io/2023/04/29/shuati/day15/"/>
    <id>https://flowerhai.github.io/2023/04/29/shuati/day15/</id>
    <published>2023-04-29T14:07:13.000Z</published>
    <updated>2023-04-29T14:07:41.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-13-机器人的运动范围"><a class="markdownIt-Anchor" href="#剑指-offer-13-机器人的运动范围">#</a> <a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>地上有一个 m 行 n 列的方格，从坐标  <code>[0,0]</code>  到坐标  <code>[m-1,n-1]</code>  。一个机器人从坐标  <code>[0, 0] </code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>将满足条件的格子置为 1，不满住的置为 0，然后对起点做一个 dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rx = <span class="number">0</span>, ry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            rx += x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            ry += y%<span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rx + ry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m,<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m[x][y] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        m[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; m[x<span class="number">-1</span>][y]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span>&lt;m.<span class="built_in">size</span>() &amp;&amp; m[x+<span class="number">1</span>][y]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; m[x][y<span class="number">-1</span>]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(y+<span class="number">1</span>&lt;m[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; m[x][y+<span class="number">1</span>]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x, y+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j= <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get_value</span>(i, j) &gt; k) a[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> a[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(a,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-14-ii-剪绳子-ii"><a class="markdownIt-Anchor" href="#剑指-offer-14-ii-剪绳子-ii">#</a> <a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><p>给你一根长度为  <code>n</code>  的绳子，请把绳子剪成整数长度的  <code>m</code>  段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为  <code>k[0],k[1]...k[m - 1]</code>  。请问  <code>k[0]*k[1]*...*k[m - 1]</code>  可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = n / <span class="number">3</span> - <span class="number">1</span>; a &gt; <span class="number">0</span>; a /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">            x = (x * x) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> rem * <span class="number">3</span> % p;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> rem * <span class="number">4</span> % p;</span><br><span class="line">        <span class="keyword">return</span> rem * <span class="number">6</span> % p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-16-数值的整数次方"><a class="markdownIt-Anchor" href="#剑指-offer-16-数值的整数次方">#</a> <a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="type">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-31-栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#剑指-offer-31-栈的压入-弹出序列">#</a> <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p>直接按照题意开整就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            st.<span class="built_in">emplace</span>(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == popped[j]) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-13-机器人的运动范围&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-13-机器人的运动范围&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/ji-qi-re</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>基础知识复习</title>
    <link href="https://flowerhai.github.io/2023/04/29/muduo/muduo1/"/>
    <id>https://flowerhai.github.io/2023/04/29/muduo/muduo1/</id>
    <published>2023-04-29T12:47:00.000Z</published>
    <updated>2023-04-29T12:47:25.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识复习"><a class="markdownIt-Anchor" href="#基础知识复习">#</a> 基础知识复习</h2><h3 id="阻塞-非阻塞-同步-异步"><a class="markdownIt-Anchor" href="#阻塞-非阻塞-同步-异步">#</a> 阻塞、非阻塞、同步、异步</h3><p>典型的一次数据 IO 包含两个阶段：数据准备、数据读写</p><h4 id="数据准备"><a class="markdownIt-Anchor" href="#数据准备">#</a> 数据准备：</h4><ul><li><p>阻塞</p><p>调用 IO 方法的线程进入阻塞状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = recv(sockfd, buf, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果 sockfd 没有数据（默认阻塞)，此时就回阻塞在这里。</p></li><li><p>非阻塞</p><p>不会改变线程的状态，通过返回值判断</p><p>如果非阻塞，会直接返回。(size == -1 &amp;&amp; errno == EAGAIN)</p></li></ul><h4 id="数据读写io的同步和异步"><a class="markdownIt-Anchor" href="#数据读写io的同步和异步">#</a> 数据读写：(IO 的同步和异步)</h4><ul><li><p>同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = recv(sockfd, buf, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果数据没有全部写到缓冲区中，那么将阻塞，且需自己写入缓冲区</p></li><li><p>异步</p><p>异步 IO 接口的时候，当系统 sigio<strong> 通知</strong>的时候，buf 的数据已经准备好了。</p><p>（aio_read, aio_write)</p></li></ul><p>Node.js 基于异步非阻塞模式下的高性能服务器</p><p>在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用特殊的 API 才是异步 IO。</p><h4 id="业务层面的一个逻辑处理是同步还是异步"><a class="markdownIt-Anchor" href="#业务层面的一个逻辑处理是同步还是异步">#</a> 业务层面的一个逻辑处理是同步还是异步？</h4><h5 id="同步"><a class="markdownIt-Anchor" href="#同步">#</a> 同步：</h5><p>A 操作等待 B 操作完成事情，得到返回，继续处理</p><h5 id="异步"><a class="markdownIt-Anchor" href="#异步">#</a> 异步：</h5><p>A 操作告诉 B 操作它感兴趣的事件以及通知方式，A 操作继续自己的业务逻辑，等待 B 监听到响应事件发生后，B 会通知 A，A 开始数据处理逻辑。</p><p>一个典型的网络 IO 接口调用，分为两个阶段，分别是 &quot;数据就绪&quot; 和 &quot;数据读写&quot;， 数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结：</h4><p>同步表示 A 向 B 请求调用一个网络 IO 接口时，数据读写都是由请求方 A 来自己完成的；异步表示 A 向 B 请求调用一个网络 IO 接口时，向 B 传入请求的事件以及事件发生时统治的方式，A 就可以处理其他逻辑了，当 B 监听到事件处理完成后，会用实现约定好的通知方式，通知 A 处理结果</p><h3 id="unixlinux上的五种io模型"><a class="markdownIt-Anchor" href="#unixlinux上的五种io模型">#</a> Unix/Linux 上的五种 IO 模型</h3><ul><li><p>阻塞 blocking</p></li><li><p>非阻塞 non-blocking</p></li><li><p>IO 复用 IO multiplexing</p></li><li><p>信号驱动 signal-driven</p></li><li><p>异步 asynchronous</p></li></ul><h3 id="网络服务器设计"><a class="markdownIt-Anchor" href="#网络服务器设计">#</a> 网络服务器设计</h3><p>one loop pre thread is usually a good model</p><h3 id="reactor模型"><a class="markdownIt-Anchor" href="#reactor模型">#</a> Reactor 模型</h3><p>Event 事件，Reactor 反应堆，Demultiplex 事件分发器，Eventhandler 事件分发器</p><h3 id="epoll"><a class="markdownIt-Anchor" href="#epoll">#</a> epoll</h3><h4 id="select和poll的缺点"><a class="markdownIt-Anchor" href="#select和poll的缺点">#</a> select 和 poll 的缺点</h4><h5 id="select的缺点"><a class="markdownIt-Anchor" href="#select的缺点">#</a> select 的缺点：</h5><p>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是 1024，当然可以更改数量，但由于 select 采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在 linux 内核头文件中，有 这样的定义：#define_FD_SETSIZE 1024 __</p><p>2、内核 / 用户空间内存拷贝问题，select 需要复制大量的句柄数据结构，产生巨大的开销</p><p>3、select 返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</p><p>4、select 的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行 IO 操作， 那么之后每次 select 调用还是会将这些文件描述符通知进程</p><p>相比 select 模型，poll 使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依 然存在。</p><p>以 select 模型为例，假设我们的服务器需要支持 100 万的并发连接，则在__FD_SETSIZE 为 1024 的情况 下，则我们至少需要开辟 1k 个进程才能实现 100 万的并发连接。除了进程间上下文切换的时间消耗外， 从内核 / 用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于 select 模型的 服务器程序，要达到 100 万级别的并发访问，是一个很难完成的任务。</p><h5 id="epoll原理以及优势"><a class="markdownIt-Anchor" href="#epoll原理以及优势">#</a> epoll 原理以及优势</h5><p>epoll 的实现机制与 select/poll 机制完全不同，它们的缺点在 epoll 上不复存在。</p><p>设想一下如下场景：有 100 万个客户端同时与一个服务器进程保持着 TCP 连接。而每一时刻，通常只有 几百上千个 TCP 连接是活跃的 (事实上大部分场景都是这种情况)。如何实现这样的高并发？ 在 select/poll 时代，服务器进程每次都把这 100 万个连接告诉操作系统（从用户态复制句柄数据结构到 内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据复制到用 户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll 一般 只能处理几千的并发连接。</p><p>epoll 的设计和实现与 select 完全不同。epoll 通过在 Linux 内核中申请一个简易的文件系统（文件系统一 般用什么数据结构实现？B + 树，磁盘 IO 消耗低，效率很高）。把原先的 select/poll 调用分成以下 3 个部 分：</p><ul><li>调用 epoll_create () 建立一个 epoll 对象（在 epoll 文件系统中为这个句柄对象分配资源）</li><li>调用 epoll_ctl 向 epoll 对象中添加这 100 万个连接的套接字</li><li>调用 epoll_wait 收集发生的事件的 fd 资源</li></ul><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个 epoll 对象，然后在需要的时候向这 个 epoll 对象中添加或者删除事件。同时，epoll_wait 的效率也非常高，因为调用 epoll_wait 时，并没有 向操作系统复制这 100 万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><p>epoll_create 在内核上创建的 eventpoll 结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line"><span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="lt模式"><a class="markdownIt-Anchor" href="#lt模式">#</a> LT 模式</h4><p>内核数据没被读完，就会一直上报数据。</p><h4 id="et模式"><a class="markdownIt-Anchor" href="#et模式">#</a> ET 模式</h4><p>内核数据只上报一次。</p><h4 id="muduo采用的是lt"><a class="markdownIt-Anchor" href="#muduo采用的是lt">#</a> muduo 采用的是 LT</h4><ul><li>不会丢失数据或者消息 应用没有读取完数据，内核是会不断上报的</li><li>低延迟处理 每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量 过大而影响其他连接处理消息</li><li>跨平台处理 像 select 一样可以跨平台使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础知识复习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础知识复习&quot;&gt;#&lt;/a&gt; 基础知识复习&lt;/h2&gt;
&lt;h3 id=&quot;阻塞-非阻塞-同步-异步&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#阻塞-非</summary>
      
    
    
    
    
    <category term="muduo设计" scheme="https://flowerhai.github.io/tags/muduo%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>智能指针简单设计</title>
    <link href="https://flowerhai.github.io/2023/04/29/smart-pointers/ptr/"/>
    <id>https://flowerhai.github.io/2023/04/29/smart-pointers/ptr/</id>
    <published>2023-04-29T12:45:29.000Z</published>
    <updated>2023-04-29T12:46:23.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针">#</a> 智能指针</h3><h4 id="关于智能指针的设计"><a class="markdownIt-Anchor" href="#关于智能指针的设计">#</a> 关于智能指针的设计</h4><p>智能指针是为了方便的智能管理内存资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//智能指针 保证能做到资源的自动释放！！！</span></span><br><span class="line"><span class="comment">//利用栈上的对象出作用域自动析构</span></span><br><span class="line"><span class="comment">//不能是堆上</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;<span class="keyword">delete</span> ptr;&#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不带引用计数的智能指针"><a class="markdownIt-Anchor" href="#不带引用计数的智能指针">#</a> 不带引用计数的智能指针</h4><p>如果我们这样：</p><p>smart_ptr<int> p1(new int);<br>smart_ptr<int> p2(p1);</p><p>会发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(): double free detected in tcache 2</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>原因是为拷贝构造默认是一个浅拷贝，相当于对同一份资源释放了两次。</p><h5 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法">#</a> 解决方法</h5><p>1）可以重新定义拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;<span class="keyword">delete</span> ptr;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src) &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">T</span>(*src.ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时运行就不会出错</p><p>2）禁用拷贝构造，即 (unique_ptr)</p><p>保持独占性即可。</p><p>3）当然还有其他的方法，不再赘述，会有安全性的问题</p><h4 id="带引用计数的智能指针设计"><a class="markdownIt-Anchor" href="#带引用计数的智能指针设计">#</a> 带引用计数的智能指针设计</h4><p>加一个计数的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr_cnt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr_cnt</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_cnt</span><span class="params">()</span> </span>&#123; cnt++;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">subtract_cnt</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> --cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="built_in">smart_ptr_cnt</span>&lt;T&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == cnt-&gt;<span class="built_in">subtract_cnt</span>()) <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src): <span class="built_in">ptr</span>(src.ptr), <span class="built_in">cnt</span>(src.cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) cnt-&gt;<span class="built_in">add_cnt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == cnt-&gt;<span class="built_in">subtract_cnt</span>()) <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = src.ptr;</span><br><span class="line">        cnt = src.cnt;</span><br><span class="line">        cnt-&gt;<span class="built_in">add_cnt</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// smart_ptr(const smart_ptr&lt;T&gt; &amp;src) = delete;</span></span><br><span class="line">    <span class="comment">// smart_ptr&lt;T&gt;&amp; operator = (const smart_ptr&lt;T&gt; &amp;) = delete;</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">    <span class="comment">//std::atomic&lt;int&gt; cnt;</span></span><br><span class="line">    smart_ptr_cnt&lt;T&gt; *cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;智能指针&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#智能指针&quot;&gt;#&lt;/a&gt; 智能指针&lt;/h3&gt;
&lt;h4 id=&quot;关于智能指针的设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于智能指针的设计&quot;&gt;#&lt;</summary>
      
    
    
    
    
    <category term="智能指针" scheme="https://flowerhai.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
