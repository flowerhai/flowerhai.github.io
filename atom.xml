<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚迷离</title>
  
  
  <link href="https://flowerhai.github.io/atom.xml" rel="self"/>
  
  <link href="https://flowerhai.github.io/"/>
  <updated>2023-05-06T13:20:59.844Z</updated>
  <id>https://flowerhai.github.io/</id>
  
  <author>
    <name>恍惚迷离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刷题day20</title>
    <link href="https://flowerhai.github.io/2023/05/06/shuati/day20/"/>
    <id>https://flowerhai.github.io/2023/05/06/shuati/day20/</id>
    <published>2023-05-06T13:20:38.000Z</published>
    <updated>2023-05-06T13:20:59.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="131-分割回文串"><a class="markdownIt-Anchor" href="#131-分割回文串">#</a> <a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h4><p>给你一个字符串  <code>s</code> ，请你将  <code>s</code>  分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回  <code>s</code>  所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; r;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d;i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ishuiwen</span>(s, d, i)) &#123;</span><br><span class="line">                string str = s.<span class="built_in">substr</span>(d, i-d+<span class="number">1</span>);</span><br><span class="line">                r.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ishuiwen</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="93-复原-ip-地址"><a class="markdownIt-Anchor" href="#93-复原-ip-地址">#</a> <a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于  <code>0</code>  到  <code>255</code>  之间组成，且不能含有前导  <code>0</code> ），整数之间用  <code>'.'</code>  分隔。</p><ul><li>例如： <code>&quot;0.1.2.201&quot;</code>  和 <code> &quot;192.168.1.1&quot;</code>  是 <strong>有效</strong> IP 地址，但是  <code>&quot;0.011.255.245&quot;</code> 、 <code>&quot;192.168.1.312&quot;</code>  和  <code>&quot;192.168@1.1&quot;</code>  是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串  <code>s</code>  ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在  <code>s</code>  中插入  <code>'.'</code>  来形成。你 <strong>不能</strong> 重新排序或删除  <code>s</code>  中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isrule</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; l != r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt;<span class="string">&#x27;0&#x27;</span> || s[i] &gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = n * <span class="number">10</span> + s[i] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s, d, s.<span class="built_in">size</span>()<span class="number">-1</span>)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s,d,i)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>); </span><br><span class="line">                p ++;</span><br><span class="line">                <span class="built_in">dfs</span>(s, i+<span class="number">2</span>, p);</span><br><span class="line">                p --;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> res; </span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集">#</a> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p>给你一个整数数组  <code>nums</code>  ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (d == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不在状态，困死惹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;131-分割回文串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#131-分割回文串&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/palindrome-partitioning/&quot;&gt;131.</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day19</title>
    <link href="https://flowerhai.github.io/2023/05/05/shuati/day19/"/>
    <id>https://flowerhai.github.io/2023/05/05/shuati/day19/</id>
    <published>2023-05-05T11:40:52.000Z</published>
    <updated>2023-05-05T11:41:16.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合">#</a> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数  <code>n</code>  和  <code>k</code> ，返回范围  <code>[1, n]</code>  中所有可能的  <code>k</code>  个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= n; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="216-组合总和-iii"><a class="markdownIt-Anchor" href="#216-组合总和-iii">#</a> <a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><p>找出所有相加之和为  <code>n</code>  的  <code>k</code>  个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k, <span class="type">int</span> tar, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == tar) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; tar) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= <span class="number">9</span>-(k-r.<span class="built_in">size</span>())+<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k, tar, sum);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合">#</a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; board = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//表示按到了键盘上的第几个键</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board[num].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(board[num][i]);  </span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, digits);  <span class="comment">//递归下一层</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();      <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28-找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#28-找出字符串中第一个匹配项的下标">#</a> <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><p>给你两个字符串  <code>haystack</code>  和  <code>needle</code>  ，请你在  <code>haystack</code>  字符串中找出  <code>needle</code>  字符串的第一个匹配项的下标（下标从 0 开始）。如果  <code>needle</code>  不是  <code>haystack</code>  的一部分，则返回  <code>-1</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pipei</span><span class="params">(string haystack, string needle, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle[y] == haystack[x] &amp;&amp; y == needle.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> haystack[x] == needle[y] &amp;&amp; <span class="built_in">pipei</span>(haystack, needle, x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pipei</span>(haystack, needle, i, <span class="number">0</span>)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP 优化版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置哨兵</span></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//预处理next数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="459-重复的子字符串"><a class="markdownIt-Anchor" href="#459-重复的子字符串">#</a> <a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><p>给定一个非空的字符串  <code>s</code>  ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; query, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = query.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是 KMP，掌握不是很熟练，明日重点 KMP.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;77-组合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#77-组合&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/combinations/&quot;&gt;77. 组合&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给定两个</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://flowerhai.github.io/2023/05/04/c/"/>
    <id>https://flowerhai.github.io/2023/05/04/c/</id>
    <published>2023-05-04T13:57:46.000Z</published>
    <updated>2023-05-04T13:58:33.755Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内联函数和普通函数的区别"><a class="markdownIt-Anchor" href="#内联函数和普通函数的区别">#</a> 内联函数和普通函数的区别</h4><p>省去函数调用开销</p><h4 id="c为什么支持函数重载c语言不支持"><a class="markdownIt-Anchor" href="#c为什么支持函数重载c语言不支持">#</a> C++ 为什么支持函数重载，C 语言不支持</h4><p>C++ 产生函数符号的时候，是由函数名 + 参数列表类型组成</p><p>C 代码是由函数名来决定的</p><h4 id="函数重载需要注意什么"><a class="markdownIt-Anchor" href="#函数重载需要注意什么">#</a> 函数重载需要注意什么</h4><h4 id="c和c语言代码之间如何调用"><a class="markdownIt-Anchor" href="#c和c语言代码之间如何调用">#</a> C++ 和 C 语言代码之间如何调用</h4><p><strong>extern &quot;C&quot; 的主要作用就是为了能够正确实现 C<ins> 代码调用其他 C 语言代码。加上 extern &quot;C&quot; 后，会指示编译器这部分代码按 C 语言（而不是 C</ins>）的方式进行编译。由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</strong></p><p>这个功能十分有用处，因为在 C<ins> 出现以前，很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，** 为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C</ins> 中尽可能的支持 C，而 extern &quot;C&quot; 就是其中的一个策略。**</p><p><strong>这个功能主要用在下面的情况：</strong></p><ol><li><strong>C++ 代码调用 C 语言代码</strong></li><li><strong>在 C++ 的头文件中使用</strong></li><li><strong>在多个人协同开发时，可能有的人比较擅长 C 语言，而有的人擅长 C++，这样的情况下也会有用到</strong></li></ol><p>看一个简单的例子：</p><p>有 moduleA、moduleB 两个模块，B 调用 A 中的代码，其中 A 是用 C 语言实现的，而 B 是利用 C++ 实现的，下面给出一种实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//moduleA头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MODULE_A_H <span class="comment">//对于模块A来说，这个宏是为了防止头文件的重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_A_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleA实现文件moduleA.C //模块A的实现部分并没有改变</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB头文件</span></span><br><span class="line"><span class="meta">#idndef __MODULE_B_H <span class="comment">//很明显这一部分也是为了防止重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">//而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件， extern &quot;C&quot;&#123; //因为cpp文件默认定义了该宏),则采用C语言方式进行编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">… <span class="comment">//其他代码</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB实现文件 moduleB.cpp //B模块的实现也没有改变，只是头文件的设计变化了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleB.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充介绍：</p><p>由于 C、C<ins> 编译器对函数的编译处理是不完全相同的，尤其对于 C</ins> 来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。</p><p>例如函数<strong> void fun (int, int)，编译后的可能是_fun_int_int (不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而 C 语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun 这样的名字。</strong></p><p>看下面的一个面试题：为什么标准头文件都有类似的结构？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __INCvxWorksh <span class="comment">/*防止该头文件被重复引用*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INCvxWorksh</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus             <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*…*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*end of __INCvxWorksh*/</span></span></span><br></pre></td></tr></table></figure><p><strong>extern &quot;C&quot; 包含双重含义</strong>，从字面上可以知道，首先，被它修饰的目标是 &quot;extern&quot; 的；其次，被它修饰的目标代码是 &quot;C&quot; 的。</p><ul><li>被 extern &quot;C&quot; 限定的函数或变量是 extern 类型的</li></ul><p>extern 是 C/C++ 语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。</p><p><strong>记住</strong>，语句：<strong>extern int a; 仅仅是一个变量的声明，其并不是在定义变量 a，也并未为 a 分配空间。变量 a 在所有模块中作为一种全局变量只能被定义一次，否则会出错。</strong></p><p>通常来说 **，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字 extern 生命。** 例如，如果模块 B 要引用模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但并不会报错；它会在链接阶段从模块 A 编译生成的目标代码中找到该函数。</p><p><strong>extern 对应的关键字是 static，static 表明变量或者函数只能在本模块中使用，因此，被 static 修饰的变量或者函数不可能被 extern C 修饰。</strong></p><ul><li><strong>被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式进行编译和链接的：这点很重要！！！！</strong></li></ul><p>上面也提到过，由于 C<ins> 支持函数重载，而 C 语言不支持，因此函数被 C</ins> 编译后在<strong>符号库</strong>中的名字是与 C 语言不同的；C++ 编译后的函数需要加上参数的类型才能唯一标定重载后的函数，而加上 extern &quot;C&quot; 后，是为了向编译器指明这段代码按照 C 语言的方式进行编译</p><p>未加 extern &quot;C&quot; 声明时的链接方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//模块A头文件 moduleA.h</span><br><span class="line">#idndef _MODULE_A_H</span><br><span class="line">#define _MODULE_A_H</span><br><span class="line"> </span><br><span class="line">int foo(int x, int y);</span><br><span class="line">#endif　</span><br></pre></td></tr></table></figure><p>在模块 B 中调用该函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//模块B实现文件 moduleB.cpp</span><br><span class="line">#include&quot;moduleA.h&quot;</span><br><span class="line">foo(2,3);　</span><br></pre></td></tr></table></figure><p>实际上，<strong>在链接阶段，链接器会从模块 A 生成的目标文件 moduleA.obj 中找_foo_int_int 这样的符号，显然这是不可能找到的，因为 foo () 函数被编译成了_foo 的符号，因此会出现链接错误。</strong></p><p><strong>extern &quot;C&quot; 的使用要点总结</strong></p><p>1，可以是如下的单一语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; double sqrt(double);</span><br></pre></td></tr></table></figure><p>2，可以是复合语句，相当于复合语句中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">      double sqrt(double);</span><br><span class="line">      int min(int, int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，可以包含头文件，相当于头文件中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    ＃include &lt;cmath&gt;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure><ul><li>不可以将 extern “C” 添加在函数内部</li><li>如果函数有多个声明，可以都加 extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。</li><li>除 extern “C”, 还有 extern “FORTRAN” 等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内联函数和普通函数的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内联函数和普通函数的区别&quot;&gt;#&lt;/a&gt; 内联函数和普通函数的区别&lt;/h4&gt;
&lt;p&gt;省去函数调用开销&lt;/p&gt;
&lt;h4 id=&quot;c为什么支持函数重载c语言不支持&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="C++" scheme="https://flowerhai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>day18</title>
    <link href="https://flowerhai.github.io/2023/05/04/shuati/day18/"/>
    <id>https://flowerhai.github.io/2023/05/04/shuati/day18/</id>
    <published>2023-05-04T13:38:01.000Z</published>
    <updated>2023-05-04T13:38:22.182Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列">#</a> <a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><p>开个数组记录一下不重复，开一个哈希表避免结果里有重复元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; jud;</span><br><span class="line">    unordered_map &lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,  <span class="type">int</span> d, <span class="type">int</span> n, string r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == n &amp;&amp; m.<span class="built_in">count</span>(r) == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">            m[r] == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jud[i]) &#123;</span><br><span class="line">                r.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                jud[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s, d + <span class="number">1</span>, n, r);</span><br><span class="line">                r.<span class="built_in">pop_back</span>();</span><br><span class="line">                jud[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        jud.<span class="built_in">resize</span>(<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">        string r;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>(), r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-43-1~n-整数中-1-出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-43-1~n-整数中-1-出现的次数">#</a> <a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p>输入一个整数  <code>n</code>  ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。</p><p>例如，输入 12，1～12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mulk = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; n &gt;= mulk; ++k) &#123;</span><br><span class="line">            ans += (n / (mulk * <span class="number">10</span>)) * mulk + <span class="built_in">min</span>(<span class="built_in">max</span>(n % (mulk * <span class="number">10</span>) - mulk + <span class="number">1</span>, <span class="number">0LL</span>), mulk);</span><br><span class="line">            mulk *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="541-反转字符串-ii"><a class="markdownIt-Anchor" href="#541-反转字符串-ii">#</a> <a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串  <code>s</code>  和一个整数  <code>k</code> ，从字符串开头算起，每计数至  <code>2k</code>  个字符，就反转这  <code>2k</code>  字符中的前  <code>k</code>  个字符。</p><ul><li>如果剩余字符少于  <code>k</code>  个，则将剩余字符全部反转。</li><li>如果剩余字符小于  <code>2k</code>  但大于或等于  <code>k</code>  个，则反转前  <code>k</code>  个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; i += 2 * k) &#123;</span><br><span class="line">            reverse(s.begin() + i, s.begin() + min(i + k, n));</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-05-替换空格"><a class="markdownIt-Anchor" href="#剑指-offer-05-替换空格">#</a> <a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串  <code>s</code>  中的每个空格替换成 &quot;%20&quot;。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a class="markdownIt-Anchor" href="#151-反转字符串中的单词">#</a> <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><p>给你一个字符串  <code>s</code>  ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。 <code>s</code>  中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>** 注意：** 输入字符串  <code>s</code>  中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p>好几种写法，用了下双端队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span>) ++left;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">&#x27; &#x27;</span>) --right;</span><br><span class="line">        deque&lt;string&gt; d;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[left];</span><br><span class="line">            <span class="keyword">if</span> (word.<span class="built_in">size</span>() &amp;&amp; c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += c;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += d.<span class="built_in">front</span>();</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-38-字符串的排列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-38-字符串的排列&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/zi-fu-chuan-</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://flowerhai.github.io/2023/05/04/qmi/"/>
    <id>https://flowerhai.github.io/2023/05/04/qmi/</id>
    <published>2023-05-04T03:34:11.000Z</published>
    <updated>2023-05-04T03:34:31.463Z</updated>
    
    <content type="html"><![CDATA[<p>\875. 快速幂</p><p>给定 n  组 ai,bi,pi  ,  ,  ，对于每组数据，求出 abiimodpi    mod   的值。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含整数 n 。</p><p>接下来 n  行，每行包含三个整数 ai,bi,pi  ,  ,  。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>对于每组数据，输出一个结果，表示 abiimodpi    mod   的值。</p><p>每个结果占一行。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤1000001≤ ≤100000,<br>1≤ai,bi,pi≤2×1091≤  , ≤2×109</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 2 5</span><br><span class="line">4 3 9</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>快速幂，类似于二进制优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * t % p;</span><br><span class="line">        t = (<span class="type">long</span> <span class="type">long</span>) t * t % p;</span><br><span class="line">        k &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">qmi</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;\875. 快速幂&lt;/p&gt;
&lt;p&gt;给定 n  组 ai,bi,pi  ,  ,  ，对于每组数据，求出 abiimodpi    mod   的值。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#输入格式&quot;&gt;#&lt;</summary>
      
    
    
    
    
    <category term="快速幂" scheme="https://flowerhai.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>刷题day17</title>
    <link href="https://flowerhai.github.io/2023/05/03/shuati/day17/"/>
    <id>https://flowerhai.github.io/2023/05/03/shuati/day17/</id>
    <published>2023-05-03T13:43:00.000Z</published>
    <updated>2023-05-03T13:43:46.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-60-n个骰子的点数"><a class="markdownIt-Anchor" href="#剑指-offer-60-n个骰子的点数">#</a> <a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n 个骰子的点数</a></h4><p>把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure><p>Dp，找到状态转移方程就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">70</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i ++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">6</span>*i; j &gt;= i; j --) &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> cur = <span class="number">1</span>; cur &lt;= <span class="number">6</span>; cur ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - cur &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] += dp[j-cur];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> all = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= <span class="number">6</span> * n; i ++) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(dp[i] * <span class="number">1.0</span> / all);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润">#</a> <a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p>一个维护最大值，一个维护最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i]-m);</span><br><span class="line">            m = <span class="built_in">min</span>(m, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-66-构建乘积数组"><a class="markdownIt-Anchor" href="#剑指-offer-66-构建乘积数组">#</a> <a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p>给定一个数组  <code>A[0,1,…,n-1]</code> ，请构建一个数组  <code>B[0,1,…,n-1]</code> ，其中  <code>B[i]</code>  的值是数组  <code>A</code>  中除了下标  <code>i</code>  以外的元素的积，即  <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code> 。不能使用除法。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><p>各开一个数组记录左右乘积</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            l[i] = l[i<span class="number">-1</span>]*a[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            r[i] = r[i+<span class="number">1</span>]*a[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            b[i] *= l[i];</span><br><span class="line">            b[i] *= r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#剑指-offer-46-把数字翻译成字符串">#</a> <a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><p>爬楼梯进阶版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num); </span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="type">int</span> t = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>)    </span><br><span class="line">                    f[i] += f[i - <span class="number">2</span>];     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#剑指-offer-45-把数组排成最小的数">#</a> <a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p>排序就行，自定义一下排序规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">            string s1 = <span class="built_in">to_string</span>(n1), s2 = <span class="built_in">to_string</span>(n2);</span><br><span class="line">            <span class="built_in">return</span> (s1 + s2) &lt; (s2 + s1);</span><br><span class="line">        &#125;);</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) ret += <span class="built_in">to_string</span>(e);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-44-数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#剑指-offer-44-数字序列中某一位的数字">#</a> <a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p>数字以 0123456789101112131415… 的格式序列化到一个字符序列中。在这个序列中，第 5 位（从下标 0 开始计数）是 5，第 13 位是 1，第 19 位是 4，等等。</p><p>请写一个函数，求任意第 n 位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; (<span class="type">long</span>) d * count) &#123;</span><br><span class="line">            n -= d * count;</span><br><span class="line">            d++;</span><br><span class="line">            count *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start = (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> num = start + index / d;</span><br><span class="line">        <span class="type">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="type">int</span> digit = (num / (<span class="type">int</span>) (<span class="built_in">pow</span>(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-60-n个骰子的点数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-60-n个骰子的点数&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/nge-tou-zi</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day16</title>
    <link href="https://flowerhai.github.io/2023/04/30/shuati/day16/"/>
    <id>https://flowerhai.github.io/2023/04/30/shuati/day16/</id>
    <published>2023-04-30T14:40:16.000Z</published>
    <updated>2023-04-30T14:41:30.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#剑指-offer-33-二叉搜索树的后序遍历序列">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回  <code>true</code> ，否则返回  <code>false</code> 。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>注意下二叉搜索树的性质即可快速求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p ++;</span><br><span class="line">        <span class="type">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, i, m - <span class="number">1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, j - <span class="number">1</span>) &amp;&amp; (p == j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的大小顺序排列是：左中右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串">#</a> <a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>动态规划</p><p>哈希表 + 动态规划</p><p>开一个哈希表存上次出现的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        mp[s[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> j = mp[s[i]];</span><br><span class="line">                <span class="keyword">if</span> (i-j &gt; f[i<span class="number">-1</span>]) f[i] = f[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i] = i-j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])==<span class="number">0</span>) &#123;</span><br><span class="line">                f[i] = f[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-56-i-数组中数字出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-56-i-数组中数字出现的次数">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组  <code>nums</code>  里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O (n)，空间复杂度是 O (1)。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p>此题甚妙</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-33-二叉搜索树的后序遍历序列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-33-二叉搜索树的后序遍历序列&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法实现</title>
    <link href="https://flowerhai.github.io/2023/04/30/lru/"/>
    <id>https://flowerhai.github.io/2023/04/30/lru/</id>
    <published>2023-04-30T08:05:27.000Z</published>
    <updated>2023-04-30T08:05:55.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现lru算法"><a class="markdownIt-Anchor" href="#实现lru算法">#</a> 实现 LRU 算法</h3><p>LRU-least recently used - 最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</p><p>可以使用双向链表加哈希表</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现LRU缓存机制</span></span><br><span class="line"><span class="comment">//LRU-least recently used-最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_lru.<span class="built_in">count</span>(x)==<span class="number">0</span>) &#123; <span class="comment">//此事时没有这个key</span></span><br><span class="line">            <span class="keyword">if</span> (size_lru &lt; v) &#123;<span class="comment">//此时LRU未满</span></span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">                size_lru ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> front_node = node_lru.<span class="built_in">front</span>();</span><br><span class="line">                hash_lru.<span class="built_in">erase</span>(front_node);</span><br><span class="line">                node_lru.<span class="built_in">pop_front</span>();</span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//存在这个</span></span><br><span class="line">            node_lru.<span class="built_in">remove</span>(x);</span><br><span class="line">            node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash_lru[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = node_lru.<span class="built_in">back</span>();</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k:node_lru) cout&lt;&lt;k&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LRU</span>(<span class="type">int</span> x,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">v</span>(x), <span class="built_in">size_lru</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash_lru;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; node_lru;</span><br><span class="line">    <span class="type">int</span> size_lru;<span class="comment">//当前节点数量</span></span><br><span class="line">    <span class="type">int</span> v;<span class="comment">//容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">0 </span><br><span class="line">3 </span><br><span class="line">0 </span><br><span class="line">4 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">7 0 </span><br><span class="line">0 1 </span><br><span class="line">1 2 </span><br><span class="line">2 0 </span><br><span class="line">0 3 </span><br><span class="line">3 0 </span><br><span class="line">0 4 </span><br></pre></td></tr></table></figure><p>7<br>7 0<br>7 0 1<br>0 1 2<br>1 2 0<br>2 0 3<br>2 3 0<br>3 0 4</p><p>没问题，表现良好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现lru算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现lru算法&quot;&gt;#&lt;/a&gt; 实现 LRU 算法&lt;/h3&gt;
&lt;p&gt;LRU-least recently used - 最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内</summary>
      
    
    
    
    
    <category term="LRU算法实现" scheme="https://flowerhai.github.io/tags/LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://flowerhai.github.io/2023/04/29/weiyuansuan/"/>
    <id>https://flowerhai.github.io/2023/04/29/weiyuansuan/</id>
    <published>2023-04-29T14:56:35.000Z</published>
    <updated>2023-04-29T14:57:51.478Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1位运算概述"><a class="markdownIt-Anchor" href="#1位运算概述">#</a> 1. 位运算概述</h3><p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*、/) 都是叫位运算，即将符号位共同参与运算的运算。</p><p>口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 35;</span><br><span class="line">int b = 47;</span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure><p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">35:  0 0 1 0 0 0 1 1</span><br><span class="line">47:  0 0 1 0 1 1 1 1</span><br><span class="line">————————————————————</span><br><span class="line">82:  0 1 0 1 0 0 1 0</span><br></pre></td></tr></table></figure><p>所以，相比在代码中直接使用 (+、-、*、/) 运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。</p><h3 id="2位运算概览"><a class="markdownIt-Anchor" href="#2位运算概览">#</a> 2. 位运算概览</h3><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th><th style="text-align:left">运算规则</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">与</td><td style="text-align:left">两个位都为 1 时，结果才为 1</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">或</td><td style="text-align:left">两个位都为 0 时，结果才为 0</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">异或</td><td style="text-align:left">两个位相同为 0，相异为 1</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">取反</td><td style="text-align:left">0 变 1，1 变 0</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移</td><td style="text-align:left">各二进位全部左移若干位，高位丢弃，低位补 0</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移</td><td style="text-align:left">各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）</td></tr></tbody></table><h3 id="3按位与运算符"><a class="markdownIt-Anchor" href="#3按位与运算符">#</a> 3. 按位与运算符（&amp;）#</h3><p><strong>定义</strong>：参加运算的两个数据，按二进制位进行 &quot;与&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&amp;0=0  0&amp;1=0  1&amp;0=0  1&amp;1=1</span><br></pre></td></tr></table></figure><p>总结：两位同时为 1，结果才为 1，否则结果为 0。</p><p>例如：3&amp;5 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得 1。</p><p>注意：负数按补码形式参加按位与运算。</p><p><strong>与运算的用途：</strong></p><p>1）清零</p><p>如果想将一个单元清零，即使其全部二进制位为 0，只要与一个各位都为零的数值相与，结果为零。</p><p>2）取一个数的指定位</p><p>比如取数 X=1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位与运算（X&amp;Y=0000 1110）即可得到 X 的指定位。</p><p>3）判断奇偶</p><p>只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a &amp; 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。</p><p>4. 按位或运算符（|）</p><p>定义：参加运算的两个对象，按二进制位进行 &quot;或&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0|0=0  0|1=1  1|0=1  1|1=1</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为 1，其值为 1。</p><p>例如：3|5 即 0000 0011| 0000 0101 = 0000 0111，因此，3|5 的值得 7。</p><p>注意：负数按补码形式参加按位或运算。</p><p>或运算的用途：</p><p>1）常用来对一个数据的某些位设置为 1</p><p>比如将数 X=1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位或运算（X|Y=1010 1111）即可得到。</p><p>5. 异或运算符（^）</p><p>定义：参加运算的两个数据，按二进制位进行 &quot;异或&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0^0=0  0^1=1  1^0=1  1^1=0</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为 0，相异为 1。</p><p>异或的几条性质:</p><ul><li>1、交换律</li><li>2、结合律 (a<sup>b)</sup>c == a<sup>(b</sup>c)</li><li>3、对于任何数 x，都有 x<sup>x=0，x</sup>0=x</li><li>4、自反性: a<sup>b</sup>b=a^0=a;</li></ul><p>异或运算的用途：</p><p>1）翻转指定位</p><p>比如将数 X=1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行异或运算（X^Y=1010 0001）即可得到。</p><p>2）与 0 相异或值不变</p><p>例如：1010 1110 ^ 0000 0000 = 1010 1110</p><p>3）交换两个数</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例">#</a> 实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a != b)&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6. 取反运算符 (~)</p><p>定义：参加运算的一个数据，按二进制进行 &quot;取反&quot; 运算。</p><p>运算规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~1=0</span><br><span class="line">~0=1</span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将 0 变 1，1 变 0。</p><p>异或运算的用途：</p><p>1）使一个数的最低位为零</p><p>使 a 的最低位为 0，可以表示为：a &amp; <sub>1。</sub>1 的值为 1111 1111 1111 1110，再按 &quot;与&quot; 运算，最低位一定为 0。因为 &quot;~&quot; 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p><p>7. 左移运算符（&lt;&lt;）</p><p>定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。</p><p>设 a=1010 1110，a = a&lt;&lt; 2 将 a 的二进制位左移 2 位、右补 0，即得 a=1011 1000。</p><p>若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2。</p><p>8. 右移运算符（&gt;&gt;）</p><p>定义：将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。</p><p>例如：a=a&gt;&gt;2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以 2。</p><p>10. 复合赋值运算符</p><p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;=        例：a&amp;=b    相当于     a=a&amp;b</span><br><span class="line"></span><br><span class="line">|=        例：a|=b    相当于     a=a|b</span><br><span class="line"></span><br><span class="line">&gt;&gt;=      例：a&gt;&gt;=b   相当于     a=a&gt;&gt;b</span><br><span class="line"></span><br><span class="line">&lt;&lt;=      例：a&lt;&lt;=b     相当于      a=a&lt;&lt;b</span><br><span class="line"></span><br><span class="line">^=        例：a^=b    相当于   a=a^b</span><br></pre></td></tr></table></figure><p>运算规则：和前面讲的复合赋值运算符的运算规则相似。</p><p>不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p><p>以 &quot;与运算&quot; 为例说明如下：我们知道在 C 语言中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行 &quot;与运算&quot;，右端对齐后，左边不足的位依下面三种情况补足，</p><ul><li><p>1）如果整型数据为正数，左边补 16 个 0。</p></li><li><p>2）如果整型数据为负数，左边补 16 个 1。</p></li><li><p>3）如果整形数据为无符号数，左边也补 16 个 0。</p></li><li><p>如：long a=123；int b=1；计算 a&amp; b。</p></li><li></li><li><p>如：long a=123；int b=-1；计算 a&amp; b。</p></li><li><p>如：long a=123；unsigned intb=1；计算 a &amp; b。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1位运算概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1位运算概述&quot;&gt;#&lt;/a&gt; 1. 位运算概述&lt;/h3&gt;
&lt;p&gt;从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算 (+、-、*</summary>
      
    
    
    
    
    <category term="位运算" scheme="https://flowerhai.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题day15</title>
    <link href="https://flowerhai.github.io/2023/04/29/shuati/day15/"/>
    <id>https://flowerhai.github.io/2023/04/29/shuati/day15/</id>
    <published>2023-04-29T14:07:13.000Z</published>
    <updated>2023-04-29T14:07:41.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-13-机器人的运动范围"><a class="markdownIt-Anchor" href="#剑指-offer-13-机器人的运动范围">#</a> <a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>地上有一个 m 行 n 列的方格，从坐标  <code>[0,0]</code>  到坐标  <code>[m-1,n-1]</code>  。一个机器人从坐标  <code>[0, 0] </code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>将满足条件的格子置为 1，不满住的置为 0，然后对起点做一个 dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rx = <span class="number">0</span>, ry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            rx += x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            ry += y%<span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rx + ry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m,<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m[x][y] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        res ++;</span><br><span class="line">        m[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; m[x<span class="number">-1</span>][y]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span>&lt;m.<span class="built_in">size</span>() &amp;&amp; m[x+<span class="number">1</span>][y]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; m[x][y<span class="number">-1</span>]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(y+<span class="number">1</span>&lt;m[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; m[x][y+<span class="number">1</span>]==<span class="number">1</span>) <span class="built_in">dfs</span>(m, x, y+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j= <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">get_value</span>(i, j) &gt; k) a[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> a[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(a,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-14-ii-剪绳子-ii"><a class="markdownIt-Anchor" href="#剑指-offer-14-ii-剪绳子-ii">#</a> <a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><p>给你一根长度为  <code>n</code>  的绳子，请把绳子剪成整数长度的  <code>m</code>  段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为  <code>k[0],k[1]...k[m - 1]</code>  。请问  <code>k[0]*k[1]*...*k[m - 1]</code>  可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = n / <span class="number">3</span> - <span class="number">1</span>; a &gt; <span class="number">0</span>; a /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">            x = (x * x) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> rem * <span class="number">3</span> % p;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> rem * <span class="number">4</span> % p;</span><br><span class="line">        <span class="keyword">return</span> rem * <span class="number">6</span> % p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-16-数值的整数次方"><a class="markdownIt-Anchor" href="#剑指-offer-16-数值的整数次方">#</a> <a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="type">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-31-栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#剑指-offer-31-栈的压入-弹出序列">#</a> <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p>直接按照题意开整就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            st.<span class="built_in">emplace</span>(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == popped[j]) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-13-机器人的运动范围&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-13-机器人的运动范围&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/ji-qi-re</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>基础知识复习</title>
    <link href="https://flowerhai.github.io/2023/04/29/muduo/muduo1/"/>
    <id>https://flowerhai.github.io/2023/04/29/muduo/muduo1/</id>
    <published>2023-04-29T12:47:00.000Z</published>
    <updated>2023-04-29T12:47:25.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识复习"><a class="markdownIt-Anchor" href="#基础知识复习">#</a> 基础知识复习</h2><h3 id="阻塞-非阻塞-同步-异步"><a class="markdownIt-Anchor" href="#阻塞-非阻塞-同步-异步">#</a> 阻塞、非阻塞、同步、异步</h3><p>典型的一次数据 IO 包含两个阶段：数据准备、数据读写</p><h4 id="数据准备"><a class="markdownIt-Anchor" href="#数据准备">#</a> 数据准备：</h4><ul><li><p>阻塞</p><p>调用 IO 方法的线程进入阻塞状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = recv(sockfd, buf, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果 sockfd 没有数据（默认阻塞)，此时就回阻塞在这里。</p></li><li><p>非阻塞</p><p>不会改变线程的状态，通过返回值判断</p><p>如果非阻塞，会直接返回。(size == -1 &amp;&amp; errno == EAGAIN)</p></li></ul><h4 id="数据读写io的同步和异步"><a class="markdownIt-Anchor" href="#数据读写io的同步和异步">#</a> 数据读写：(IO 的同步和异步)</h4><ul><li><p>同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = recv(sockfd, buf, <span class="number">1024</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果数据没有全部写到缓冲区中，那么将阻塞，且需自己写入缓冲区</p></li><li><p>异步</p><p>异步 IO 接口的时候，当系统 sigio<strong> 通知</strong>的时候，buf 的数据已经准备好了。</p><p>（aio_read, aio_write)</p></li></ul><p>Node.js 基于异步非阻塞模式下的高性能服务器</p><p>在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用特殊的 API 才是异步 IO。</p><h4 id="业务层面的一个逻辑处理是同步还是异步"><a class="markdownIt-Anchor" href="#业务层面的一个逻辑处理是同步还是异步">#</a> 业务层面的一个逻辑处理是同步还是异步？</h4><h5 id="同步"><a class="markdownIt-Anchor" href="#同步">#</a> 同步：</h5><p>A 操作等待 B 操作完成事情，得到返回，继续处理</p><h5 id="异步"><a class="markdownIt-Anchor" href="#异步">#</a> 异步：</h5><p>A 操作告诉 B 操作它感兴趣的事件以及通知方式，A 操作继续自己的业务逻辑，等待 B 监听到响应事件发生后，B 会通知 A，A 开始数据处理逻辑。</p><p>一个典型的网络 IO 接口调用，分为两个阶段，分别是 &quot;数据就绪&quot; 和 &quot;数据读写&quot;， 数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结：</h4><p>同步表示 A 向 B 请求调用一个网络 IO 接口时，数据读写都是由请求方 A 来自己完成的；异步表示 A 向 B 请求调用一个网络 IO 接口时，向 B 传入请求的事件以及事件发生时统治的方式，A 就可以处理其他逻辑了，当 B 监听到事件处理完成后，会用实现约定好的通知方式，通知 A 处理结果</p><h3 id="unixlinux上的五种io模型"><a class="markdownIt-Anchor" href="#unixlinux上的五种io模型">#</a> Unix/Linux 上的五种 IO 模型</h3><ul><li><p>阻塞 blocking</p></li><li><p>非阻塞 non-blocking</p></li><li><p>IO 复用 IO multiplexing</p></li><li><p>信号驱动 signal-driven</p></li><li><p>异步 asynchronous</p></li></ul><h3 id="网络服务器设计"><a class="markdownIt-Anchor" href="#网络服务器设计">#</a> 网络服务器设计</h3><p>one loop pre thread is usually a good model</p><h3 id="reactor模型"><a class="markdownIt-Anchor" href="#reactor模型">#</a> Reactor 模型</h3><p>Event 事件，Reactor 反应堆，Demultiplex 事件分发器，Eventhandler 事件分发器</p><h3 id="epoll"><a class="markdownIt-Anchor" href="#epoll">#</a> epoll</h3><h4 id="select和poll的缺点"><a class="markdownIt-Anchor" href="#select和poll的缺点">#</a> select 和 poll 的缺点</h4><h5 id="select的缺点"><a class="markdownIt-Anchor" href="#select的缺点">#</a> select 的缺点：</h5><p>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是 1024，当然可以更改数量，但由于 select 采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在 linux 内核头文件中，有 这样的定义：#define_FD_SETSIZE 1024 __</p><p>2、内核 / 用户空间内存拷贝问题，select 需要复制大量的句柄数据结构，产生巨大的开销</p><p>3、select 返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</p><p>4、select 的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行 IO 操作， 那么之后每次 select 调用还是会将这些文件描述符通知进程</p><p>相比 select 模型，poll 使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依 然存在。</p><p>以 select 模型为例，假设我们的服务器需要支持 100 万的并发连接，则在__FD_SETSIZE 为 1024 的情况 下，则我们至少需要开辟 1k 个进程才能实现 100 万的并发连接。除了进程间上下文切换的时间消耗外， 从内核 / 用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于 select 模型的 服务器程序，要达到 100 万级别的并发访问，是一个很难完成的任务。</p><h5 id="epoll原理以及优势"><a class="markdownIt-Anchor" href="#epoll原理以及优势">#</a> epoll 原理以及优势</h5><p>epoll 的实现机制与 select/poll 机制完全不同，它们的缺点在 epoll 上不复存在。</p><p>设想一下如下场景：有 100 万个客户端同时与一个服务器进程保持着 TCP 连接。而每一时刻，通常只有 几百上千个 TCP 连接是活跃的 (事实上大部分场景都是这种情况)。如何实现这样的高并发？ 在 select/poll 时代，服务器进程每次都把这 100 万个连接告诉操作系统（从用户态复制句柄数据结构到 内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据复制到用 户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll 一般 只能处理几千的并发连接。</p><p>epoll 的设计和实现与 select 完全不同。epoll 通过在 Linux 内核中申请一个简易的文件系统（文件系统一 般用什么数据结构实现？B + 树，磁盘 IO 消耗低，效率很高）。把原先的 select/poll 调用分成以下 3 个部 分：</p><ul><li>调用 epoll_create () 建立一个 epoll 对象（在 epoll 文件系统中为这个句柄对象分配资源）</li><li>调用 epoll_ctl 向 epoll 对象中添加这 100 万个连接的套接字</li><li>调用 epoll_wait 收集发生的事件的 fd 资源</li></ul><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个 epoll 对象，然后在需要的时候向这 个 epoll 对象中添加或者删除事件。同时，epoll_wait 的效率也非常高，因为调用 epoll_wait 时，并没有 向操作系统复制这 100 万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><p>epoll_create 在内核上创建的 eventpoll 结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line"><span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="lt模式"><a class="markdownIt-Anchor" href="#lt模式">#</a> LT 模式</h4><p>内核数据没被读完，就会一直上报数据。</p><h4 id="et模式"><a class="markdownIt-Anchor" href="#et模式">#</a> ET 模式</h4><p>内核数据只上报一次。</p><h4 id="muduo采用的是lt"><a class="markdownIt-Anchor" href="#muduo采用的是lt">#</a> muduo 采用的是 LT</h4><ul><li>不会丢失数据或者消息 应用没有读取完数据，内核是会不断上报的</li><li>低延迟处理 每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量 过大而影响其他连接处理消息</li><li>跨平台处理 像 select 一样可以跨平台使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础知识复习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础知识复习&quot;&gt;#&lt;/a&gt; 基础知识复习&lt;/h2&gt;
&lt;h3 id=&quot;阻塞-非阻塞-同步-异步&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#阻塞-非</summary>
      
    
    
    
    
    <category term="muduo设计" scheme="https://flowerhai.github.io/tags/muduo%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>智能指针简单设计</title>
    <link href="https://flowerhai.github.io/2023/04/29/smart-pointers/ptr/"/>
    <id>https://flowerhai.github.io/2023/04/29/smart-pointers/ptr/</id>
    <published>2023-04-29T12:45:29.000Z</published>
    <updated>2023-04-29T12:46:23.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针">#</a> 智能指针</h3><h4 id="关于智能指针的设计"><a class="markdownIt-Anchor" href="#关于智能指针的设计">#</a> 关于智能指针的设计</h4><p>智能指针是为了方便的智能管理内存资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//智能指针 保证能做到资源的自动释放！！！</span></span><br><span class="line"><span class="comment">//利用栈上的对象出作用域自动析构</span></span><br><span class="line"><span class="comment">//不能是堆上</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;<span class="keyword">delete</span> ptr;&#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不带引用计数的智能指针"><a class="markdownIt-Anchor" href="#不带引用计数的智能指针">#</a> 不带引用计数的智能指针</h4><p>如果我们这样：</p><p>smart_ptr<int> p1(new int);<br>smart_ptr<int> p2(p1);</p><p>会发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(): double free detected in tcache 2</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>原因是为拷贝构造默认是一个浅拷贝，相当于对同一份资源释放了两次。</p><h5 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法">#</a> 解决方法</h5><p>1）可以重新定义拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;<span class="keyword">delete</span> ptr;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src) &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">T</span>(*src.ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时运行就不会出错</p><p>2）禁用拷贝构造，即 (unique_ptr)</p><p>保持独占性即可。</p><p>3）当然还有其他的方法，不再赘述，会有安全性的问题</p><h4 id="带引用计数的智能指针设计"><a class="markdownIt-Anchor" href="#带引用计数的智能指针设计">#</a> 带引用计数的智能指针设计</h4><p>加一个计数的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr_cnt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr_cnt</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_cnt</span><span class="params">()</span> </span>&#123; cnt++;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">subtract_cnt</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> --cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smart_ptr</span>(T* mptr = <span class="literal">nullptr</span>):<span class="built_in">ptr</span>(mptr) &#123;</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="built_in">smart_ptr_cnt</span>&lt;T&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == cnt-&gt;<span class="built_in">subtract_cnt</span>()) <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src): <span class="built_in">ptr</span>(src.ptr), <span class="built_in">cnt</span>(src.cnt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) cnt-&gt;<span class="built_in">add_cnt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> smart_ptr&lt;T&gt; &amp;src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == cnt-&gt;<span class="built_in">subtract_cnt</span>()) <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = src.ptr;</span><br><span class="line">        cnt = src.cnt;</span><br><span class="line">        cnt-&gt;<span class="built_in">add_cnt</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// smart_ptr(const smart_ptr&lt;T&gt; &amp;src) = delete;</span></span><br><span class="line">    <span class="comment">// smart_ptr&lt;T&gt;&amp; operator = (const smart_ptr&lt;T&gt; &amp;) = delete;</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *ptr;&#125;;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> ptr;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">    <span class="comment">//std::atomic&lt;int&gt; cnt;</span></span><br><span class="line">    smart_ptr_cnt&lt;T&gt; *cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;智能指针&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#智能指针&quot;&gt;#&lt;/a&gt; 智能指针&lt;/h3&gt;
&lt;h4 id=&quot;关于智能指针的设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于智能指针的设计&quot;&gt;#&lt;</summary>
      
    
    
    
    
    <category term="智能指针" scheme="https://flowerhai.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>刷题day14</title>
    <link href="https://flowerhai.github.io/2023/04/29/shuati/day14/"/>
    <id>https://flowerhai.github.io/2023/04/29/shuati/day14/</id>
    <published>2023-04-29T02:35:30.000Z</published>
    <updated>2023-04-29T02:37:01.062Z</updated>
    
    <content type="html"><![CDATA[<p>昨天忘发了</p><h4 id="剑指-offer-12-矩阵中的路径"><a class="markdownIt-Anchor" href="#剑指-offer-12-矩阵中的路径">#</a> <a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><p>给定一个  <code>m x n</code>  二维字符网格  <code>board</code>  和一个字符串单词  <code>word</code>  。如果  <code>word</code>  存在于网格中，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>dfs，没什么难的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        rows = board.<span class="built_in">size</span>();</span><br><span class="line">        cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= rows || i &lt; <span class="number">0</span> || j &gt;= cols || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || </span><br><span class="line">                      <span class="built_in">dfs</span>(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-47-礼物的最大价值"><a class="markdownIt-Anchor" href="#剑指-offer-47-礼物的最大价值">#</a> <a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p>没啥难度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = grid.<span class="built_in">size</span>(), r = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(l, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r, <span class="number">0</span>));</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; r; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">0</span>) res[i][j] = <span class="built_in">max</span>(res[i<span class="number">-1</span>][j], res[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) res[i][j] = res[i<span class="number">-1</span>][j]+ grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) res[i][j] = res[i][j<span class="number">-1</span>]+ grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-047-二叉树剪枝"><a class="markdownIt-Anchor" href="#剑指-offer-ii-047-二叉树剪枝">#</a> <a href="https://leetcode.cn/problems/pOCWxh/">剑指 Offer II 047. 二叉树剪枝</a></h4><p>给定一个二叉树 <strong>根节点</strong>  <code>root</code>  ，树的每个节点的值要么是  <code>0</code> ，要么是  <code>1</code> 。请剪除该二叉树中所有节点的值为  <code>0</code>  的子树。</p><p>节点  <code>node</code>  的子树为  <code>node</code>  本身，以及所有  <code>node</code>  的后代。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,0,0,1]</span><br><span class="line">输出: [1,null,0,null,1] </span><br><span class="line">解释: </span><br><span class="line">只有红色节点满足条件“所有不包含 1 的子树”。</span><br><span class="line">右图为返回的答案。</span><br></pre></td></tr></table></figure><p>另外定义一个函数判断一下是否全位 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">iszero</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == <span class="number">0</span> &amp;&amp; <span class="built_in">iszero</span>(root-&gt;left) &amp;&amp; <span class="built_in">iszero</span>(root-&gt;right)) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || <span class="built_in">iszero</span>(root)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">pruneTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">pruneTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-004-只出现一次的数字"><a class="markdownIt-Anchor" href="#剑指-offer-ii-004-只出现一次的数字">#</a> <a href="https://leetcode.cn/problems/WGki4K/">剑指 Offer II 004. 只出现一次的数字 </a></h4><p>给你一个整数数组  <code>nums</code>  ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 ** 三次 。** 请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,1,0,1,100]</span><br><span class="line">输出：100</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] != nums[<span class="number">1</span>] &amp;&amp; nums[<span class="number">1</span>] == nums[<span class="number">2</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>] != nums[nums.<span class="built_in">size</span>()<span class="number">-2</span>] &amp;&amp; nums[nums.<span class="built_in">size</span>()<span class="number">-2</span>] == nums[nums.<span class="built_in">size</span>()<span class="number">-3</span>]) <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i<span class="number">-1</span>] &amp;&amp; nums[i] != nums[i+<span class="number">1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-07-重建二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-07-重建二叉树">#</a> <a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++)</span><br><span class="line">            dic[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(<span class="number">0</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preorder;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dic;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;                        <span class="comment">// 递归终止</span></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="type">int</span> i = dic[preorder[root]];                            <span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        node-&gt;left = <span class="built_in">recur</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        node-&gt;right = <span class="built_in">recur</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;                                            <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点意思这题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天忘发了&lt;/p&gt;
&lt;h4 id=&quot;剑指-offer-12-矩阵中的路径&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-12-矩阵中的路径&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>二维vector初始化</title>
    <link href="https://flowerhai.github.io/2023/04/27/some-tips/ve/"/>
    <id>https://flowerhai.github.io/2023/04/27/some-tips/ve/</id>
    <published>2023-04-27T14:03:03.000Z</published>
    <updated>2023-04-27T14:04:00.397Z</updated>
    
    <content type="html"><![CDATA[<p>二维 vector 初始化</p><p>今天写题的时候遇到一种情况，二维 vector 初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(l, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>在已知维度的前提下，这种初始化方式就挺不错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二维 vector 初始化&lt;/p&gt;
&lt;p&gt;今天写题的时候遇到一种情况，二维 vector 初始化。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    
    <category term="小tips" scheme="https://flowerhai.github.io/tags/%E5%B0%8Ftips/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者练习题</title>
    <link href="https://flowerhai.github.io/2023/04/27/some-tips/con-pro/"/>
    <id>https://flowerhai.github.io/2023/04/27/some-tips/con-pro/</id>
    <published>2023-04-27T09:25:40.000Z</published>
    <updated>2023-04-27T13:58:05.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者消费者练习题"><a class="markdownIt-Anchor" href="#生产者消费者练习题">#</a> 生产者消费者练习题</h3><p>线程 A 每隔 10~200ms 按顺序生成 1-100 的数字，放入队列中</p><p>三个线程 B,C,D 即时消费这些数据，线程 B 打印所有被 2 整除的数，线程 C 打印所有被 3 整除的数，线程 D 打印其他数。</p><p>且打印出来的数字得有序</p><p>刷到牛友分享的一道面试题，于是随手做一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line">std::mutex mutex_;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(i);</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0.2</span>);</span><br><span class="line">        i ++;</span><br><span class="line">        i %= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cv.notify_all();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者B线程函数，打印所有被2整除的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerB: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者C线程函数，打印所有被3整除的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerC: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者D线程函数，打印其他数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; x%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerD: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g++ pruduct_cumsor.cpp -o a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动生产者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">consumerB_thread</span><span class="params">(consumerB)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerC_thread</span><span class="params">(consumerC)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerD_thread</span><span class="params">(consumerD)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerB_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerC_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerD_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumerD: 1</span><br><span class="line">consumerB: 2</span><br><span class="line">consumerC: 3</span><br><span class="line">consumerB: 4</span><br><span class="line">consumerD: 5</span><br><span class="line">consumerC: 6</span><br><span class="line">consumerD: 7</span><br><span class="line">consumerB: 8</span><br><span class="line">consumerC: 9</span><br><span class="line">consumerB: 10</span><br><span class="line">consumerD: 11</span><br><span class="line">consumerB: 12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出没啥问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;生产者消费者练习题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#生产者消费者练习题&quot;&gt;#&lt;/a&gt; 生产者消费者练习题&lt;/h3&gt;
&lt;p&gt;线程 A 每隔 10~200ms 按顺序生成 1-100 的数字，放入队列中&lt;/p&gt;
&lt;p&gt;三个线程</summary>
      
    
    
    
    
    <category term="生产者消费者" scheme="https://flowerhai.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>刷题day13</title>
    <link href="https://flowerhai.github.io/2023/04/27/shuati/day13/"/>
    <id>https://flowerhai.github.io/2023/04/27/shuati/day13/</id>
    <published>2023-04-27T06:49:26.000Z</published>
    <updated>2023-04-27T06:49:53.649Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-20-表示数值的字符串"><a class="markdownIt-Anchor" href="#剑指-offer-20-表示数值的字符串">#</a> <a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个  <code>'e'</code>  或  <code>'E'</code>  ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（ <code>'+'</code>  或  <code>'-'</code> ）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点  <code>'.'</code></li><li>至少一位数字，后面跟着一个点  <code>'.'</code>  ，后面再跟着至少一位数字</li><li>一个点  <code>'.'</code>  ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（ <code>'+'</code>  或  <code>'-'</code> ）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>吐血，本来还想着是否有什么算法可以求解，解决直接来一个有限状态机，算了这种题，再次碰见类似的估计还是想不出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CharType</span> &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">CharType <span class="title">toCharType</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_SPACE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                STATE_INITIAL, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_INITIAL&#125;,</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_INT_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INT_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INTEGER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT_WITHOUT_INT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_FRACTION,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_EXP_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_NUMBER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_END, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        State st = STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            CharType typ = <span class="built_in">toCharType</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (transfer[st].<span class="built_in">find</span>(typ) == transfer[st].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st = transfer[st][typ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-17-打印从1到最大的n位数"><a class="markdownIt-Anchor" href="#剑指-offer-17-打印从1到最大的n位数">#</a> <a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从 1 到最大的 n 位数</a></h4><p>输入数字  <code>n</code> ，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure><p>很简单的一道题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">            r *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; r; i ++) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-14-i-剪绳子"><a class="markdownIt-Anchor" href="#剑指-offer-14-i-剪绳子">#</a> <a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><p>给你一根长度为  <code>n</code>  的绳子，请把绳子剪成整数长度的  <code>m</code>  段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为  <code>k[0],k[1]...k[m-1]</code>  。请问  <code>k[0]*k[1]*...*k[m-1]</code>  可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><p>此题动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dp[3] = 2;</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">max</span>(<span class="number">0</span>, dp[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j*(i-j), j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-40-最小的k个数"><a class="markdownIt-Anchor" href="#剑指-offer-40-最小的k个数">#</a> <a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的 k 个数</a></h4><p>输入整数数组  <code>arr</code>  ，找出其中最小的  <code>k</code>  个数。例如，输入 4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>排序…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) res.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-55-ii-平衡二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-55-ii-平衡二叉树">#</a> <a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong></p><p>给定二叉树  <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回  <code>true</code>  。</p><p>对每个节点都判断一下是否满足，随后看一下子节点是否满足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="built_in">return</span> ((<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right))*(<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right)) &lt;= <span class="number">1</span>) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-27-二叉树的镜像"><a class="markdownIt-Anchor" href="#剑指-offer-27-二叉树的镜像">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p><code>   4  /  \ 2   7 / \  / \1  3 6  9</code> <br> 镜像输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4  /  \ 7   2 / \  / \9  6 3  1</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p>没什么好说的，直接翻转就完事了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="built_in">mirror</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">mirror</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">mirror</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-68-i-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#剑指-offer-68-i-二叉搜索树的最近公共祖先">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* ancestor = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-089-房屋偷盗"><a class="markdownIt-Anchor" href="#剑指-offer-ii-089-房屋偷盗">#</a> <a href="https://leetcode.cn/problems/Gu0c2T/">剑指 Offer II 089. 房屋偷盗</a></h4><p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组  <code>nums</code>  ，请计算 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        res[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="number">0</span>, res[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res[i] = <span class="built_in">max</span>(res[i<span class="number">-1</span>], res[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">            r = <span class="built_in">max</span>(r, res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-20-表示数值的字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-20-表示数值的字符串&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/biao-shi</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day12</title>
    <link href="https://flowerhai.github.io/2023/04/25/shuati/day12/"/>
    <id>https://flowerhai.github.io/2023/04/25/shuati/day12/</id>
    <published>2023-04-25T03:57:39.000Z</published>
    <updated>2023-04-25T03:58:14.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-57-和为s的两个数字"><a class="markdownIt-Anchor" href="#剑指-offer-57-和为s的两个数字">#</a> <a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为 s 的两个数字</a></h4><p>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (slow &lt; fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] &gt; target) fast --;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] &lt; target) slow ++;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] == target) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[slow]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[fast]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-26-树的子结构"><a class="markdownIt-Anchor" href="#剑指-offer-26-树的子结构">#</a> <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)</p><p>B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。</p><p>例如:<br> 给定的树 A:</p><p><code>   3  / \  4  5 / \ 1  2</code> <br> 给定的树 B：</p><p><code>  4  / 1</code> <br> 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>递归判断呗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">iszi</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!A ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iszi</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">iszi</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (A != nullptr &amp;&amp; !B) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (!A || A != <span class="literal">nullptr</span> &amp;&amp; !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">iszi</span>(A, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-57-ii-和为s的连续正数序列"><a class="markdownIt-Anchor" href="#剑指-offer-57-ii-和为s的连续正数序列">#</a> <a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为 s 的连续正数序列</a></h4><p>输入一个正整数  <code>target</code>  ，输出所有和为  <code>target</code>  的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; target; i ++) &#123;</span><br><span class="line">            cnt += i;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (cnt == target) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">                <span class="comment">//return true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; target) &#123;</span><br><span class="line">                <span class="comment">//return false;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; target; i ++) &#123;</span><br><span class="line">            <span class="built_in">get</span>(i, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上来直接暴力了一下，发现超时了</p><p>随后想如何优化，可以用滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">            rr += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) &gt; target) l ++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) &lt; target) r ++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) == target) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) re.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(re);</span><br><span class="line">                l ++;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-58-ii-左旋转字符串"><a class="markdownIt-Anchor" href="#剑指-offer-58-ii-左旋转字符串">#</a> <a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串 &quot;abcdefg&quot; 和数字 2，该函数将返回左旋转两位得到的结果 &quot;cdefgab&quot;。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p>没啥难度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        n %= len;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-32-i-从上到下打印二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-32-i-从上到下打印二叉树">#</a> <a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br> 给定二叉树:  <code>[3,9,20,null,null,15,7]</code> ,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><p>层序遍历而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-04-二维数组中的查找"><a class="markdownIt-Anchor" href="#剑指-offer-04-二维数组中的查找">#</a> <a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target =  <code>5</code> ，返回  <code>true</code> 。</p><p>给定 target =  <code>20</code> ，返回  <code>false</code> 。</p><p>真是烧脑筋，想了又想，还是得结合这个图长得样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-57-和为s的两个数字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-57-和为s的两个数字&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/he-wei-s</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>实现线程安全的懒汉单例模式</title>
    <link href="https://flowerhai.github.io/2023/04/25/some-tips/danli/"/>
    <id>https://flowerhai.github.io/2023/04/25/some-tips/danli/</id>
    <published>2023-04-25T00:41:36.000Z</published>
    <updated>2023-04-25T00:42:43.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现线程安全的懒汉单例模式并定义一个函数获取单例地址"><a class="markdownIt-Anchor" href="#实现线程安全的懒汉单例模式并定义一个函数获取单例地址">#</a> 实现线程安全的懒汉单例模式并定义一个函数获取单例地址</h3><p>昨天面试居然没实现出来，痛定思痛，今天好好写一遍。</p><p>创建这个单例类需要使用静态变量，利用了静态变量的一些性质，静态变量在整个代码运行周期内只会定义一次。</p><p><strong>对于 static 静态局部变量的初始化，编译器会自动对它的初始化进行加锁和解锁控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single *<span class="title">get_single</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Single single_only;</span><br><span class="line">        <span class="keyword">return</span> &amp;single_only;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_dizhi</span><span class="params">(Single *a)</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;create victory&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Single *ah = Single::<span class="built_in">get_single</span>();</span><br><span class="line">    ah-&gt;<span class="built_in">get_dizhi</span>(ah);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create victory</span><br><span class="line">0x560ecd8d9152</span><br><span class="line">0x560ecd8d9152</span><br><span class="line">0x560ecd8d9152</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现线程安全的懒汉单例模式并定义一个函数获取单例地址&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现线程安全的懒汉单例模式并定义一个函数获取单例地址&quot;&gt;#&lt;/a&gt; 实现线程安全的懒汉单例模式并定义一个函数获取单例地址&lt;/h3&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://flowerhai.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="线程安全的懒汉单例模式" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>某厂面试(被薄纱)</title>
    <link href="https://flowerhai.github.io/2023/04/24/mianshi/mianshi/"/>
    <id>https://flowerhai.github.io/2023/04/24/mianshi/mianshi/</id>
    <published>2023-04-24T12:39:39.000Z</published>
    <updated>2023-04-24T12:43:40.852Z</updated>
    
    <content type="html"><![CDATA[<p>怎么这样捏，太紧张了，很多东西都没想起来</p><p>自我介绍开场</p><h4 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h4><h4 id="智能指针熟悉吗介绍下智能指针"><a class="markdownIt-Anchor" href="#智能指针熟悉吗介绍下智能指针">#</a> 智能指针熟悉吗，介绍下智能指针</h4><p>智能指针（Smart Pointer）是一种 C++ 中的类，它的主要作用是管理动态分配的内存资源，从而避免内存泄漏和野指针等常见的内存安全问题。</p><p>智能指针通过重载指针操作符，提供与原生指针类似的使用方式，但其具有以下几个重要的特点：</p><ol><li>自动内存管理：智能指针会在其生命周期结束时自动释放其所管理的内存资源，从而避免了内存泄漏的风险。</li><li>所有权转移：智能指针支持所有权转移，即可以将一个智能指针的所有权转移给另一个智能指针，从而避免了多个指针同时管理同一块内存的问题。</li><li>引用计数：智能指针通常会维护一个引用计数器，用于记录有多少个智能指针共享同一块内存。当引用计数器减为 0 时，智能指针会自动释放其所管理的内存资源。</li><li>类型安全：智能指针可以防止类型不匹配的错误，从而提高程序的稳定性和安全性。</li></ol><h4 id="智能指针是为了解决什么问题提出来的"><a class="markdownIt-Anchor" href="#智能指针是为了解决什么问题提出来的">#</a> 智能指针是为了解决什么问题提出来的</h4><h4 id="为什么会有unique_ptr"><a class="markdownIt-Anchor" href="#为什么会有unique_ptr">#</a> 为什么会有 unique_ptr</h4><p>unique_ptr 是一种独占式智能指针，它的主要特点是只能有一个指针拥有它所管理的内存资源。unique_ptr 的出现主要是为了解决动态内存分配和释放过程中的一些常见问题，具有以下几个优点：</p><ol><li>防止内存泄漏：unique_ptr 能够确保在其生命周期结束时自动释放所管理的内存资源，从而避免了内存泄漏的风险。</li><li>防止多个指针同时访问同一块内存：由于 unique_ptr 是独占式的，即只能有一个指针拥有它所管理的内存资源，因此可以有效避免多个指针同时访问同一块内存的问题。</li><li>支持移动语义：unique_ptr 支持移动语义，即可以将其所有权转移给另一个 unique_ptr 对象，从而避免了显式内存管理过程中的复制和赋值问题。</li><li>更好的性能：unique_ptr 相比原生指针可以更好地支持现代 C++ 的一些高级特性，例如使用 RAII（Resource Acquisition Is Initialization）技术和模板元编程等。</li></ol><p>总之，unique_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以有效避免内存泄漏和野指针等常见问题。在编写 C</ins> 程序时，使用 unique_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="为什么会有shared_ptr"><a class="markdownIt-Anchor" href="#为什么会有shared_ptr">#</a> 为什么会有 shared_ptr</h4><p>shared_ptr 是一种共享式智能指针，它可以实现多个指针共享同一块内存资源，具有以下优点：</p><ol><li>引用计数机制：shared_ptr 会维护一个引用计数器，用于记录有多少个 shared_ptr 共享同一块内存。当引用计数器减为 0 时，shared_ptr 会自动释放其所管理的内存资源，从而避免了内存泄漏的风险。</li><li>所有权转移：shared_ptr 支持所有权转移，即可以将一个 shared_ptr 的所有权转移给另一个 shared_ptr，从而避免了多个指针同时管理同一块内存的问题。</li><li>方便使用：shared_ptr 与原生指针类似，可以使用普通的指针操作符和普通的函数调用方式，非常方便易用。</li><li>高效性能：shared_ptr 采用的是 “写时复制”（copy-on-write）机制，即只有在多个 shared_ptr 共享同一块内存资源时才进行复制，从而提高了内存和性能的效率。</li><li>支持自定义删除器：shared_ptr 支持自定义删除器（deleter），可以通过自定义删除器来控制内存资源的释放方式，增加了灵活性和可扩展性。</li></ol><p>总之，shared_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以实现多个指针共享同一块内存资源，并且能够自动管理内存资源，避免了内存泄漏和野指针等常见问题。在编写 C</ins> 程序时，使用 shared_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="为什么会有weak_ptr"><a class="markdownIt-Anchor" href="#为什么会有weak_ptr">#</a> 为什么会有 weak_ptr</h4><p>weak_ptr 是一种弱引用智能指针，它用于解决 shared_ptr 的循环引用问题。当两个或多个对象通过 shared_ptr 相互引用时，可能会形成一个环形引用，从而导致内存泄漏的问题。为了解决这个问题，C++11 引入了 weak_ptr，它具有以下优点：</p><ol><li>弱引用：weak_ptr 只是对所管理的对象的一个弱引用，它不会增加引用计数，也不会影响对象的生命周期。因此，当 shared_ptr 对象释放了它所管理的内存资源时，weak_ptr 并不会导致内存泄漏。</li><li>防止循环引用：当两个或多个对象通过 shared_ptr 相互引用时，可以将其中的某些指针替换为 weak_ptr，从而避免形成循环引用，减少内存泄漏的风险。</li><li>空指针检查：通过 lock () 函数可以检查所管理的对象是否存在，如果对象已经被释放，则返回一个空的 shared_ptr，从而避免了使用已经释放的内存资源的问题。</li></ol><p>总之，weak_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以有效避免 shared_ptr 的循环引用问题，并且能够检查所管理的对象是否存在，避免了使用已经释放的内存资源的问题。在编写 C</ins> 程序时，使用 weak_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="智能指针底层是如何实现的"><a class="markdownIt-Anchor" href="#智能指针底层是如何实现的">#</a> 智能指针底层是如何实现的</h4><h4 id="除了计数还有其他的什么解决方法吗"><a class="markdownIt-Anchor" href="#除了计数还有其他的什么解决方法吗">#</a> 除了计数，还有其他的什么解决方法吗</h4><p>除了引用计数，还有其他一些方法可以解决循环引用的问题，例如：</p><ol><li>弱回调：可以使用回调函数来避免循环引用。当对象之间需要相互引用时，可以将其中一个对象作为回调函数的参数传递给另一个对象，并在需要释放内存时，调用回调函数释放所管理的内存资源。这种方式可以避免引用计数的问题，但是需要手动管理回调函数的注册和调用，比较繁琐。</li><li>其他智能指针：除了 shared_ptr 和 weak_ptr，还有其他一些智能指针可以用于管理内存资源，例如 unique_ptr 和 auto_ptr。这些指针不支持循环引用，因此可以用于避免循环引用的问题。但是需要注意，使用 unique_ptr 和 auto_ptr 时需要确保对象之间不存在循环引用。</li><li>弱化对象之间的关系：可以通过重新设计对象之间的关系，将原本相互引用的关系弱化，从而避免循环引用的问题。例如，可以将对象之间的关系转化为单向依赖关系，或者使用事件机制来解耦对象之间的依赖关系。</li></ol><p>总之，除了引用计数之外，还有其他一些方法可以用于解决循环引用的问题。在设计和实现程序时，应该根据具体的需求和场景选择合适的方法，避免出现内存泄漏和野指针等问题。</p><h4 id="介绍下循环引用问题以及如何用weak_ptr解决循环引用问题的"><a class="markdownIt-Anchor" href="#介绍下循环引用问题以及如何用weak_ptr解决循环引用问题的">#</a> 介绍下循环引用问题，以及如何用 weak_ptr 解决循环引用问题的</h4><p>循环引用是指在两个或多个对象之间相互引用的情况下，可能会导致内存泄漏和野指针等问题。在 C++ 中，循环引用通常出现在使用 shared_ptr 管理内存资源的场景中。</p><p>当两个或多个对象通过 shared_ptr 相互引用时，每个 shared_ptr 都会增加所管理的对象的引用计数。如果其中一个对象被释放时，它所管理的内存资源可能并不会被释放，因为另一个对象仍然持有对它的引用，从而导致内存泄漏。此外，当所有对象都释放后，如果某个 shared_ptr 继续持有对已经释放的内存资源的引用，就会导致野指针问题。</p><p>为了解决循环引用问题，C++11 引入了 weak_ptr。weak_ptr 是一种弱引用智能指针，它不会增加引用计数，也不会影响对象的生命周期。当两个或多个对象通过 shared_ptr 相互引用时，可以将其中的某些指针替换为 weak_ptr，从而避免形成循环引用。当所有的 shared_ptr 对象释放了它们所管理的内存资源时，weak_ptr 并不会导致内存泄漏。此外，可以使用 lock () 函数来检查所管理的对象是否存在，从而避免了使用已经释放的内存资源的问题。</p><p>具体来说，使用 weak_ptr 解决循环引用问题的步骤如下：</p><ol><li>将其中的某些 shared_ptr 指针替换为 weak_ptr，避免形成循环引用。</li><li>在需要访问所管理的对象时，先使用 lock () 函数检查对象是否存在。如果对象已经被释放，则返回一个空的 shared_ptr；否则，返回一个新的 shared_ptr，可以安全地访问所管理的内存资源。</li></ol><p>总之，使用 weak_ptr 可以有效避免 shared_ptr 的循环引用问题，并且能够检查所管理的对象是否存在，避免了使用已经释放的内存资源的问题。在编写 C++ 程序时，使用 weak_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量。</p><h4 id="你说到了死锁为什么多个shared_ptr互相引用会发生死锁"><a class="markdownIt-Anchor" href="#你说到了死锁为什么多个shared_ptr互相引用会发生死锁">#</a> 你说到了死锁，为什么多个 shared_ptr 互相引用会发生死锁</h4><h4 id="什么是拷贝构造函数什么是赋值构造函数"><a class="markdownIt-Anchor" href="#什么是拷贝构造函数什么是赋值构造函数">#</a> 什么是拷贝构造函数，什么是赋值构造函数</h4><p>拷贝构造函数和赋值构造函数都是 C++ 中的特殊函数，用于创建新对象或将一个对象的值复制到另一个对象。</p><p>拷贝构造函数是一个特殊的构造函数，用于创建一个新对象，并将已有对象的值复制到新对象中。当用已有对象初始化一个新对象或者将一个对象作为参数传递给函数时，拷贝构造函数会被自动调用。拷贝构造函数的函数签名通常是类名 (const 类名 &amp; other)，其中 const 表示被复制的对象是只读的，&amp; 表示传递的是一个引用。</p><p>赋值构造函数是另一个特殊的函数，用于将一个对象的值复制到另一个已经存在的对象中。当使用一个对象为另一个对象赋值时，赋值构造函数会被自动调用。赋值构造函数的函数签名通常是类名 &amp; operator=(const 类名 &amp; other)，其中 = 表示赋值操作，&amp; 表示返回的是一个引用。</p><p>需要注意的是，拷贝构造函数和赋值构造函数是不同的函数，其函数签名也不同。拷贝构造函数创建新对象时，需要分配新的内存；而赋值构造函数则是将一个已有对象的值复制到另一个已经存在的对象中，不需要分配新的内存。</p><p>在 C++ 中，如果没有定义拷贝构造函数和赋值构造函数，编译器会自动生成默认的拷贝构造函数和赋值构造函数。默认的拷贝构造函数和赋值构造函数只是将每个成员变量的值从一个对象复制到另一个对象，因此如果类中存在指针等需要手动管理的资源，就需要自定义拷贝构造函数和赋值构造函数来确保正确的资源管理。</p><h4 id="这两个是为了解决一个什么问题"><a class="markdownIt-Anchor" href="#这两个是为了解决一个什么问题">#</a> 这两个是为了解决一个什么问题</h4><h4 id="拷贝构造函数和赋值构造函数时干什么用的可以告诉我你都知道什么吗"><a class="markdownIt-Anchor" href="#拷贝构造函数和赋值构造函数时干什么用的可以告诉我你都知道什么吗">#</a> 拷贝构造函数和赋值构造函数时干什么用的，可以告诉我你都知道什么吗</h4><h4 id="什么是浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#什么是浅拷贝和深拷贝">#</a> 什么是浅拷贝和深拷贝</h4><h4 id="newdelete-mallocfree是干什么用的具体有什么区别"><a class="markdownIt-Anchor" href="#newdelete-mallocfree是干什么用的具体有什么区别">#</a> new/delete malloc/free 是干什么用的，具体有什么区别</h4><p>new/delete 和 malloc/free 都是用于动态内存管理的 C++ 和 C 语言函数，用于在程序运行时分配和释放内存空间。</p><p>new/delete 是 C++ 语言中的运算符，用于动态地分配和释放内存空间，并在内存中构造和销毁对象。new 返回一个指向已分配内存的指针，而 delete 则释放已分配的内存空间。</p><p>malloc/free 是 C 语言中的函数，用于动态地分配和释放内存空间，但它们并不会自动构造和销毁对象。malloc 返回一个指向已分配内存的指针，而 free 则释放已分配的内存空间。</p><p>虽然 new/delete 和 malloc/free 都用于动态内存管理，但它们之间存在一些重要的区别：</p><ol><li>语法：new/delete 是 C++ 运算符，malloc/free 是 C 语言函数，因此它们的语法不同。</li><li>类型安全：new/delete 是类型安全的，可以自动调用对象的构造函数和析构函数，确保了类型安全。而 malloc/free 并不具备类型安全的特性，需要手动调用构造函数和析构函数。</li><li>内存分配方式：new/delete 分配的内存是从自由存储区（heap）中分配的，而 malloc/free 分配的内存是从堆（heap）中分配的。</li><li>内存分配大小：new/delete 在分配内存时，需要指定对象的类型，因此可以自动计算对象的大小。而 malloc/free 需要手动计算分配内存的大小，因此可能会产生错误。</li><li>重载：new/delete 可以被重载，可以自定义内存分配和释放方式。而 malloc/free 是 C 语言函数，不能被重载。</li></ol><p>综上所述，虽然 new/delete 和 malloc/free 都是用于动态内存管理，但它们的语法、类型安全、内存分配方式、内存分配大小和重载等方面都存在一定的区别。在 C++ 中，建议使用 new/delete 来管理动态内存，以确保类型安全和内存分配的正确性。</p><h4 id="如果new的一片内存用free会发生什么"><a class="markdownIt-Anchor" href="#如果new的一片内存用free会发生什么">#</a> 如果 new 的一片内存用 free，会发生什么</h4><p>如果使用 free 释放由 new 分配的内存，会导致未定义的行为。因为 new 和 free 是不同的内存分配函数，它们使用不同的内存管理机制。new 操作符在分配内存时，会调用 C++ 运行库的 operator new () 函数，它使用了动态分配内存的底层机制，例如 malloc 等。而 free 函数只能释放由 malloc 等函数分配的内存。所以，如果使用 free 函数释放由 new 分配的内存，会导致未定义的行为，可能会发生内存泄漏或者其他的错误。</p><p>在 C++ 中，建议使用 delete 操作符来释放由 new 分配的内存，而不是使用 free 函数。使用 delete 操作符可以确保内存分配和释放的正确性，同时也可以调用对象的析构函数来进行资源释放。</p><h4 id="我们知道如果new一个数组的话会是new-a这种格式为什么delete的也要delete-a"><a class="markdownIt-Anchor" href="#我们知道如果new一个数组的话会是new-a这种格式为什么delete的也要delete-a">#</a> 我们知道如果 new 一个数组的话会是 new a [] 这种格式，为什么 delete 的也要 delete a []</h4><h4 id="new-和-malloc分配的内存空间都在哪个地方"><a class="markdownIt-Anchor" href="#new-和-malloc分配的内存空间都在哪个地方">#</a> new 和 malloc 分配的内存空间都在哪个地方</h4><p>在 C++ 中， <code>new</code>  和  <code>malloc</code>  都可以用来动态分配内存。但是它们在分配内存的方式和位置上有一些不同。</p><p><code>new</code>  运算符分配内存的位置在 C++ 的自由存储区 (heap) 上，它会在运行时在堆上分配一段连续的内存区域来存储数据，并返回这段内存的首地址。使用  <code>new</code>  分配内存时，系统会自动调用构造函数来对分配的内存进行初始化。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int *ptr = new int;  // 分配一个整数的内存空间，并初始化为0</span><br></pre></td></tr></table></figure><p><code>malloc</code>  函数分配内存的位置在 C 的堆 (heap) 上，它也会在运行时在堆上分配一段连续的内存区域来存储数据，并返回这段内存的首地址。与  <code>new</code>  不同的是， <code>malloc</code>  只是简单地分配了一块内存空间，并不会自动调用构造函数来初始化这块内存。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int *ptr = (int*)malloc(sizeof(int));  // 分配一个整数的内存空间，但是不会初始化</span><br></pre></td></tr></table></figure><p>需要注意的是，使用  <code>malloc</code>  分配内存时，必须使用  <code>free</code>  函数来释放内存。而使用  <code>new</code>  分配内存时，则需要使用  <code>delete</code>  运算符来释放内存。</p><p>总之， <code>new</code>  和  <code>malloc</code>  的不同之处在于它们所在的存储区域不同、分配内存的方式和返回内存地址的类型不同，同时也涉及到了对象构造和析构等语义的差异。因此，在使用时需要根据实际需求来选择适合的内存分配方式。</p><h4 id="分配一段内存都有什么方法说说你都知道哪些"><a class="markdownIt-Anchor" href="#分配一段内存都有什么方法说说你都知道哪些">#</a> 分配一段内存都有什么方法，说说你都知道哪些</h4><p>在 C++ 中，常用的动态分配内存的方法主要有以下几种：</p><ol><li><code>new</code>  运算符：使用  <code>new</code>  运算符可以动态地分配指定类型的内存空间。例如，可以使用  <code>new int</code>  来分配一个  <code>int</code>  类型的内存空间，或者使用  <code>new int[10]</code>  来分配一个包含 10 个  <code>int</code>  类型元素的数组。</li><li><code>malloc</code>  函数：使用  <code>malloc</code>  函数可以在堆上动态地分配指定大小的内存空间，它的函数原型为  <code>void *malloc(size_t size)</code> 。需要注意的是，使用  <code>malloc</code>  分配内存时，必须使用  <code>free</code>  函数来释放内存。</li><li><code>calloc</code>  函数：使用  <code>calloc</code>  函数可以在堆上动态地分配指定数量、指定大小的内存空间，并且会将分配的内存空间清零，它的函数原型为  <code>void *calloc(size_t nmemb, size_t size)</code> 。</li><li><code>realloc</code>  函数：使用  <code>realloc</code>  函数可以重新分配之前由  <code>malloc</code>  或  <code>calloc</code>  分配的内存空间，它的函数原型为  <code>void *realloc(void *ptr, size_t size)</code> 。需要注意的是，使用  <code>realloc</code>  函数时，必须将之前分配的内存空间的地址作为第一个参数传递给该函数，而且不能用于  <code>new</code>  分配的内存空间。</li></ol><p>除了上述方法，C++ 标准库中还提供了一些内存分配函数，例如  <code>std::malloc</code> 、 <code>std::calloc</code> 、 <code>std::realloc</code> 、 <code>std::aligned_alloc</code> 、 <code>std::new_handler</code>  等，这些函数可以方便地进行内存分配、重新分配、对齐等操作。</p><h4 id="知道static吗详细介绍下static的功能"><a class="markdownIt-Anchor" href="#知道static吗详细介绍下static的功能">#</a> 知道 static 吗，详细介绍下 static 的功能</h4><p>在 C++ 中， <code>static</code>  关键字可以用于以下三个方面：</p><ol><li>静态变量：使用  <code>static</code>  关键字声明的变量被称为静态变量，它们存储在静态存储区中，并且只会被初始化一次。在函数内部声明的静态变量在函数执行完毕后不会被销毁，而是会一直存在于程序的生命周期中。在类中声明的静态变量被称为类变量或静态成员变量，它们被所有类对象共享，并且不依赖于任何类对象而存在。</li><li>静态函数：使用  <code>static</code>  关键字声明的函数被称为静态函数或类函数，它们与类的静态成员变量类似，不依赖于任何类对象而存在。因此，静态函数只能访问类的静态成员变量或其他静态函数，不能访问类的非静态成员变量或成员函数。</li><li>静态类：使用  <code>static</code>  关键字声明的类被称为静态类，它们只包含静态成员变量和静态成员函数，不能创建任何对象。静态类通常用于实现一些辅助函数或工具类，例如数学库、字符串库等。</li></ol><p>除了上述功能之外， <code>static</code>  关键字还可以用于限制变量和函数的作用域，使其仅在当前文件或代码块中可见。在这种情况下， <code>static</code>  关键字相当于将变量或函数的链接类型改为内部链接。这种用法可以用于隐藏实现细节，防止变量和函数被其他文件或代码块访问，从而增强程序的安全性和可维护性。</p><h4 id="知道const吗详细介绍下const的功能"><a class="markdownIt-Anchor" href="#知道const吗详细介绍下const的功能">#</a> 知道 const 吗，详细介绍下 const 的功能</h4><p>在 C++ 中， <code>const</code>  关键字用于修饰变量、函数和类成员函数等，其功能如下：</p><ol><li>常量变量：使用  <code>const</code>  关键字声明的变量称为常量变量，其值在程序运行过程中不可修改。常量变量可以在声明时进行初始化，也可以在构造函数中进行初始化。</li><li>常量函数：使用  <code>const</code>  关键字修饰的函数称为常量函数，其内部不能修改对象的状态或调用非常量成员函数。常量函数可以被常量对象和非常量对象调用，但在常量对象中只能调用常量成员函数。</li><li>常量类成员函数：使用  <code>const</code>  关键字修饰的类成员函数称为常量类成员函数，其作用与常量函数类似，但只能在类的成员函数中使用。常量类成员函数不能修改类的成员变量，但可以访问类的非常量成员函数。</li><li>常量对象：使用  <code>const</code>  关键字修饰的对象称为常量对象，其状态不能在程序运行过程中被修改。常量对象只能调用常量成员函数和常量类成员函数，不能调用非常量成员函数和非常量类成员函数。</li></ol><p>通过使用  <code>const</code>  关键字，可以增加程序的可读性、可靠性和安全性，减少代码中的错误和 bug。例如，常量变量可以防止在程序运行过程中意外修改变量的值，常量函数可以确保对象的状态不会被修改，常量类成员函数可以避免在类内部误用非常量成员函数等。</p><h4 id="关于c内存管理机制详细介绍一下"><a class="markdownIt-Anchor" href="#关于c内存管理机制详细介绍一下">#</a> 关于 C++ 内存管理机制，详细介绍一下</h4><h4 id="介绍下堆区和栈区他们有什么区别"><a class="markdownIt-Anchor" href="#介绍下堆区和栈区他们有什么区别">#</a> 介绍下堆区和栈区，他们有什么区别</h4><p>C++ 的内存管理机制主要包括两个方面：栈内存管理和堆内存管理。</p><ol><li>栈内存管理</li></ol><p>在 C++ 中，函数调用时会在栈内存中为函数创建一个新的栈帧，用于存储函数的局部变量、函数参数、返回地址和临时变量等。栈内存是由操作系统分配和管理的，因此其大小和位置是固定的。栈内存管理具有以下特点：</p><ul><li>自动分配和释放：栈内存的分配和释放是自动的，程序员不需要显式地调用函数进行内存管理。</li><li>后进先出：栈内存采用后进先出的方式进行管理，即最后进入栈的变量最先被释放。</li><li>快速访问：栈内存的访问速度非常快，因为栈内存是连续的、顺序存储的，可以直接通过栈指针进行访问。</li></ul><ol><li>堆内存管理</li></ol><p>堆内存是由程序员手动分配和释放的，其大小和位置不固定，可以动态调整。在 C++ 中，使用  <code>new</code>  运算符分配堆内存，使用  <code>delete</code>  运算符释放堆内存。堆内存管理具有以下特点：</p><ul><li>动态分配和释放：堆内存的分配和释放是由程序员手动控制的，需要使用  <code>new</code>  和  <code>delete</code>  运算符进行操作。</li><li>不连续存储：堆内存是不连续存储的，其分配和释放涉及到内存的分配和释放算法，比较复杂。</li><li>慢速访问：堆内存的访问速度比栈内存慢，因为堆内存是不连续存储的，访问需要通过指针进行间接访问。</li></ul><p>C++ 的内存管理机制是基于 RAII（Resource Acquisition Is Initialization）原则的，即资源获取即初始化。该原则要求程序员在使用资源（如堆内存、文件、锁等）时，通过对象的构造函数获取资源，在对象的析构函数中释放资源，从而避免资源泄漏和错误。例如，使用智能指针可以自动管理堆内存的分配和释放，避免手动控制  <code>new</code>  和  <code>delete</code>  运算符的问题。同时，C++ 标准库提供了多种容器和算法，可以更方便地管理内存和数据结构。</p><h4 id="你说到栈区比堆区快为什么栈快"><a class="markdownIt-Anchor" href="#你说到栈区比堆区快为什么栈快">#</a> 你说到栈区比堆区快，为什么栈快</h4><h4 id="你说到os对其做了许多优化os究竟做了什么优化为什么要这样优化呢"><a class="markdownIt-Anchor" href="#你说到os对其做了许多优化os究竟做了什么优化为什么要这样优化呢">#</a> 你说到 OS 对其做了许多优化，OS 究竟做了什么优化，为什么要这样优化呢</h4><h4 id="我们知道在递归层数太深的时候会发生栈溢出为什么会发生栈溢出呢"><a class="markdownIt-Anchor" href="#我们知道在递归层数太深的时候会发生栈溢出为什么会发生栈溢出呢">#</a> 我们知道在递归层数太深的时候会发生栈溢出，为什么会发生栈溢出呢</h4><p>栈溢出（stack overflow）是指在程序运行时，栈内存中的数据超出了栈的大小，导致无法继续正常执行程序的现象。</p><p>在函数调用时，函数的参数、局部变量、返回地址等信息都会被压入栈中，每次函数调用都会在栈上分配一段内存，称为栈帧（stack frame），当函数执行结束后，栈帧就被销毁，栈顶指针回到上一层调用函数的位置，继续执行后续的代码。</p><p>当递归层数太深时，栈空间被不断地分配和销毁，如果栈的空间不足以存储所有的栈帧，就会导致栈溢出。这通常是因为程序中使用了过多的递归调用，或者函数中分配了过多的局部变量或数组等占用了大量的栈空间。</p><p>另外，有些编译器还可以检测到递归的循环调用，从而避免栈溢出的问题。例如 GCC 编译器的 - O2 优化级别会启用尾递归优化，将递归调用转化为循环调用，从而减少栈帧的使用。</p><h4 id="你知道什么是压栈和入栈吗"><a class="markdownIt-Anchor" href="#你知道什么是压栈和入栈吗">#</a> 你知道什么是压栈和入栈吗</h4><p>在内存管理中，栈（stack）是一种线性的数据结构，具有先进后出（Last-In-First-Out，LIFO）的特点。栈通常用来存储临时变量、函数调用返回地址、函数参数以及一些其他的上下文信息。</p><p>压栈和入栈都是指将数据放入栈中的操作，但它们的含义略有不同：</p><ul><li>压栈（push）通常指将一个数据压入栈顶，即栈指针向下移动一个位置，指向新压入的数据。</li><li>入栈（push）通常指将一组数据按照某种顺序依次压入栈中，其中包括多个数据元素和可能的一些控制信息。这个操作通常用于函数调用时将参数和返回地址压入栈中。</li></ul><p>举个例子，假设我们有一个栈，其中已经有两个元素 10 和 20，栈指针指向第三个空位。此时，我们执行以下操作：</p><ul><li>压栈 30，即将数据 30 放入栈顶，栈指针指向第四个位置。</li><li>入栈函数调用信息，即将函数调用的参数和返回地址按照一定的顺序压入栈中，同时更新栈指针的位置。</li></ul><p>需要注意的是，栈的大小是有限的，当栈满了之后，就会发生栈溢出（stack overflow）的错误，这通常是因为递归调用过多或者占用了过多的栈空间导致的。因此，在编写程序时，需要谨慎使用栈，并保证栈空间的合理分配和管理。</p><h4 id="你知道什么是栈争吗详细解释下"><a class="markdownIt-Anchor" href="#你知道什么是栈争吗详细解释下">#</a> 你知道什么是栈争吗，详细解释下</h4><p>栈争（Stack Clash）是一种计算机安全漏洞，可以被黑客用来攻击目标系统并获取系统权限。该漏洞最初于 2017 年被发现，但其基本原理已经存在了很长时间。</p><p>栈争漏洞的基本原理是，当程序的堆栈空间与另一个内存区域（例如堆或共享库）发生冲突时，黑客可以利用这个漏洞来覆盖栈中的数据，从而控制程序的执行流程。具体来说，黑客会通过精心构造的输入数据来使程序在堆栈和其他内存区域之间跳转，从而实现代码注入和控制流劫持。</p><p>栈争漏洞通常发生在使用静态栈分配的程序中，这种程序在编译时会为每个线程分配固定大小的堆栈空间。黑客可以通过超出堆栈空间的边界来覆盖栈中的数据，从而实现攻击。</p><p>为了防止栈争漏洞，开发人员可以采用一些措施，例如：</p><ol><li>使用动态栈分配：动态栈分配可以使程序在运行时动态地分配堆栈空间，从而减少堆栈与其他内存区域发生冲突的可能性。</li><li>限制堆栈空间的大小：开发人员可以限制程序的堆栈空间大小，从而减少栈与其他内存区域发生冲突的可能性。</li><li>栈随机化：开发人员可以采用栈随机化技术来使每个线程的堆栈空间的地址随机化，从而使攻击者难以确定正确的地址。</li></ol><p>总之，栈争漏洞是一种常见的安全漏洞，可以通过采用适当的措施来减少其发生的可能性。</p><h4 id="什么变量分配在堆上什么变量分配在栈上"><a class="markdownIt-Anchor" href="#什么变量分配在堆上什么变量分配在栈上">#</a> 什么变量分配在堆上，什么变量分配在栈上</h4><p>在计算机编程中，内存被划分为栈（stack）和堆（heap），它们都用于存储变量。</p><p>栈（stack）：栈是一种线性数据结构，具有后进先出（LIFO）的特性。栈上的变量由编译器自动分配和释放内存。当程序执行一个函数时，该函数的参数、局部变量和返回地址被压入栈中。当函数返回时，这些变量被弹出栈。因此，栈上的变量的生命周期是由函数的调用和返回决定的。栈的大小通常是固定的，由操作系统或编译器定义。</p><p>堆（heap）：堆是一种非线性数据结构，由程序员动态分配和释放内存。堆上的变量可以在程序的任何位置被访问，因此它们的生命周期可以由程序员控制。在堆上分配内存需要显式地调用分配函数（如 malloc () 或 new），在不需要变量时，需要显式地释放它们（如 free () 或 delete）。</p><p>一般来说，较小的变量（如基本数据类型）通常分配在栈上，而较大的变量（如数组、对象等）通常分配在堆上。但是，这也取决于编译器和操作系统的实现方式，所以并非所有的编程语言和平台都遵循这种规则。</p><h4 id="关于操作系统是如何实现堆和栈的堆和栈究竟是一个怎么样的结构"><a class="markdownIt-Anchor" href="#关于操作系统是如何实现堆和栈的堆和栈究竟是一个怎么样的结构">#</a> 关于操作系统是如何实现堆和栈的，堆和栈究竟是一个怎么样的结构</h4><h4 id="c中一个很重要的特性是多态关于c中多态是如何实现的呢"><a class="markdownIt-Anchor" href="#c中一个很重要的特性是多态关于c中多态是如何实现的呢">#</a> C<ins> 中一个很重要的特性是多态，关于 C</ins> 中多态是如何实现的呢？</h4><h4 id="讲到了虚函数然后问虚函数是如何实现的呢"><a class="markdownIt-Anchor" href="#讲到了虚函数然后问虚函数是如何实现的呢">#</a> 讲到了虚函数，然后问虚函数是如何实现的呢？</h4><p>在 C<ins> 中，多态是通过虚函数（virtual function）实现的。虚函数是在基类中声明的一种特殊的成员函数，它可以被派生类重写以实现特定的行为。通过虚函数，C</ins> 能够实现运行时多态性（runtime polymorphism）。</p><p>当一个类中包含至少一个虚函数时，编译器会为该类生成一个虚函数表（virtual table，也称为 vtable），用于存储类的虚函数地址。当一个对象被创建时，它会包含一个指向虚函数表的指针。当调用一个虚函数时，C++ 会根据该对象的指针找到虚函数表，并调用相应的函数。</p><p>通过使用虚函数，C++ 可以实现动态绑定（dynamic binding）或晚绑定（late binding）的特性，即在运行时确定调用哪个函数。这样可以实现在运行时根据对象的实际类型调用相应的函数，而不是根据变量类型调用函数，从而实现多态性。</p><p>下面是一个使用虚函数实现多态的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;This is an animal sound.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Meow!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Woof!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal *ptr;</span><br><span class="line">    Cat cat;</span><br><span class="line">    Dog dog;</span><br><span class="line">    ptr = &amp;cat;</span><br><span class="line">    ptr-&gt;makeSound(); // 输出：Meow!</span><br><span class="line">    ptr = &amp;dog;</span><br><span class="line">    ptr-&gt;makeSound(); // 输出：Woof!</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Animal 类包含一个虚函数 makeSound ()，Cat 类和 Dog 类都重写了这个函数。在 main 函数中，定义了一个 Animal 类型的指针 ptr，并分别让它指向 Cat 对象和 Dog 对象。当调用 ptr 的 makeSound () 函数时，C++ 会根据 ptr 指向的对象的实际类型调用相应的函数，输出相应的结果。这就是多态的表现。</p><h4 id="c如何找到虚表的如何确定每一个子类对应的虚表就是这个虚表呢"><a class="markdownIt-Anchor" href="#c如何找到虚表的如何确定每一个子类对应的虚表就是这个虚表呢">#</a> C++ 如何找到虚表的，如何确定每一个子类对应的虚表就是这个虚表呢</h4><p>在 C++ 中，每个包含虚函数的类都会有一个虚函数表（vtable），这个表中存储了虚函数的地址。每个对象都有一个指向其对应类的虚函数表的指针（通常被称为虚表指针或 vptr），通过这个指针可以动态地调用虚函数。</p><p>在编译时，编译器为每个包含虚函数的类生成一个虚表，虚表中存储了该类中所有虚函数的地址。当派生类继承了基类的虚函数时，派生类也会包含基类的虚表，而且在该虚表的末尾添加自己的虚函数地址。这样，派生类就可以重写基类的虚函数，并添加自己的虚函数。</p><p>在运行时，当调用一个虚函数时，C++ 会根据对象的虚表指针找到对应的虚表，然后根据虚函数在虚表中的位置，调用相应的虚函数。</p><p>在实际编程中，可以使用指针操作虚表。例如，可以将一个指向虚函数的指针与一个指向对象的虚表指针相加，从而获取对象中某个虚函数的地址。这个技巧在某些情况下可以提高程序的效率。</p><p>需要注意的是，不同的编译器可能会对虚表的实现方式有所不同，因此在使用指针操作虚表时需要注意不同编译器的差异。</p><h4 id="什么是纯虚函数纯虚函数是如何实现的"><a class="markdownIt-Anchor" href="#什么是纯虚函数纯虚函数是如何实现的">#</a> 什么是纯虚函数，纯虚函数是如何实现的</h4><p>纯虚函数是在 C++ 中的一种特殊的虚函数，它没有函数体，只有函数原型，而且必须被子类重写。纯虚函数的定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">virtual return_type function_name(parameters) = 0;</span><br></pre></td></tr></table></figure><p>其中， <code>= 0</code>  表示这是一个纯虚函数。</p><p>纯虚函数的作用是为了定义一个接口，强制子类实现该接口中的方法，从而实现多态性。例如，我们可以定义一个抽象类，其中包含一个纯虚函数，子类必须实现这个函数才能被实例化。下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void draw() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Circle : public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        // 实现画圆的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle : public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        // 实现画矩形的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Shape *ptr;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Rectangle rectangle;</span><br><span class="line">    ptr = &amp;circle;</span><br><span class="line">    ptr-&gt;draw(); // 调用Circle的draw函数</span><br><span class="line">    ptr = &amp;rectangle;</span><br><span class="line">    ptr-&gt;draw(); // 调用Rectangle的draw函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Shape 类包含一个纯虚函数 draw ()，表示它是一个抽象类，不能被实例化。Circle 类和 Rectangle 类继承自 Shape 类，并重写了 draw () 函数。在 main 函数中，使用 Shape 类型的指针 ptr 分别指向 Circle 对象和 Rectangle 对象，并调用它们的 draw () 函数。由于 draw () 是一个虚函数，并且在 Shape 中被声明为纯虚函数，因此在运行时会根据 ptr 指向的对象的实际类型调用相应的函数，从而实现多态性。</p><p>纯虚函数是通过将虚函数表中的函数指针设为 NULL 来实现的。由于纯虚函数没有函数体，因此编译器不会为它生成函数的代码，而是在虚函数表中将对应的函数指针设为 NULL。这就表示该函数没有实现，必须由子类重写并实现。当派生类实现了纯虚函数后，虚函数表中对应的函数指针会被更新为子类中的函数地址，从而实现动态绑定。</p><h4 id="为什么纯虚函数不能初始化"><a class="markdownIt-Anchor" href="#为什么纯虚函数不能初始化">#</a> 为什么纯虚函数不能初始化</h4><h4 id="定义了虚函数如何在子类中访问父类的虚函数方法"><a class="markdownIt-Anchor" href="#定义了虚函数如何在子类中访问父类的虚函数方法">#</a> 定义了虚函数，如何在子类中访问父类的虚函数方法</h4><p>在 C++ 中，如果子类定义了一个和父类同名的虚函数，子类的这个函数会覆盖父类的函数，使得父类的函数在子类对象中无法直接访问。</p><p>但是，在子类中可以通过使用作用域限定符来显式地调用父类的虚函数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void foo() &#123;</span><br><span class="line">        // 父类中的虚函数实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        // 子类中的虚函数实现</span><br><span class="line">        Base::foo(); // 调用父类中的虚函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Derived 类继承自 Base 类，并覆盖了 Base 类中的虚函数 foo ()。在 Derived 类中，我们可以使用作用域限定符 <code>Base::</code>  来调用父类中的 foo () 函数。</p><p>使用作用域限定符可以在子类中显式地调用父类的虚函数，从而保留父类的实现，并添加子类的特定功能。需要注意的是，如果父类的虚函数是纯虚函数，子类必须重写该函数，否则编译器会报错。</p><h4 id="你说的这个多态是编译器多态还是运行时多态"><a class="markdownIt-Anchor" href="#你说的这个多态是编译器多态还是运行时多态">#</a> 你说的这个多态是编译器多态还是运行时多态？</h4><p>在 C++ 中，多态分为两种类型：编译时多态和运行时多态。</p><p>在编译时多态中，函数的调用在编译期就已经确定了，具体调用哪个函数由函数的静态类型（即声明时的类型）决定。这种多态性也称为静态多态性，它是通过函数重载和模板实现的。</p><p>而在运行时多态中，函数的调用是在运行时确定的，具体调用哪个函数由函数的实际类型（即运行时对象的类型）决定。这种多态性也称为动态多态性，它是通过虚函数和继承实现的。</p><p>所以，我之前提到的多态是指运行时多态，即通过虚函数和继承实现的多态。在运行时多态中，函数的调用是在运行时才确定的，具体调用哪个函数取决于对象的实际类型，而不是声明时的类型。</p><h4 id="你知道什么是编译器多态以及运行时多态吗"><a class="markdownIt-Anchor" href="#你知道什么是编译器多态以及运行时多态吗">#</a> 你知道什么是编译器多态以及运行时多态吗？</h4><h4 id="动态库和静态库有什么区别为什么有动态库和静态库关于动态库和静态库你都知道什么"><a class="markdownIt-Anchor" href="#动态库和静态库有什么区别为什么有动态库和静态库关于动态库和静态库你都知道什么">#</a> 动态库和静态库有什么区别，为什么有动态库和静态库，关于动态库和静态库你都知道什么</h4><p>动态库和静态库都是编译后的可执行文件所依赖的库，它们的主要区别在于链接方式不同。</p><p>静态库是在编译时将库的代码链接到可执行文件中，因此可执行文件中包含了完整的库代码。静态库的好处是使用简单，只需要将库的头文件和库文件一起编译即可，不需要在运行时再去加载库。但是，静态库会使得可执行文件变得比较大，而且如果多个可执行文件都使用同一个静态库，这些可执行文件会重复包含静态库的代码，导致浪费空间。</p><p>动态库则是在运行时动态加载并链接到可执行文件中，因此可执行文件中只包含了对库函数的引用，而不包含完整的库代码。动态库的好处是可以在运行时动态加载，节省空间，也方便库的更新和维护。但是，动态库的使用相对复杂，需要在编译时指定库的位置，并且需要在运行时保证库文件的可用性。</p><p>关于动态库和静态库，我还知道以下几点：</p><ol><li>静态库的文件扩展名通常为.a（Unix/Linux）或.lib（Windows），<a href="http://xn--siqsrq5g3tb3wu3ycdsap5gqzh71i2q4cq5x3i0c.so">而动态库的文件扩展名通常为.so</a>（Unix/Linux）或.dll（Windows）。</li><li>静态库和动态库都可以包含函数、变量和类等。但是，如果库中包含了全局变量，那么在动态库中可能会出现符号冲突问题。</li><li>动态库需要在运行时加载，所以可能会影响程序的性能。此外，由于动态库的引用是在运行时解析的，所以动态库存在版本兼容性问题，需要进行版本管理。</li><li>静态库和动态库的选择取决于具体的需求和场景。通常情况下，如果需要多个可执行文件共享同一库，使用动态库更为合适；如果只需要在一个可执行文件中使用库，使用静态库更为合适。</li></ol><h4 id="为什么析构函数要定义成虚函数详细解释一下"><a class="markdownIt-Anchor" href="#为什么析构函数要定义成虚函数详细解释一下">#</a> 为什么析构函数要定义成虚函数详细解释一下</h4><p>C++ 中析构函数的作用是在对象生命周期结束时进行资源的清理和释放，它与构造函数相对应。如果一个类有虚函数，那么它的析构函数通常也应该被定义成虚函数。</p><p>理由如下：</p><ol><li>多态调用问题：如果一个基类指针指向派生类对象，那么通过这个指针调用 delete 操作时，只会调用到基类的析构函数，而不会调用到派生类的析构函数。这就导致派生类中可能存在的资源泄漏问题。如果将基类的析构函数定义成虚函数，那么在调用 delete 操作时，就会自动调用到派生类的析构函数，从而确保资源被正确释放。</li><li>防止内存泄漏问题：当一个对象从动态分配的内存中释放时，如果析构函数不是虚函数，可能只有该对象的部分内存会被释放，而不是整个对象的内存。这种情况下，就会出现内存泄漏的问题。</li><li>防止对象切割问题：如果派生类对象以值传递给一个函数，而函数参数类型是基类指针或引用类型，那么传递进去的对象就会发生 “对象切割”，即只有基类部分会被复制到函数的参数中，而派生类部分会被丢失。如果基类的析构函数不是虚函数，那么在函数结束时只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类对象的资源无法释放。</li></ol><p>综上所述，如果一个类可能会被继承或者被作为基类，那么应该将其析构函数定义为虚函数，以确保在对象被销毁时能够正确地释放资源。</p><h4 id="只定义析构函数会自动生成哪些构造函数"><a class="markdownIt-Anchor" href="#只定义析构函数会自动生成哪些构造函数">#</a> 只定义析构函数，会自动生成哪些构造函数</h4><p>在 C++ 中，如果只定义一个析构函数，编译器会自动生成默认的构造函数、拷贝构造函数和拷贝赋值运算符。</p><p>具体来说，如果一个类只定义了析构函数，没有定义任何构造函数，则编译器会自动生成默认构造函数。默认构造函数没有参数，并且不执行任何操作，仅仅是为对象分配空间。</p><p>如果一个类只定义了析构函数和拷贝构造函数，则编译器会自动生成默认拷贝赋值运算符。默认拷贝构造函数用于在对象被复制时执行浅复制，即仅仅复制对象的成员变量的值，而不会复制对象的动态资源。默认拷贝赋值运算符用于在对象被赋值时执行浅复制，即将右侧对象的成员变量的值复制给左侧对象的成员变量。</p><p>需要注意的是，如果一个类需要执行深复制或者需要自定义构造函数，那么就需要手动定义这些函数，否则使用默认函数可能会导致程序错误或者内存泄漏。</p><h4 id="解释下向上转型和向下转型以及c中的四种强制类型转换为什么要有这四种强制类型转换你平时都用过哪些"><a class="markdownIt-Anchor" href="#解释下向上转型和向下转型以及c中的四种强制类型转换为什么要有这四种强制类型转换你平时都用过哪些">#</a> 解释下向上转型和向下转型，以及 C++ 中的四种强制类型转换，为什么要有这四种强制类型转换，你平时都用过哪些</h4><ol><li>向上转型（upcasting）：指的是将一个派生类指针或引用赋值给基类指针或引用的过程，即从派生类到基类的转换。这种转换是安全的，因为基类指针或引用只能访问基类中的成员，不会访问派生类中新增的成员或重载的成员函数。</li><li>向下转型（downcasting）：指的是将一个基类指针或引用转换为派生类指针或引用的过程，即从基类到派生类的转换。这种转换是危险的，因为基类指针或引用可能并不指向一个派生类对象，如果这样的转换失败，则会导致程序崩溃或者未定义行为。</li><li>C++ 中的四种强制类型转换分别为：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。<ul><li>static_cast：用于基本数据类型之间的转换，以及指针或引用之间的转换。这种转换是在编译时完成的，对于向上转型和向下转型都可以使用。但是，对于向下转型，如果类型转换不合法，则会在运行时产生未定义行为，因此需要谨慎使用。</li><li>dynamic_cast：用于将基类指针或引用转换为派生类指针或引用。这种转换是在运行时完成的，会进行类型检查，如果类型转换不合法，则返回空指针或抛出 std::bad_cast 异常。dynamic_cast 只能用于有虚函数的类之间的转换，因为它依赖于运行时类型信息。</li><li>const_cast：用于移除对象的 const 属性或将对象的 volatile 属性移除。这种转换主要用于遗留代码和与 C 语言代码的互操作。</li><li>reinterpret_cast：用于不同类型之间的强制转换，它可以将任何类型的指针或引用转换为任何其他类型的指针或引用。这种转换是非常危险的，因为它完全依赖于编译器的实现，可能会导致未定义行为或崩溃。</li></ul></li><li>强制类型转换的主要目的是为了解决类型不匹配的问题。这四种转换方式提供了不同的转换方式，使程序员可以根据需要选择适当的方式。需要注意的是，强制类型转换应该尽可能地避免使用，因为它们可能会导致安全问题和未定义行为。在实际开发中，应该尽量使用更加安全的类型转换方式，例如模板函数、函数重载、继承等。</li></ol><h3 id="做题吧"><a class="markdownIt-Anchor" href="#做题吧">#</a> 做题吧</h3><h4 id="写一个线程安全且高效的懒汉单例模式"><a class="markdownIt-Anchor" href="#写一个线程安全且高效的懒汉单例模式">#</a> 写一个线程安全且高效的懒汉单例模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 私有化构造函数，保证只能在内部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;怎么这样捏，太紧张了，很多东西都没想起来&lt;/p&gt;
&lt;p&gt;自我介绍开场&lt;/p&gt;
&lt;h4 id=&quot;c&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c&quot;&gt;#&lt;/a&gt; C++&lt;/h4&gt;
&lt;h4 id=&quot;智能指针熟悉吗介绍下智能指针&quot;&gt;&lt;a class=</summary>
      
    
    
    
    
    <category term="面试" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题day11</title>
    <link href="https://flowerhai.github.io/2023/04/24/shuati/day11/"/>
    <id>https://flowerhai.github.io/2023/04/24/shuati/day11/</id>
    <published>2023-04-24T03:55:24.000Z</published>
    <updated>2023-04-24T08:52:05.128Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和">#</a> <a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><p>给你一个整数数组  <code>nums</code>  ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>这个题动态规划就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> r = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i<span class="number">-1</span>] + nums[i] &gt; nums[i]) res[i] = res[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">            <span class="keyword">else</span> res[i] = nums[i];</span><br><span class="line"></span><br><span class="line">            r = <span class="built_in">max</span>(r, res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a class="markdownIt-Anchor" href="#70-爬楼梯">#</a> <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要  <code>n</code>  阶你才能到达楼顶。</p><p>每次你可以爬  <code>1</code>  或  <code>2</code>  个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p>DP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + res[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表">#</a> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>老熟人了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list1) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span> (!list2) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list2-&gt;next, list1);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="912-排序数组"><a class="markdownIt-Anchor" href="#912-排序数组">#</a> <a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></h4><p>给你一个整数数组  <code>nums</code> ，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p>写一个快排吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="83-删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#83-删除排序链表中的重复元素">#</a> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><p>给定一个已排序的链表的头  <code>head</code>  ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>用的递归，过了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        ListNode* hn = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (!hn) <span class="keyword">return</span> h;</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;val == hn-&gt;val) <span class="keyword">return</span> hn;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            h-&gt;next = hn;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="19-删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第-n-个结点">#</a> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>给你一个链表，删除链表的倒数第  <code>n</code>  个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>用的笨方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        ListNode* he  = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (ListNode* a = head; a != <span class="literal">nullptr</span>; a = a-&gt;next) &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = l - n;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* a = he;a != <span class="literal">nullptr</span> ; a = a-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == r ) &#123;</span><br><span class="line">                a-&gt;next = a-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = he-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> he;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="876-链表的中间结点"><a class="markdownIt-Anchor" href="#876-链表的中间结点">#</a> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><p>给你单链表的头结点  <code>head</code>  ，请你找出并返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[3,4,5]</span><br><span class="line">解释：链表只有一个中间结点，值为 3 。</span><br></pre></td></tr></table></figure><p>明显双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;53-最大子数组和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#53-最大子数组和&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/maximum-subarray/&quot;&gt;53. 最大子数组和&lt;</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
</feed>
