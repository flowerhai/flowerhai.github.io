<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚迷离</title>
  
  
  <link href="https://flowerhai.github.io/atom.xml" rel="self"/>
  
  <link href="https://flowerhai.github.io/"/>
  <updated>2023-04-23T14:36:35.800Z</updated>
  <id>https://flowerhai.github.io/</id>
  
  <author>
    <name>恍惚迷离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刷题day10</title>
    <link href="https://flowerhai.github.io/2023/04/23/day10/"/>
    <id>https://flowerhai.github.io/2023/04/23/day10/</id>
    <published>2023-04-23T14:36:04.000Z</published>
    <updated>2023-04-23T14:36:35.800Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#剑指-offer-25-合并两个排序的链表">#</a> <a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>难度简单 343 收藏分享切换为英文接收动态反馈</p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>算是很简单吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* h;</span><br><span class="line">        <span class="comment">//ListNode* head = new ListNode(0);</span></span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">            h = l2;</span><br><span class="line">            h-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            h = l1;</span><br><span class="line">            h-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-56-ii-数组中数字出现的次数-ii"><a class="markdownIt-Anchor" href="#剑指-offer-56-ii-数组中数字出现的次数-ii">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p>难度中等 443 收藏分享切换为英文接收动态反馈</p><p>在一个数组  <code>nums</code>  中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>排序解决了应该有更好的解法</p><p>需要特殊处理下边界条件，第一个元素和最后一个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        if (nums[0] != nums[1] &amp;&amp; nums[1] == nums[2]) return nums[0];</span><br><span class="line">        if (nums[nums.size()-1] != nums[nums.size()-2] &amp;&amp; nums[nums.size()-2] == nums[nums.size()-3]) return nums[nums.size()-1];</span><br><span class="line">        for (int i = 1; i&lt; nums.size()-1; i ++) &#123;</span><br><span class="line">            if (nums[i] != nums[i+1] &amp;&amp; nums[i] != nums[i-1]) return nums[i];</span><br><span class="line">        &#125; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-53-ii-0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#剑指-offer-53-ii-0~n-1中缺失的数字">#</a> <a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1 中缺失的数字</a></h4><p>难度简单 373 收藏分享切换为英文接收动态反馈</p><p>一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k:nums) cnt += k;</span><br><span class="line">        <span class="keyword">return</span> (nums.<span class="built_in">size</span>()+<span class="number">1</span>)*nums.<span class="built_in">size</span>()/<span class="number">2</span> - cnt; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点">#</a> <a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>难度简单 636 收藏分享切换为英文接收动态反馈</p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表 **：**</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p>昨天写过原题了，没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* ha = headA;</span><br><span class="line">        ListNode* hb = headB;</span><br><span class="line">        <span class="keyword">if</span> (!ha || !hb) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (ha != hb) &#123;</span><br><span class="line">            ha = ha ? ha-&gt;next : headB;</span><br><span class="line">            hb = hb ? hb-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写了四个简单题，下午面试被拷打的太惨了，写四个简单题找找自信吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-25-合并两个排序的链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-25-合并两个排序的链表&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/he-bin</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day9</title>
    <link href="https://flowerhai.github.io/2023/04/22/day9/"/>
    <id>https://flowerhai.github.io/2023/04/22/day9/</id>
    <published>2023-04-22T13:32:54.000Z</published>
    <updated>2023-04-22T13:34:15.376Z</updated>
    
    <content type="html"><![CDATA[<h4 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表">#</a> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>难度简单 2076 收藏分享切换为英文接收动态反馈</p><p>给你两个单链表的头节点  <code>headA</code>  和  <code>headB</code>  ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回  <code>null</code>  。</p><p>图示两个链表在节点  <code>c1</code>  开始相交 **：**</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code>  - 相交的起始节点的值。如果不存在相交节点，这一值为  <code>0</code></li><li><code>listA</code>  - 第一个链表</li><li><code>listB</code>  - 第二个链表</li><li><code>skipA</code>  - 在  <code>listA</code>  中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code>  - 在  <code>listB</code>  中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点  <code>headA</code>  和  <code>headB</code>  传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p>关于这个题，用双指针</p><p>一个从 A 出发，一个从 B 出发</p><p>一个到头后从另外一个起点出发，相遇的点就是交点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *a = headA;</span><br><span class="line">        ListNode *b = headB;</span><br><span class="line">        <span class="comment">//if (a == nullptr || b == nullptr) return nullptr;</span></span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="543-二叉树的直径"><a class="markdownIt-Anchor" href="#543-二叉树的直径">#</a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><p>难度简单 1305 收藏分享切换为英文接收动态反馈</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br> 给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">depth</span>(rt-&gt;left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">depth</span>(rt-&gt;right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>今天下午网易笔试，做完脑子不好使了，今天就写这两题，还有三天连着面试，线程池稍微慢一点，这几天复习下面经，背下知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;160-相交链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#160-相交链表&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/intersection-of-two-linked-lists</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>信号量以及Any类型的实现</title>
    <link href="https://flowerhai.github.io/2023/04/22/thread-pool5/"/>
    <id>https://flowerhai.github.io/2023/04/22/thread-pool5/</id>
    <published>2023-04-22T10:28:32.000Z</published>
    <updated>2023-04-22T10:30:01.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池实现任意类型的返回值"><a class="markdownIt-Anchor" href="#线程池实现任意类型的返回值">#</a> 线程池实现任意类型的返回值</h3><p>实现 C++17 中的 Any 类</p><p>任意的其他类型 template</p><p>基类类型指向派生类类型</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Any</span>(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp;) = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T data)</span> : base_(std::make_unique&lt;Derive&lt;T&gt;&gt;(data)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    T <span class="title">cast_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Derive&lt;T&gt; *pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (pd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;type is unmatch&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//基类类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Derive</span>(T data) : <span class="built_in">data_</span>(data) &#123;&#125;</span><br><span class="line">            T data_;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="信号量实现"><a class="markdownIt-Anchor" href="#信号量实现">#</a> 信号量实现</h3><p>因为线程池中的不同线程可能运行时间并不相同，因此实现线程池中的线程通信是十分有必要的。</p><p>在此不适应 C++20 中的，直接使用互斥锁和条件变量实现一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">semaphore</span>(<span class="type">int</span> Limit = <span class="number">0</span>) </span><br><span class="line">        : <span class="built_in">resLimit_</span>(Limit) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">semaphore</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//获取一个信号资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> resLimit_ &gt; <span class="number">0</span>;&#125;);</span><br><span class="line">        resLimit_ --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加一个信号资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        resLimit_ ++;</span><br><span class="line">        cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> resLimit_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程池实现任意类型的返回值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池实现任意类型的返回值&quot;&gt;#&lt;/a&gt; 线程池实现任意类型的返回值&lt;/h3&gt;
&lt;p&gt;实现 C++17 中的 Any 类&lt;/p&gt;
&lt;p&gt;任意的其他类型 templ</summary>
      
    
    
    
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>周五总结</title>
    <link href="https://flowerhai.github.io/2023/04/21/hhh/"/>
    <id>https://flowerhai.github.io/2023/04/21/hhh/</id>
    <published>2023-04-21T14:25:51.000Z</published>
    <updated>2023-04-21T14:26:28.200Z</updated>
    
    <content type="html"><![CDATA[<p>点进来了捏！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;点进来了捏！&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="逗你玩~" scheme="https://flowerhai.github.io/tags/%E9%80%97%E4%BD%A0%E7%8E%A9/"/>
    
  </entry>
  
  <entry>
    <title>刷题day8</title>
    <link href="https://flowerhai.github.io/2023/04/21/day8/"/>
    <id>https://flowerhai.github.io/2023/04/21/day8/</id>
    <published>2023-04-21T14:08:15.000Z</published>
    <updated>2023-04-21T14:08:45.969Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和">#</a> <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><p>难度中等 2459 收藏分享切换为英文接收动态反馈</p><p>给你一个 <strong>无重复元素</strong> 的整数数组  <code>candidates</code>  和一个目标整数  <code>target</code>  ，找出  <code>candidates</code>  中可以使数字和为目标数  <code>target</code>  的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code>  中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为  <code>target</code>  的不同组合数少于  <code>150</code>  个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p>这个题首先想到的就是直接 dfs 写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d==candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[i], d + <span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ft</span><span class="params">(candidates.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是呢这样还是不符合题意的，因为题目还要求我们去重。</p><p>那么该如何去做呢？</p><p>关于去重，首先我是想到了哈希表，然后仔细想想不大行，太复杂了，因此考虑一下顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d==candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选当前元素</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, d+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//选当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[d] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(candidates[d]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[d], d);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ft</span><span class="params">(candidates.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>太困了脑子不好使，今天只写一题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#39-组合总和&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;39. 组合总和&lt;/a&gt;&lt;/h4</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>线程池中添加任务实现以及功能验证</title>
    <link href="https://flowerhai.github.io/2023/04/20/thread-pool4/"/>
    <id>https://flowerhai.github.io/2023/04/20/thread-pool4/</id>
    <published>2023-04-20T14:07:27.000Z</published>
    <updated>2023-04-20T14:08:09.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="向线程池中添加任务"><a class="markdownIt-Anchor" href="#向线程池中添加任务">#</a> 向线程池中添加任务：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="comment">//线程的通信 等待任务队列有空余 wait wait_for wait_until</span></span><br><span class="line">    <span class="comment">//wait 等到条件满足</span></span><br><span class="line">    <span class="comment">//wait_for 等一段时间</span></span><br><span class="line">    <span class="comment">//wait_until 等待到</span></span><br><span class="line">    <span class="comment">//notFull_.wait(lock, [&amp;]()-&gt;bool &#123;return taskQue_.size() &lt; taskQueMaxThreshHold_; &#125;);</span></span><br><span class="line">    <span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//表示notFull等待一秒钟，条件仍然没有满足</span></span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;task queue is full, submit task fail&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有余， 把任务放入任务队列</span></span><br><span class="line">    taskQue_.<span class="built_in">emplace</span>(sp);</span><br><span class="line">    taskSize_ ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为新放了任务，任务肯定非空，not_empty通知</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证线程池功能"><a class="markdownIt-Anchor" href="#验证线程池功能">#</a> 验证线程池功能：</h3><h4 id="只在里面添加一个任务"><a class="markdownIt-Anchor" href="#只在里面添加一个任务">#</a> 只在里面添加一个任务</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140243752814144</span><br><span class="line">任务获取成功 140243752814144</span><br><span class="line">tid 140243752814144begin  </span><br><span class="line">tid 140243752814144end  </span><br><span class="line">尝试获取任务 140243752814144</span><br><span class="line">尝试获取任务 140243761206848</span><br><span class="line">尝试获取任务 140243769599552</span><br><span class="line">尝试获取任务 140243777992256</span><br></pre></td></tr></table></figure><p>可知线程池成功运行</p><h4 id="在线程池中添加三个任务"><a class="markdownIt-Anchor" href="#在线程池中添加三个任务">#</a> 在线程池中添加三个任务</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">尝试获取任务 140607723173440</span><br><span class="line">尝试获取任务 140607731566144</span><br><span class="line">尝试获取任务 140607739958848</span><br></pre></td></tr></table></figure><p>发现在一个线程中就完成了所有任务</p><p>猜测是因为 任务体量太小，加一个睡眠函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140719386736192</span><br><span class="line">任务获取成功 140719386736192</span><br><span class="line">tid 140719386736192begin  </span><br><span class="line">尝试获取任务 140719395128896</span><br><span class="line">任务获取成功 140719395128896</span><br><span class="line">tid 140719395128896begin  </span><br><span class="line">尝试获取任务 140719403521600</span><br><span class="line">任务获取成功 140719403521600</span><br><span class="line">tid 140719403521600begin  </span><br><span class="line">尝试获取任务 140719411914304</span><br><span class="line">tid 140719386736192end  </span><br><span class="line">尝试获取任务 140719386736192</span><br><span class="line">tid 140719395128896end  </span><br><span class="line">尝试获取任务 140719395128896</span><br><span class="line">tid 140719403521600end  </span><br><span class="line">尝试获取任务 140719403521600</span><br></pre></td></tr></table></figure><p>成功</p><h4 id="添加6个任务"><a class="markdownIt-Anchor" href="#添加6个任务">#</a> 添加 6 个任务</h4><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 139810625140288</span><br><span class="line">任务获取成功 139810625140288</span><br><span class="line">tid 139810625140288begin  </span><br><span class="line">尝试获取任务 139810633532992</span><br><span class="line">任务获取成功 139810633532992</span><br><span class="line">tid 139810633532992begin  </span><br><span class="line">尝试获取任务 139810641925696</span><br><span class="line">任务获取成功 139810641925696</span><br><span class="line">tid 139810641925696begin  </span><br><span class="line">尝试获取任务 139810650318400</span><br><span class="line">任务获取成功 139810650318400</span><br><span class="line">tid 139810650318400begin  </span><br><span class="line">tid 139810625140288end  </span><br><span class="line">尝试获取任务 139810625140288</span><br><span class="line">任务获取成功 139810625140288</span><br><span class="line">tid 139810625140288begin  </span><br><span class="line">tid 139810633532992end  </span><br><span class="line">尝试获取任务 139810633532992</span><br><span class="line">任务获取成功 139810633532992</span><br><span class="line">tid 139810633532992begin  </span><br><span class="line">tid 139810641925696end  </span><br><span class="line">尝试获取任务 139810641925696</span><br><span class="line">tid 139810650318400end  </span><br><span class="line">尝试获取任务 139810650318400</span><br><span class="line">tid 139810625140288end  </span><br><span class="line">尝试获取任务 139810625140288</span><br><span class="line">tid 139810633532992end  </span><br><span class="line">尝试获取任务 139810633532992</span><br></pre></td></tr></table></figure><h4 id="综上所述"><a class="markdownIt-Anchor" href="#综上所述">#</a> 综上所述</h4><p>该线程池目前看来并无问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;向线程池中添加任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#向线程池中添加任务&quot;&gt;#&lt;/a&gt; 向线程池中添加任务：&lt;/h3&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于线程池的一些设计以及问题排查</title>
    <link href="https://flowerhai.github.io/2023/04/19/thread-pool3/"/>
    <id>https://flowerhai.github.io/2023/04/19/thread-pool3/</id>
    <published>2023-04-19T09:34:16.000Z</published>
    <updated>2023-04-19T09:37:47.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于线程池的一些设计以及问题排查"><a class="markdownIt-Anchor" href="#关于线程池的一些设计以及问题排查">#</a> 关于线程池的一些设计以及问题排查</h3><p>关于任务队列，为了实现资源的高效管理，选用 shared_ptr 智能指针</p><p>使用 bind 函数实现类外定义的类能够访问本类所拥有的私有函数以及私有变量</p><h4 id="在验证线程池的时候发现打印出来的线程id都一样于是排查哪里出了问题"><a class="markdownIt-Anchor" href="#在验证线程池的时候发现打印出来的线程id都一样于是排查哪里出了问题">#</a> 在验证线程池的时候发现打印出来的线程 ID 都一样，于是排查哪里出了问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br></pre></td></tr></table></figure><p>所写线程池创建 ID</p><p>原代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; initThreadSize_; i ++) &#123;</span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,<span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; initThreadSize_; i ++) &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();<span class="comment">//执行线程函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_)</span></span>; </span><br><span class="line">    t.<span class="built_in">detach</span>();<span class="comment">//设置分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;end threadFunc tid &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细排查发现应该是这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;end threadFunc tid &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_)</span></span>; </span><br><span class="line">    t.<span class="built_in">detach</span>();<span class="comment">//设置分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">    :<span class="built_in">func_</span>(func)</span><br><span class="line">&#123;&#125;</span><br><span class="line">Thread:: ~<span class="built_in">Thread</span>()&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid 140554644977216</span><br><span class="line">end threadFunc tid 140554644977216</span><br><span class="line"></span><br><span class="line">begin threadFunc tid 140554653369920</span><br><span class="line">begin threadFunc tid 140554653369920</span><br></pre></td></tr></table></figure><p>但是明明线程池里有四个线程，为什么只运行了两个呢？</p><p>查阅资料发现，是主线程运行时间太快了，因此让主线程睡一会儿～</p><p>主线程加上 sleep (3) 后发现果然，成功！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid <span class="number">140566920504896</span></span><br><span class="line">end threadFunc tid <span class="number">140566920504896</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566928897600</span></span><br><span class="line">end threadFunc tid <span class="number">140566928897600</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566937290304</span></span><br><span class="line">end threadFunc tid <span class="number">140566937290304</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566945683008</span></span><br><span class="line">end threadFunc tid <span class="number">140566945683008</span></span><br></pre></td></tr></table></figure><h4 id="发现线程池中的线程用的是裸指针"><a class="markdownIt-Anchor" href="#发现线程池中的线程用的是裸指针">#</a> 发现线程池中的线程用的是裸指针</h4><p>修改为 unique_ptr 后然后发现以下问题</p><p ::new((void="" *)__p)="" _Up(std::forward&lt;_Args(__args)...);="">/usr/include/c++/11/ext/new_allocator.h:162:11: error: cannot convert ‘std::unique_ptr&lt;Thread, std::default_delete<Thread> &gt;’ to ‘Thread*’ in initialization<br>162 |        </p><p>左值引用问题</p><p>move 一下</p><p>然后还是错误</p><p>陷入沉思</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,<span class="keyword">this</span>));</span><br><span class="line">threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br></pre></td></tr></table></figure><p>逆天！</p><p>气死我了！</p><p>因为是远程连接 ECS 的原因，头文件没保存，</p><p>心中一万只草泥🐎奔腾！</p><p>所以修改成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于线程池的一些设计以及问题排查&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于线程池的一些设计以及问题排查&quot;&gt;#&lt;/a&gt; 关于线程池的一些设计以及问题排查&lt;/h3&gt;
&lt;p&gt;关于任务队列，为了实现资源的高效管理，选用 shared_</summary>
      
    
    
    
    
    <category term="bug" scheme="https://flowerhai.github.io/tags/bug/"/>
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="https://flowerhai.github.io/2023/04/19/acw1/"/>
    <id>https://flowerhai.github.io/2023/04/19/acw1/</id>
    <published>2023-04-19T01:53:07.000Z</published>
    <updated>2023-04-19T03:28:23.138Z</updated>
    
    <content type="html"><![CDATA[<ol start="241"><li>楼兰图腾</li></ol><p>在完成了分配任务之后，西部 314314 来到了楼兰古城的西部。</p><p>相传很久以前这片土地上 (比楼兰古城还早) 生活着两个部落，一个部落崇拜尖刀 ( <code>V</code> )，一个部落崇拜铁锹 ( <code>∧</code> )，他们分别用  <code>V</code>  和  <code>∧</code>  的形状来代表各自部落的图腾。</p><p>西部 314314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n  个点，经测量发现这 n 个点的水平位置和竖直位置是两两不同的。</p><p>西部 314314 认为这幅壁画所包含的信息与这 n  个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)(1, 1),(2, 2),…,( ,  )，其中 y1∼yn 1∼   是 11 到 n  的一个排列。</p><p>西部 314314 打算研究这幅壁画中包含着多少个图腾。</p><p>如果三个点 (i,yi),(j,yj),(k,yk)( ,  ),( ,  ),( ,  ) 满足 1≤i&lt;j&lt;k≤n1≤ &lt; &lt; ≤  且 yi&gt;yj,yj<yk  >  ,  &lt;  ，则称这三个点构成  <code>V</code>  图腾；</p><p>如果三个点 (i,yi),(j,yj),(k,yk)( ,  ),( ,  ),( ,  ) 满足 1≤i&lt;j&lt;k≤n1≤ &lt; &lt; ≤  且 yi&lt;yj,yj&gt;yk  &lt;  ,  &gt;  ，则称这三个点构成  <code>∧</code>  图腾；</p><p>西部 314314 想知道，这 n  个点中两个部落图腾的数目。</p><p>因此，你需要编写一个程序来求出  <code>V</code>  的个数和  <code>∧</code>  的个数。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行一个数 n 。</p><p>第二行是 n  个数，分别代表 y1，y2,…,yn 1， 2,…,  。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>两个数，中间用空格隔开，依次为  <code>V</code>  的个数和  <code>∧</code>  的个数。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>对于所有数据，n≤200000 ≤200000，且输出答案不会超过 int64   64。<br>y1∼yn 1∼   是 11 到 n  的一个排列。</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 2 4</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure><p>此题用树状数组，对于每一个点找出其左边比该点值大的，右边亦如此，两个数相乘，最后得到的数就是该点中 V 的图腾个数，n 正好相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> Greater[N], lower[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        Greater[i] = <span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y);</span><br><span class="line">        lower[i] = <span class="built_in">sum</span>(y - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">    LL res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * (LL)(<span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y));</span><br><span class="line">        res2 += lower[i] * (LL)(<span class="built_in">sum</span>(y - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, res1, res2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;241&quot;&gt;
&lt;li&gt;楼兰图腾&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在完成了分配任务之后，西部 314314 来到了楼兰古城的西部。&lt;/p&gt;
&lt;p&gt;相传很久以前这片土地上 (比楼兰古城还早) 生活着两个部落，一个部落崇拜尖刀 ( &lt;code&gt;V&lt;/code&gt; )，一个</summary>
      
    
    
    
    
    <category term="树状数组" scheme="https://flowerhai.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>刷题day7</title>
    <link href="https://flowerhai.github.io/2023/04/19/day7/"/>
    <id>https://flowerhai.github.io/2023/04/19/day7/</id>
    <published>2023-04-19T01:51:46.000Z</published>
    <updated>2023-04-19T01:52:48.593Z</updated>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和">#</a> <a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>难度中等 5885 收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组  <code>nums</code>  ，判断是否存在三元组  <code>[nums[i], nums[j], nums[k]]</code>  满足  <code>i != j</code> 、 <code>i != k</code>  且  <code>j != k</code>  ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code>  。请</p><p>你返回所有和为  <code>0</code>  且不重复的三元组。</p><p>** 注意：** 答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p>三树之和，经典老题了。</p><p>先将数组排序，随后用双指针，从头到尾，slow 的话从 i+1 开始，fast 从末尾开始。</p><p>如果 nums [i] + nums [slow] + nums [fast] &lt; 0</p><p>将 slow 右移</p><p>如果上面那个值大于 0</p><p>将 fast 左移</p><p>每次移动避开相同的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> slow = i + <span class="number">1</span>, fast = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (slow &lt; fast) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[slow]+nums[fast]+nums[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    slow ++;</span><br><span class="line">                    <span class="comment">//while (nums[slow] == nums[slow-1] &amp;&amp; slow &lt; fast) slow ++;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nums[slow]+nums[fast]+nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    fast --;</span><br><span class="line">                    <span class="comment">//while (nums[fast] == nums[fast+1] &amp;&amp; slow &lt; fast) fast --;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[slow], nums[fast]&#125;);</span><br><span class="line">                    slow ++;</span><br><span class="line">                    <span class="keyword">while</span> (nums[slow] == nums[slow<span class="number">-1</span>] &amp;&amp; slow &lt; fast) slow ++;</span><br><span class="line">                    fast --;</span><br><span class="line">                    <span class="keyword">while</span> (nums[fast] == nums[fast+<span class="number">1</span>] &amp;&amp; slow &lt; fast) fast --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res.erase(unique(res.begin(), res.end()), res.end());</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表">#</a> <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><p>难度简单 3105 收藏分享切换为英文接收动态反馈</p><p>给你单链表的头节点  <code>head</code>  ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>此题 easy 题，用一个头节点即可轻松完成翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">while</span> (h) &#123;</span><br><span class="line">            ListNode* ne = h-&gt;next;</span><br><span class="line">            h-&gt;next = q;</span><br><span class="line">            q = h;</span><br><span class="line">            h = ne;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="538-把二叉搜索树转换为累加树"><a class="markdownIt-Anchor" href="#538-把二叉搜索树转换为累加树">#</a> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>难度中等 880 收藏分享切换为英文接收动态反馈</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点  <code>node</code>  的新值等于原树中大于或等于  <code>node.val</code>  的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p>** 注意：** 本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p>反向中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">            root-&gt;val = sum;</span><br><span class="line">            <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="241"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;15-三数之和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#15-三数之和&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/3sum/&quot;&gt;15. 三数之和&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;难度中等 5</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day6</title>
    <link href="https://flowerhai.github.io/2023/04/18/day6/"/>
    <id>https://flowerhai.github.io/2023/04/18/day6/</id>
    <published>2023-04-18T12:51:08.000Z</published>
    <updated>2023-04-18T12:52:15.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="75-颜色分类"><a class="markdownIt-Anchor" href="#75-颜色分类">#</a> <a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h4><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>示例</mtext><mn>1</mn><mtext>：输入：</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo><mtext>输出：</mtext><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">示例 1：输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">例</span><span class="mord">1</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">：</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">：</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p>这个题，炒鸡简单。、</p><p>先把 0 放放前面，再把 1 放前面，就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> two = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏">#</a> <a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p>对每个点都求一下最大可到达距离，如果有点的能够大于等于 size-1，即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> r_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r_max) &#123;</span><br><span class="line">                r_max = <span class="built_in">max</span>(r_max, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (r_max &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#剑指-offer-34-二叉树中和为某一值的路径">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br> 输出：[[5,4,11,2],[5,8,4,5]]</p><p>这道题，对每一个节点进行 dfs 操作，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        r.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        target -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, target);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, target);</span><br><span class="line">        r.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="1252"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;75-颜色分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#75-颜色分类&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/sort-colors/&quot;&gt;75. 颜色分类&lt;/a&gt;&lt;/h4&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>线程池代码(整合版)</title>
    <link href="https://flowerhai.github.io/2023/04/18/thread-pool2/"/>
    <id>https://flowerhai.github.io/2023/04/18/thread-pool2/</id>
    <published>2023-04-18T08:44:21.000Z</published>
    <updated>2023-04-18T08:45:36.269Z</updated>
    
    <content type="html"><![CDATA[<p>关于线程池的设计，很多都和内存池差不多，在此贴上总体代码。</p><p>后续再挨个分析细节以及编写过程中的 Bug 调试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> TASK_MAX_THRESHHOLD = <span class="number">2</span>; <span class="comment">// INT32_MAX;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>; <span class="comment">// 单位：秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">PoolMode</span> &#123;</span><br><span class="line">MODE_FIXED,  <span class="comment">// 固定数量的线程</span></span><br><span class="line">MODE_CACHED, <span class="comment">// 线程数量可动态增长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程函数对象类型</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line"><span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">: <span class="built_in">func_</span>(func)</span><br><span class="line">, <span class="built_in">threadId_</span>(generateId_++)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">~<span class="built_in">Thread</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个线程来执行一个线程函数 pthread_create</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func_, threadId_)</span></span>;  <span class="comment">// C++11来说 线程对象t  和线程函数func_</span></span><br><span class="line">t.<span class="built_in">detach</span>(); <span class="comment">// 设置分离线程   pthread_detach  pthread_t设置成分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> threadId_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ThreadFunc func_;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> generateId_;</span><br><span class="line"><span class="type">int</span> threadId_;  <span class="comment">// 保存线程id</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line"><span class="built_in">ThreadPool</span>()</span><br><span class="line">: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">curThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">threadSizeThreshHold_</span>(THREAD_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED)</span><br><span class="line">, <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程池里面所有的线程返回  有两种状态：阻塞 &amp; 正在执行任务中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">poolMode_ = mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置task任务队列上线阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池cached模式下线程阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">&#123;</span><br><span class="line">threadSizeThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池提交任务</span></span><br><span class="line"><span class="comment">// 使用可变参模板编程，让submitTask可以接收任意任务函数和任意数量的参数</span></span><br><span class="line"><span class="comment">// pool.submitTask(sum1, 10, 20);   csdn  大秦坑王  右值引用+引用折叠原理</span></span><br><span class="line"><span class="comment">// 返回值future&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 打包任务，放入任务队列里面</span></span><br><span class="line"><span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">std::future&lt;RType&gt; result = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"><span class="comment">// 用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回</span></span><br><span class="line"><span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">[&amp;]()-&gt;<span class="type">bool</span> &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; (<span class="type">size_t</span>)taskQueMaxThreshHold_; &#125;)) &#123;</span><br><span class="line"><span class="comment">// 表示notFull_等待1s种，条件依然没有满足</span></span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;task queue is full, submit task fail.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">[]()-&gt;RType &#123; <span class="keyword">return</span> <span class="built_in">RType</span>(); &#125;);</span><br><span class="line">(*task)();</span><br><span class="line"><span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有空余，把任务放入任务队列中</span></span><br><span class="line"><span class="comment">// taskQue_.emplace(sp);  </span></span><br><span class="line"><span class="comment">// using Task = std::function&lt;void()&gt;;</span></span><br><span class="line">taskQue_.<span class="built_in">emplace</span>([task]() &#123;(*task)();&#125;);</span><br><span class="line">taskSize_++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为新放了任务，任务队列肯定不空了，在notEmpty_上进行通知，赶快分配线程执行任务</span></span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式 任务处理比较紧急 场景：小而快的任务 需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程出来</span></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">&amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">&amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line"><span class="comment">// 修改线程个数相关的变量</span></span><br><span class="line">curThreadSize_++;</span><br><span class="line">idleThreadSize_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回任务的Result对象</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启线程池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> initThreadSize = std::thread::hardware_concurrency())</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录初始线程个数</span></span><br><span class="line">initThreadSize_ = initThreadSize;</span><br><span class="line">curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line"><span class="comment">// 创建thread线程对象的时候，把线程函数给到thread线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// threads_.emplace_back(std::move(ptr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动所有线程  std::vector&lt;Thread*&gt; threads_;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line">threads_[i]-&gt;<span class="built_in">start</span>(); <span class="comment">// 需要去执行一个线程函数</span></span><br><span class="line">idleThreadSize_++;    <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有任务必须执行完成，线程池才可以回收所有线程资源</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Task task; &#123;</span><br><span class="line"><span class="comment">// 先获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line"><span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line"><span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line"><span class="comment">// 锁 + 双重判断</span></span><br><span class="line"><span class="keyword">while</span> (taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line"><span class="keyword">if</span> (!isPoolRunning_) &#123;</span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line">exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 线程函数结束，线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED) &#123;</span><br><span class="line"><span class="comment">// 条件变量，超时返回了</span></span><br><span class="line"><span class="keyword">if</span> (std::cv_status::timeout ==</span><br><span class="line">notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line"><span class="keyword">if</span> (dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">&amp;&amp; curThreadSize_ &gt; initThreadSize_) &#123;</span><br><span class="line"><span class="comment">// 开始回收当前线程</span></span><br><span class="line"><span class="comment">// 记录线程数量的相关变量的值修改</span></span><br><span class="line"><span class="comment">// 把线程对象从线程列表容器中删除   没有办法 threadFunc《=》thread对象</span></span><br><span class="line"><span class="comment">// threadid =&gt; thread对象 =&gt; 删除</span></span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">curThreadSize_--;</span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 等待notEmpty条件</span></span><br><span class="line">notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从任务队列种取一个任务出来</span></span><br><span class="line">task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">taskSize_--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果依然有剩余任务，继续通知其它得线程执行任务</span></span><br><span class="line"><span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出一个任务，进行通知，通知可以继续提交生产任务</span></span><br><span class="line">notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125; <span class="comment">// 就应该把锁释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程负责执行这个任务</span></span><br><span class="line"><span class="keyword">if</span> (task != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">task</span>(); <span class="comment">// 执行function&lt;void()&gt; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_++;</span><br><span class="line">lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">// 更新线程执行完任务的时间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查pool的运行状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isPoolRunning_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_; <span class="comment">// 线程列表</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initThreadSize_;  <span class="comment">// 初始的线程数量</span></span><br><span class="line"><span class="type">int</span> threadSizeThreshHold_; <span class="comment">// 线程数量上限阈值</span></span><br><span class="line">std::atomic_int curThreadSize_;<span class="comment">// 记录当前线程池里面线程的总数量</span></span><br><span class="line">std::atomic_int idleThreadSize_; <span class="comment">// 记录空闲线程的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task任务 =》 函数对象</span></span><br><span class="line"><span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">std::queue&lt;Task&gt; taskQue_; <span class="comment">// 任务队列</span></span><br><span class="line">std::atomic_int taskSize_; <span class="comment">// 任务的数量</span></span><br><span class="line"><span class="type">int</span> taskQueMaxThreshHold_;  <span class="comment">// 任务队列数量上限阈值</span></span><br><span class="line"></span><br><span class="line">std::mutex taskQueMtx_; <span class="comment">// 保证任务队列的线程安全</span></span><br><span class="line">std::condition_variable notFull_; <span class="comment">// 表示任务队列不满</span></span><br><span class="line">std::condition_variable notEmpty_; <span class="comment">// 表示任务队列不空</span></span><br><span class="line">std::condition_variable exitCond_; <span class="comment">// 等到线程资源全部回收</span></span><br><span class="line"></span><br><span class="line">PoolMode poolMode_; <span class="comment">// 当前线程池的工作模式</span></span><br><span class="line">std::atomic_bool isPoolRunning_; <span class="comment">// 表示当前线程池的启动状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于线程池的设计，很多都和内存池差不多，在此贴上总体代码。&lt;/p&gt;
&lt;p&gt;后续再挨个分析细节以及编写过程中的 Bug 调试&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>线程池总体设计及相关概念</title>
    <link href="https://flowerhai.github.io/2023/04/18/thread-pool1/"/>
    <id>https://flowerhai.github.io/2023/04/18/thread-pool1/</id>
    <published>2023-04-18T08:42:56.000Z</published>
    <updated>2023-04-19T09:36:36.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池">#</a> 线程池</h2><h3 id="线程池-2"><a class="markdownIt-Anchor" href="#线程池-2">#</a> 线程池</h3><p>池也算是比较常用的降低时间开销的手段了吧，</p><p>在此总结一下写过的线程池，把每一步捋顺了，再稍微复习下多线程相关的知识。</p><h4 id="关于本线程池项目描述"><a class="markdownIt-Anchor" href="#关于本线程池项目描述">#</a> 关于本线程池项目描述：</h4><ul><li>基于可变参模板编程和引用折叠原理，实现线程池 submitTask 接口，支持任意任务函数和任意参数 的传递</li><li>使用 future 类型定制 submitTask 提交任务的返回值</li><li>使用 map 和 queue 容器管理线程对象和任务</li><li>基于条件变量 condition_variable 和互斥锁 mutex 实现任务提交线程和任务执行线程间</li><li>的通信机制</li><li>支持 fixed 和 cached 模式的线程池定制</li><li>gdb 调试分析定位死锁问题</li></ul><h4 id="线程的消耗"><a class="markdownIt-Anchor" href="#线程的消耗">#</a> 线程的消耗</h4><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好？</p><ul><li>线程的创建和销毁都是非常 &quot;重&quot; 的操作</li><li>线程栈本身占用大量内存</li><li>线程的上下文切换要占用大量时间</li><li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机</li></ul><h4 id="线程池的优势"><a class="markdownIt-Anchor" href="#线程池的优势">#</a> 线程池的优势</h4><p>操作系统上创建线程和销毁线程都是很 &quot;重&quot; 的操作，耗时耗性能都比较多，那么在服务执行的过程中， 如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能 降低，业务的处理能力也会降低。 线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线 程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 task 任务即可，task 执行 完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的 task 提供服务。</p><h4 id="fixed模式线程池"><a class="markdownIt-Anchor" href="#fixed模式线程池">#</a> fixed 模式线程池</h4><p>线程池里面的线程个数是固定不变的，一般是 ThreadPool 创建时根据当前机器的 CPU 核心数量进行指 定。</p><h4 id="cached模式线程池"><a class="markdownIt-Anchor" href="#cached模式线程池">#</a> cached 模式线程池</h4><p>线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程 数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了 60s 还没 有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。</p><ul><li><p>C++11</p><p>组合和继承，多态，STL，智能指针，函数对象，绑定器，可变参模板编程</p></li><li><p>C++11 多线程编程</p><p>thread,mutxe,atomic,condition_variable,unique_lock</p></li><li><p>C<ins>17 和 C</ins>20 的标准的一些内容</p><p>17 的 any， 20 的 semaphore</p></li><li><p>多线程理论</p><p>多线程基本知识，线程互斥，线程同步，原子操作，CAS</p></li></ul><h4 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行">#</a> 并发和并行</h4><ul><li>CPU 单核</li><li>CPU 多核、多 CPU</li></ul><h4 id="并发"><a class="markdownIt-Anchor" href="#并发">#</a> 并发</h4><p>单核上，多个线程占用不同的 CPU 时间片，物理上还是串行执行的，但是由于每个线程占用的 CPU 时间 片非常短（比如 10ms），看起来就像是多个线程都在共同执行一样，这样的场景称作并发 （concurrent）。</p><h4 id="并行"><a class="markdownIt-Anchor" href="#并行">#</a> 并行</h4><p>在多核或者多 CPU 上，多个线程是在真正的同时执行，这样的场景称作并行（parallel）。</p><h3 id="多线程的优势"><a class="markdownIt-Anchor" href="#多线程的优势">#</a> 多线程的优势</h3><p>多线程程序一定就好吗？不一定，要看具体的应用场景：</p><h4 id="io密集型"><a class="markdownIt-Anchor" href="#io密集型">#</a> IO 密集型</h4><p>程序里面指令的执行，涉及一些 IO 操作 (会阻塞)</p><p>无论是 CPU 单核、CPU 多核、多 CPU，都是比较适合多线程程序的</p><h4 id="cpu密集型"><a class="markdownIt-Anchor" href="#cpu密集型">#</a> CPU 密集型</h4><p>(程序里面的指令做计算用的)</p><ul><li><p>CPU 单核</p><p>多线程存在上下文切换，是额外的花销，线程越多上下文切换所花费的额外时间也越多，倒不如一个线 程一直进 行计算。</p></li><li><p>CPU 多核、多 CPU</p><p>多个线程可以并行执行，对 CPU 利用率好</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池&quot;&gt;#&lt;/a&gt; 线程池&lt;/h2&gt;
&lt;h3 id=&quot;线程池-2&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池-2&quot;&gt;#&lt;/a&gt; 线程池&lt;/h3</summary>
      
    
    
    
    
    <category term="bug" scheme="https://flowerhai.github.io/tags/bug/"/>
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池压测</title>
    <link href="https://flowerhai.github.io/2023/04/17/yace/"/>
    <id>https://flowerhai.github.io/2023/04/17/yace/</id>
    <published>2023-04-17T11:37:45.000Z</published>
    <updated>2023-04-17T11:38:13.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压测"><a class="markdownIt-Anchor" href="#压测">#</a> 压测：</h3><ul><li>50393us 数据库连接池 100</li><li>424062us 普通连接 100</li></ul><p>可以看出使用线程池后效果拔群！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;压测&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#压测&quot;&gt;#&lt;/a&gt; 压测：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;50393us 数据库连接池 100&lt;/li&gt;
&lt;li&gt;424062us 普通连接 100&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出</summary>
      
    
    
    
    
    <category term="数据库连接池实现" scheme="https://flowerhai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库连接池实现</title>
    <link href="https://flowerhai.github.io/2023/04/17/mysql-mysql-poo2/"/>
    <id>https://flowerhai.github.io/2023/04/17/mysql-mysql-poo2/</id>
    <published>2023-04-17T11:34:15.000Z</published>
    <updated>2023-04-17T11:36:46.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库连接池"><a class="markdownIt-Anchor" href="#数据库连接池">#</a> 数据库连接池</h3><h4 id="数据库连接池-2"><a class="markdownIt-Anchor" href="#数据库连接池-2">#</a> 数据库连接池：</h4><h5 id="小tips"><a class="markdownIt-Anchor" href="#小tips">#</a> 小 tips：</h5><p>关于外部获取连接池中的空闲连接，在此可以使用智能指针来完成内存管理，能够方便许多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">connectpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取连接池对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> connectpool* <span class="title">getconnectpool</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;<span class="comment">//给外部提供一个接口，从连接池中获取一个可用的空闲连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadconfig</span><span class="params">()</span></span>;<span class="comment">//加载配置项</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span></span>;<span class="comment">//生产新连接 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connectpool</span>();<span class="comment">//构造函数私有化</span></span><br><span class="line">    string _ip;<span class="comment">//ip地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> _port;<span class="comment">//端口号</span></span><br><span class="line">    string _username;<span class="comment">//用户名</span></span><br><span class="line">    string _password;<span class="comment">//密码</span></span><br><span class="line">    string _dbname;<span class="comment">//db名字</span></span><br><span class="line">    <span class="type">int</span> _initsize; <span class="comment">//初始连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxsize;<span class="comment">//最大连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxIdleTime;<span class="comment">//连接池最大空闲时间</span></span><br><span class="line">    <span class="type">int</span> _connectTimeout;<span class="comment">//连接池获取连接的超时时间 </span></span><br><span class="line"></span><br><span class="line">    queue&lt;connection*&gt; _connectqueue; <span class="comment">//存储mysql的队列</span></span><br><span class="line">    mutex _queueMutex;<span class="comment">//维护连接队列的线程安全互斥锁</span></span><br><span class="line">    atomic_int connectCnt;<span class="comment">//记录连接创建的connect连接的数量</span></span><br><span class="line">    condition_variable cv;<span class="comment">//设置条件变量，用于连接生产者和消费者</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="数据库连接池的构造函数"><a class="markdownIt-Anchor" href="#数据库连接池的构造函数">#</a> 数据库连接池的构造函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connectpool::<span class="built_in">connectpool</span>() &#123;</span><br><span class="line">    <span class="built_in">loadconfig</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _initsize; i ++) &#123;</span><br><span class="line">        connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">        p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">        _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">        connectCnt ++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//启动一个新的线程，作为连接的生产者</span></span><br><span class="line">    <span class="function">thread <span class="title">produce</span><span class="params">(bind(&amp;connectpool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者函数"><a class="markdownIt-Anchor" href="#生产者函数">#</a> 生产者函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::produceConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock);<span class="comment">//队列不空，生产者进入等待状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接数量没到达上限，继续创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span>(connectCnt &lt; _maxsize) &#123;</span><br><span class="line">            connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">            p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">            _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">            connectCnt ++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知消费者线程，可以消费连接</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者函数"><a class="markdownIt-Anchor" href="#消费者函数">#</a> 消费者函数：</h4><p>智能指针加 lambda 表达式</p><p>注意 sleep 和 wait-for 的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;connection&gt; <span class="title">connectpool::getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv_status::timeout ==  cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(_connectTimeout))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="built_in">LOG</span>(<span class="string">&quot;获取空闲连接超时————失败！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 智能指针析构时，会把资源delete，需要自定义 ./run</span></span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">sp</span><span class="params">(_connectqueue.front(), </span></span></span><br><span class="line"><span class="params"><span class="function">            [&amp;](connection *pcon) &#123;<span class="comment">//要考虑线程安全</span></span></span></span><br><span class="line"><span class="params"><span class="function">                unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">                pcon-&gt;refreshAliveTime();<span class="comment">//刷新一下开始空闲起始时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                _connectqueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();<span class="comment">//空了再通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除超时连接"><a class="markdownIt-Anchor" href="#删除超时连接">#</a> 删除超时连接</h4><p>应当注意在上面的代码中，在每次创建完数据库连接时刷新一下定时器，或者消费者使用完的连接返还回数据库连接池时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::scanConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//通过sleep模拟定时效果</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(_maxIdleTime));</span><br><span class="line">        <span class="comment">//扫描整个队列，释放多余连接</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (connectCnt &gt; _initsize) &#123;</span><br><span class="line">            connection *p = _connectqueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;<span class="built_in">getAliceTime</span>() &gt;= (_maxIdleTime * <span class="number">1000</span>)) &#123;</span><br><span class="line">                _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">                connectCnt --;</span><br><span class="line">                <span class="keyword">delete</span> p;<span class="comment">//释放连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//队头的连接都没超时，后面更不会</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库连接池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库连接池&quot;&gt;#&lt;/a&gt; 数据库连接池&lt;/h3&gt;
&lt;h4 id=&quot;数据库连接池-2&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库连接池-2</summary>
      
    
    
    
    
    <category term="数据库连接池实现" scheme="https://flowerhai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://flowerhai.github.io/2023/04/17/acw/"/>
    <id>https://flowerhai.github.io/2023/04/17/acw/</id>
    <published>2023-04-17T02:32:52.000Z</published>
    <updated>2023-04-18T12:52:13.175Z</updated>
    
    <content type="html"><![CDATA[<ol start="1250"><li><strong>格子游戏</strong></li></ol><p>Alice 和 Bob 玩了一个古老的游戏：首先画一个 n×n�×� 的点阵（下图 n=3�=3 ）。</p><p>接着，他们两个轮流在相邻的点之间画上红边和蓝边：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/12/11/19_9edbcf521b-1.png" class="lazyload placeholder" data-srcset="https://cdn.acwing.com/media/article/image/2019/12/11/19_9edbcf521b-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1.png"></p><p>直到围成一个封闭的圈（面积不必为 11）为止，“封圈” 的那个人就是赢家。因为棋盘实在是太大了，他们的游戏实在是太长了！</p><p>他们甚至在游戏中都不知道谁赢得了游戏。</p><p>于是请你写一个程序，帮助他们计算他们是否结束了游戏？</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>输入数据第一行为两个整数 n 和 m。n 表示点阵的大小，m 表示一共画了 m 条线。</p><p>以后 m 行，每行首先有两个数字 (x,y)，代表了画线的起点坐标，接着用空格隔开一个字符，假如字符是 D，则是向下连一条边，如果是 R 就是向右连一条边。</p><p>输入数据不会有重复的边且保证正确。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出一行：在第几步的时候结束。</p><p>假如 m 步之后也没有结束，则输出一行 “draw”。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤2001≤≤200，<br>1≤m≤240001≤≤24000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 1 D</span><br><span class="line">1 1 R</span><br><span class="line">1 2 D</span><br><span class="line">2 1 R</span><br><span class="line">2 2 D</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>这个题目的思路是这样的：</p><p>就是用并查集的思路去做，这个题让我们判断是否成环，我们可以思考一下，怎么才能出现环呢？</p><p>那就是当要添加进去的两个点，都在一个集合里！</p><p>这样就会出现环，因此我们只需要将每次添加进去的点存在并查集里，然后对每个即将添加进去的两个点判断一下是否在一个并查集里即可，如果在成环且返回，如果不在，将两个点添加到一个并查集即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[x] != x) a[x] = <span class="built_in">find</span>(a[x]);</span><br><span class="line">    <span class="keyword">return</span> a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; i ++) a[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;</span><br><span class="line">        x --, y--;</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">get</span>(x, y);</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;D&#x27;</span>) d = <span class="built_in">get</span>(x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> d = <span class="built_in">get</span>(x,y+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="type">int</span> pd = <span class="built_in">find</span>(d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pb == pd) &#123;</span><br><span class="line">            res = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[pb] = pd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!res) cout&lt;&lt;<span class="string">&quot;draw&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="1252"><li>搭配购买</li></ol><p>Joe 觉得云朵很美，决定去山上的商店买一些云朵。</p><p>商店里有 n 朵云，云朵被编号为 1,2,…,n1,2,…,，并且每朵云都有一个价值。</p><p>但是商店老板跟他说，一些云朵要搭配来买才好，所以买一朵云则与这朵云有搭配的云都要买。</p><p>但是 Joe 的钱有限，所以他希望买的价值越多越好。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>第 11 行包含三个整数 n，m，w，表示有 n 朵云，m 个搭配，Joe 有 w 的钱。</p><p>第 2∼n+12∼+1 行，每行两个整数 ci，di 表示 i 朵云的价钱和价值。</p><p>第 n+2∼n+1+m +2∼ +1+  行，每行两个整数 ui，vi  ，  ，表示买 ui   就必须买 vi  ，同理，如果买 vi   就必须买 ui  。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>一行，表示可以获得的最大价值。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤n≤100001≤ ≤10000,<br>0≤m≤50000≤ ≤5000,<br>1≤w≤100001≤ ≤10000,<br>1≤ci≤50001≤  ≤5000,<br>1≤di≤1001≤  ≤100,<br>1≤ui,vi≤n1≤  ,  ≤</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 3 10</span><br><span class="line">3 10</span><br><span class="line">3 10</span><br><span class="line">3 10</span><br><span class="line">5 100</span><br><span class="line">10 1</span><br><span class="line">1 3</span><br><span class="line">3 2</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>这个题啊，思路也不难。</p><p>首先我们先读入数据，然后看看新加入的两朵云是否在一个并查集里面，如果在的话，暂且不管，如果不在的话，添加以下，价格价值也需要更新。</p><p>随后遍历所有的云，仅当 p [i]==i 时，选该云，化为一个 01 背包问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], p[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(x), pb = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb) &#123;</span><br><span class="line">            v[pb] += v[pa];</span><br><span class="line">            w[pb] += w[pa];</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = q; j &gt;= v[i]; j --) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[q]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;1250&quot;&gt;
&lt;li&gt;&lt;strong&gt;格子游戏&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Alice 和 Bob 玩了一个古老的游戏：首先画一个 n×n�×� 的点阵（下图 n=3�=3 ）。&lt;/p&gt;
&lt;p&gt;接着，他们两个轮流在相邻的点之间画上红边和蓝边</summary>
      
    
    
    
    
    <category term="并查集" scheme="https://flowerhai.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>刷题day5</title>
    <link href="https://flowerhai.github.io/2023/04/17/day5/"/>
    <id>https://flowerhai.github.io/2023/04/17/day5/</id>
    <published>2023-04-17T02:32:11.000Z</published>
    <updated>2023-04-17T02:32:38.337Z</updated>
    
    <content type="html"><![CDATA[<h4 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p>这个题啊，对于一个节点，求出其左右孩子的贡献度，且仅当该贡献度大于 0 时，选该孩子，不然不参与贡献度计算，然后对于一个节点的贡献度，为其节点的值加上左右孩子节点的最大值，就行喽！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxgain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INT_MAX;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">maxgain</span>(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">maxgain</span>(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pp = r + l + root-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, pp);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l ,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxgain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="48-旋转图像"><a class="markdownIt-Anchor" href="#48-旋转图像">#</a> <a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h4><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>这个题啊，so easy</p><p>只需要对称一下，然后对角线翻转一下，直接拿捏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) <span class="built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;124-二叉树中的最大路径和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#124-二叉树中的最大路径和&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/binary-tree-maximum-</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day4</title>
    <link href="https://flowerhai.github.io/2023/04/15/day4/"/>
    <id>https://flowerhai.github.io/2023/04/15/day4/</id>
    <published>2023-04-15T12:45:13.000Z</published>
    <updated>2023-04-22T10:27:53.497Z</updated>
    
    <content type="html"><![CDATA[<h4 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换">#</a> <a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h4><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的</p><p>DP 法</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></msub><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mtext>其中</mtext><msub><mi>f</mi><mi>i</mi></msub><mtext>表示总金额为</mtext><mi>i</mi><mtext>时的最小硬币数</mtext><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mtext>为第</mtext><mi>i</mi><mtext>个硬币的金额数</mtext></mrow><annotation encoding="application/x-tex">f_{i} = f_{i-a[i]} + 1 \\其中f_{i}表示总金额为i时的最小硬币数,a_{i}为第i个硬币的金额数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">a</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span><span class="mord cjk_fallback">为</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">硬</span><span class="mord cjk_fallback">币</span><span class="mord cjk_fallback">数</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">硬</span><span class="mord cjk_fallback">币</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span><span class="mord cjk_fallback">数</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)coins.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合">#</a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>用 dfs 来做就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; board = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//表示按到了键盘上的第几个键</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board[num].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(board[num][i]);  </span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, digits);  <span class="comment">//递归下一层</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();      <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;322-零钱兑换&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#322-零钱兑换&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/coin-change/&quot;&gt;322. 零钱兑换&lt;/a&gt;&lt;/h4&gt;</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库连接实现</title>
    <link href="https://flowerhai.github.io/2023/04/15/mysql-pool1/"/>
    <id>https://flowerhai.github.io/2023/04/15/mysql-pool1/</id>
    <published>2023-04-15T09:31:37.000Z</published>
    <updated>2023-04-15T09:33:05.039Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql数据库连接实现"><a class="markdownIt-Anchor" href="#mysql数据库连接实现">#</a> MySQL 数据库连接实现</h4><h4 id="connecth"><a class="markdownIt-Anchor" href="#connecth">#</a> connect.h</h4><p>实现连接，更新，查询，可以后续添加很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">connection</span>(<span class="comment">/* args */</span>);</span><br><span class="line">    ~<span class="built_in">connection</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">(string ip,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">short</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                string user,</span></span></span><br><span class="line"><span class="params"><span class="function">                string hash_password,</span></span></span><br><span class="line"><span class="params"><span class="function">                string dbname</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line">    <span class="function">MYSQL_RES* <span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    MYSQL * _conn;<span class="comment">//表示MYSQL Server的一条连接</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>connect.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connect.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//g++ -o run  main.cpp connect.cpp -I /usr/include/mysql -lmysqlclient</span></span><br><span class="line">connection::<span class="built_in">connection</span>() &#123;</span><br><span class="line">    _conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection::~<span class="built_in">connection</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_conn) <span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::connect</span><span class="params">(string ip,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">short</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">                string user,</span></span></span><br><span class="line"><span class="params"><span class="function">                string hash_password,</span></span></span><br><span class="line"><span class="params"><span class="function">                string dbname)</span> </span>&#123;</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, ip.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),</span><br><span class="line">    hash_password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection::update</span><span class="params">(std::string sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">         <span class="built_in">LOG</span>(<span class="string">&quot;更新失败:&quot;</span> + sql);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_RES* <span class="title">connection::query</span><span class="params">(string sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(<span class="string">&quot;查询失败:&quot;</span> + sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_use_result</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;mysql数据库连接实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mysql数据库连接实现&quot;&gt;#&lt;/a&gt; MySQL 数据库连接实现&lt;/h4&gt;
&lt;h4 id=&quot;connecth&quot;&gt;&lt;a class=&quot;markdownIt-Anch</summary>
      
    
    
    
    
    <category term="数据库连接池实现" scheme="https://flowerhai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池框架构建</title>
    <link href="https://flowerhai.github.io/2023/04/15/mysql-pool/"/>
    <id>https://flowerhai.github.io/2023/04/15/mysql-pool/</id>
    <published>2023-04-15T09:22:24.000Z</published>
    <updated>2023-04-15T09:33:06.147Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库连接池框架构建"><a class="markdownIt-Anchor" href="#数据库连接池框架构建">#</a> 数据库连接池框架构建</h3><p>技术点：</p><p>MySQL 数据库编程、单例模式、queue 队列容器、C++11 多线程、线程互斥、线程同步和 unique_lock、基于 CAS 的原子整形、智能指针 shared_ptr、lambda 表达式、生产者消费者线程模型</p><p>在高并发情况下，大量的 TCP 三次握手，MySQL Server 连接认证、关闭连接回收资源和 TCP 四次挥手耗费的性能时间很明显，增加连接词就是为了减少这一部分的性能损耗。</p><p><strong>实现功能：</strong></p><p><strong>初始连接量</strong></p><p><strong>最大连接量</strong></p><p><strong>最大空闲时间</strong></p><p><strong>连接超时时间</strong></p><p>主要实现上述四个功能</p><p><strong>设计思路：</strong></p><ul><li>连接池只需要一个实例，所以 ConnectionPool 以单例模式设计</li><li>从 ConnectionPool 中可以获得和 MySQL 连接的 Connection</li><li>空闲连接 Connection 全部维护在一个线程安全地 Connection 队列中，使用线程互斥锁保证队列的线程安全</li><li>如果 Connection 队列为空，需要再获取连接，此时动态创建连接，上限数量是 maxSize</li><li>队列中空闲连接时间超过 maxIdleTime 的就要被释放掉，只保留初始的 initSize 就可以了，这个功能交由独立的线程去做</li><li>如果 Connection 队列为空，而此时连接的数量已达上线 maxSize，那么等待 Connection TimeOut 时间如果还获取不到空闲的连接，那么获取连接失败，此处 Connection 队列获取空闲连接，可以使用带超时时间的 mutex 互斥锁来实现连接超时时间</li><li>用户获取的连接用 shared_ptr 智能指针来管理，用 lambda 表达式定制连接释放的功能</li><li>连接的生产和连接的消费采用生产者消费者线程模型设计，使用线程间的同步通信机制条件变量和互斥锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库连接池框架构建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库连接池框架构建&quot;&gt;#&lt;/a&gt; 数据库连接池框架构建&lt;/h3&gt;
&lt;p&gt;技术点：&lt;/p&gt;
&lt;p&gt;MySQL 数据库编程、单例模式、queue 队列容器、C++11 多</summary>
      
    
    
    
    
    <category term="数据库连接池实现" scheme="https://flowerhai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于数据库连接池遇到的一些问题</title>
    <link href="https://flowerhai.github.io/2023/04/15/problem1/"/>
    <id>https://flowerhai.github.io/2023/04/15/problem1/</id>
    <published>2023-04-15T09:21:01.000Z</published>
    <updated>2023-04-19T09:37:07.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于数据库连接池遇到的一些问题"><a class="markdownIt-Anchor" href="#关于数据库连接池遇到的一些问题">#</a> 关于数据库连接池遇到的一些问题</h3><p>首先，要记得绑 mysql 的库。</p><p>g++ -o run  main.cpp connect.cpp -I /usr/include/mysql -lmysqlclient</p><p>否则会出现一些问题，仅仅能导入是不行的。</p><p>其次是关于 mysql 的指令学习。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">CREATE DATABASES;</span><br><span class="line">USE test_db;</span><br><span class="line">CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];</span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>因为不熟悉 mysql 搞了好多低级错误，哭晕。</p><h3 id="关于破bug"><a class="markdownIt-Anchor" href="#关于破bug">#</a> 关于破 bug</h3><h4 id="segmentation-fault-core-dumped"><a class="markdownIt-Anchor" href="#segmentation-fault-core-dumped">#</a> Segmentation fault (core dumped)</h4><p>在本问题在中是指针出问题了 qaq</p><p>排查了半天</p><p>通过查资料学到了 gdb 调试的一些方法来判断是什么问题</p><h4 id="然后就是不知道为什么运行之后一直阻塞"><a class="markdownIt-Anchor" href="#然后就是不知道为什么运行之后一直阻塞">#</a> 然后就是不知道为什么运行之后一直阻塞</h4><p>排查到这个地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();<span class="comment">//空了再通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这可不行！<br>居然把返回值放到函数里面了我的错我的错</p><p>排查半天，难受死！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于数据库连接池遇到的一些问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于数据库连接池遇到的一些问题&quot;&gt;#&lt;/a&gt; 关于数据库连接池遇到的一些问题&lt;/h3&gt;
&lt;p&gt;首先，要记得绑 mysql 的库。&lt;/p&gt;
&lt;p&gt;g++ -o </summary>
      
    
    
    
    
    <category term="数据库连接池实现" scheme="https://flowerhai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="bug" scheme="https://flowerhai.github.io/tags/bug/"/>
    
  </entry>
  
</feed>
