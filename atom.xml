<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚迷离</title>
  
  
  <link href="https://flowerhai.github.io/atom.xml" rel="self"/>
  
  <link href="https://flowerhai.github.io/"/>
  <updated>2023-09-19T12:59:45.840Z</updated>
  <id>https://flowerhai.github.io/</id>
  
  <author>
    <name>恍惚迷离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日沉淀</title>
    <link href="https://flowerhai.github.io/2023/09/19/qiu-zhao/s1/"/>
    <id>https://flowerhai.github.io/2023/09/19/qiu-zhao/s1/</id>
    <published>2023-09-19T12:59:19.000Z</published>
    <updated>2023-09-19T12:59:45.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象设计原则"><a class="markdownIt-Anchor" href="#面向对象设计原则">#</a> 面向对象设计原则</h3><ul><li><em>Single Responsibility Principle：单一职责原则</em></li><li><em>Open Closed Principle：开放封闭原则</em></li><li><em>Liskov Substitution Principle：里氏代换原则</em></li><li><em>Dependence Inversion Principle：依赖倒转原则</em></li><li><em>Law of Demeter：迪米特法则</em></li><li><em>Interface Segregation Principle：接口隔离原则</em></li></ul><h3 id="linux使用相关"><a class="markdownIt-Anchor" href="#linux使用相关">#</a> linux 使用相关</h3><p>如何查看当前目录下最近修改的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lt ##此命令可以列出相关信息</span><br></pre></td></tr></table></figure><p>筛选指定行的关键字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;abab&quot; | sed ####打印奇数行（~2代表跳2行）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">p打印</span></span><br><span class="line">seq 10 |sed -n &#x27;1~2p&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以使用d删除偶数行，来获取偶数行</span></span><br><span class="line">seq 10 |sed -n &#x27;2~2d&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###打印偶数行（~2代表跳2行）</span></span></span><br><span class="line">seq 10 |sed -n &#x27;2~2p&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以使用d删除奇数行，来获取偶数行</span></span><br><span class="line">seq 10 |sed -n &#x27;1~2d&#x27;</span><br></pre></td></tr></table></figure><h3 id="红黑树的旋转结构插入删除性质"><a class="markdownIt-Anchor" href="#红黑树的旋转结构插入删除性质">#</a> 红黑树的旋转，结构，插入，删除，性质</h3><p><a href="https://zhuanlan.zhihu.com/p/166319823">https://zhuanlan.zhihu.com/p/166319823</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;面向对象设计原则&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面向对象设计原则&quot;&gt;#&lt;/a&gt; 面向对象设计原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Single Responsibility Principle：单一职责原则&lt;/em&gt;</summary>
      
    
    
    
    
    <category term="秋招" scheme="https://flowerhai.github.io/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>youhua</title>
    <link href="https://flowerhai.github.io/2023/08/03/youhua/"/>
    <id>https://flowerhai.github.io/2023/08/03/youhua/</id>
    <published>2023-08-03T07:17:25.000Z</published>
    <updated>2023-08-03T07:17:59.264Z</updated>
    
    <content type="html"><![CDATA[<p># 乘客应答时长感知优化</p><p>## 感知时长：</p><ul><li><p>乘客呼单时间</p></li><li><p>订单创建时间</p></li><li><p>订单到达 duse 时间</p></li><li><p>duse 完成播单时间</p></li><li><p>司机应答时间</p></li><li><p>乘客感知应答时间</p></li></ul><p>乘客呼单至感知应答 = （乘客呼单至订单创建 + 订单创建至播单 + 播单至服务端订单应答 + 服务端订单应答至乘客感知应答）</p><p>查看统计数据发现：</p><ul><li>“乘客呼单至订单创建”、“服务端订单应答至乘客感知应答” 这两个环节耗时略长</li><li>播单至服务端订单应答的 P99 是 15s，核心原因是抢单播单</li></ul><p>因此优先对上面两个环节进行优化</p><p>在发单和应答的时候都会有一个 pOrderStatus, 轮询 30s 用来查看订单状态。（优化点）</p><p>## 发单</p><p>### pOrderStatus 轮询优化：</p><p>当长连接不可用时，排除运力情况下，用户的被接单感知时长延长 30s</p><p>solve: 缩短等待司机接单、等待接驾状态下的轮询时长，通过增加 pOrderStatus 的负载能力，从 30s 周期降低到 5s</p><p>### 分单</p><p>播单有订单锁（8-15s)，播单后未应答就是无效播单。</p><p>push 未触达司机端，分单无法感知失败无法重试</p><p>slove：端过滤提前解锁订单，优化缩短订单锁时长</p><p>### 拉单：</p><p>主要是各种业务环节耗时严重</p><p>### 乘客应答感知</p><p>1、核心问题在触达率，如果未触达，需要依赖 30s 轮询兜底，导致乘客感知 30s+。</p><p>2、不在线率，主要是 app 切后台、杀端等，只能依赖端外触达，但端外触达率很低（10%）。</p><p>3、在线情况下触达率能达到 99%，但依然有 1% 的长尾问题。</p><ul><li>灵动岛链路优化 体验攻坚二期需求</li><li>push 感知优化 体验攻坚一期</li><li>pOrderStatus 轮询周期从 30s 降低到 5s</li></ul><h2 id="2-porderstatus轮询优化"><a class="markdownIt-Anchor" href="#2-porderstatus轮询优化">#</a> 2. pOrderStatus 轮询优化</h2><h3 id="21-现状"><a class="markdownIt-Anchor" href="#21-现状">#</a> 2.1 现状</h3><p><a href="http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=505577388">pOrderStatus 轮询整理 &amp; 降级</a></p><p>端上依赖长连接 push + 轮询 pOrderStatus 兜底的方式感知订单状态变化。</p><p>当从 status=7 变化为 status=4 时，会切换等待接驾组件。</p><h3 id="22-端上行为"><a class="markdownIt-Anchor" href="#22-端上行为">#</a> 2.2 端上行为：</h3><p>长连接有效时，在 yuying 时会 push 乘客端感知被接单，乘客感知时长会很短。</p><p>当长连接无效时，只能依赖 pOrderStatus 轮询兜底感知订单状态变更。</p><p>当端上切后台时，小程序大约 5s 后被挂起，js 线程被停止执行，长连接和轮询都不会生效，切回前台后会调用一次 pOrderStatus 主动感知订单状态变化。</p><p>客户端上逻辑基本差不多，只是切后台后，操作系统的表现不一样，长连接和轮询还可能继续生效一段时间，切前台也会掉 pOrderStatus 主动感知订单状态变化</p><h3 id="23-服务端返回轮询间隔"><a class="markdownIt-Anchor" href="#23-服务端返回轮询间隔">#</a> 2.3 服务端返回轮询间隔：</h3><p>轮询时间依赖 pOrderStatus 的 interval_time 字段，按照订单状态和 productId 指定了不同的数值，在 Apollo 中配置</p><p>相关 Apollo：<a href="http://ab.intra.xiaojukeji.com/conf/6/1872/2142/22602">Apollo 配置同步</a>，目前 等待司机接单（status=7） 的轮询时间为 30s</p><table><thead><tr><th>STATUS</th><th>SUB_STATUS</th><th>兜底值</th><th>productID=0 默认值</th></tr></thead><tbody><tr><td>0 默认</td><td><br></td><td>-1 (不再请求)</td><td>-1</td></tr><tr><td>1 待出发</td><td><br></td><td>出发时间刷新</td><td><br></td></tr><tr><td>2 已关闭</td><td><br></td><td>-1</td><td>-1</td></tr><tr><td>3 已完成</td><td><br></td><td>-1</td><td>-1</td></tr><tr><td>4 进行中</td><td>4001 等待接驾</td><td>120</td><td>120</td></tr><tr><td>5 待支付</td><td><br></td><td>60</td><td>60</td></tr><tr><td>6 已取消</td><td><br></td><td>-1</td><td>-1</td></tr><tr><td>7 等待司机接单</td><td><br></td><td>webapp 60 其他 30</td><td><br></td></tr><tr><td><br></td><td>4002 司机迟到</td><td>30</td><td>30</td></tr><tr><td><br></td><td>4003 司机到达</td><td>120</td><td>120</td></tr><tr><td><br></td><td>4004 乘客迟到</td><td>120</td><td>120</td></tr><tr><td><br></td><td>4006 计费中</td><td>300</td><td>300</td></tr></tbody></table><h3 id="24-数据分析"><a class="markdownIt-Anchor" href="#24-数据分析">#</a> 2.4 数据分析</h3><h4 id="241-端上埋点"><a class="markdownIt-Anchor" href="#241-端上埋点">#</a> 2.4.1 端上埋点</h4><p>长连接 push 切接驾 &amp; 轮询切接驾的占比分析，目前只有小程序上线了埋点：</p><p>轮询跳转司机接驾页比例：</p><p>微信小程序： 2.2% =152358/(152358+6545241+152358)</p><p>支付宝小程序：11.3% = 88052/(88052+50396+635613)</p><h4 id="242-ab实验"><a class="markdownIt-Anchor" href="#242-ab实验">#</a> 2.4.2 AB 实验</h4><p>通过做一个 ab 实验，单独提高一个城市的轮询间隔 30s→5s 来观测乘客被接单后的感知时长是否降低</p><p>城市取南京市：07.24 15:00 发布完 Apollo</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>城市</td><td>全部</td><td></td><td></td><td>南京</td><td></td><td></td><td>杭州</td><td></td><td></td><td>上海</td><td></td><td></td></tr><tr><td><br></td><td>avg</td><td>p95</td><td>p99</td><td>avg</td><td>p95</td><td>p99</td><td>avg</td><td>p95</td><td>p99</td><td>avg</td><td>p95</td><td>p99</td></tr><tr><td>7.22</td><td>2.86</td><td>3</td><td>31</td><td>2.97</td><td>3.00</td><td>31.00</td><td>3.35</td><td>3.00</td><td>38.00</td><td>3.40</td><td>3.00</td><td>40.00</td></tr><tr><td>7.23</td><td>2.22</td><td>3</td><td>29</td><td>2.14</td><td>3.00</td><td>29.00</td><td>2.37</td><td>3.00</td><td>30.00</td><td>2.14</td><td>2.00</td><td>29.00</td></tr><tr><td>7.24</td><td>2.19</td><td>3</td><td>25</td><td>1.98</td><td>2.00</td><td><strong>16.00</strong></td><td>2.31</td><td>3.00</td><td>29.00</td><td>2.16</td><td>2.00</td><td>29.00</td></tr><tr><td>7.25</td><td>2.25</td><td>3.00</td><td>28.00</td><td>2.02</td><td>3.00</td><td>7.00</td><td>2.40</td><td>3.00</td><td>29.00</td><td>2.13</td><td>3.00</td><td>29.00</td></tr></tbody></table><p>目前看 24、25 号数据，对比全部城市，上海，杭州，P99 下降明显，降低轮询是有效的</p><h3 id="25-优化"><a class="markdownIt-Anchor" href="#25-优化">#</a> 2.5 优化</h3><p>我们主要优化的地方是<strong>乘客被接单后感知被接单的时长</strong>。降低 pOrderStatus 的轮询间隔可以降低长链接不可以用时，乘客被接单的感知时长。</p><p>降低 sub_status=4001 status=7 的 pOrderStatus 的轮询间隔为 5s，随之带来的问题是 pOrderStatus 的 qps 上涨，接口可能会抗不住，尤其是当运力不足的情况下，大量用户处于 status=7 的状态。</p><p>我们可以使用缓存来抗流量的上涨，同时本身也有的接口限流可以防止服务被打死，还有 pOrderStatus 有常态的降级轮询的 911 预案。</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>方案 1：缓存 /dos/getOrderInfo</td><td>pOrderStatus qps 上涨核心影响的是 dos，只缓存 dos，其他业务逻辑不受影响，改动也最小。</td><td>1. 其他的一些下游，如 uranus、拼车、治理的 qps 也会上涨<br>2. passenger-center 自身的 cpu 占用还在</td></tr><tr><td>方案 2：缓存整个 pOrderStatus 的响应</td><td>性能最优，只会调用一次 Redis</td><td>需要梳理 是否可以缓存响应中的字段（已梳理）</td></tr><tr><td>方案 3: 等待应答阶段依靠 pOderMatch 轮询 (5s)</td><td>1. 从端上改造更治本，服务端需要任何成本<br>2. 减少了 pOrderStatus 的流量，原有的降级手段应该可以抛弃</td><td>新版本覆盖需要时间</td></tr></tbody></table><p>请求比较多的下游 TOP10</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>● sum/callee-func=/dos/getOrderInfo,</td></tr><tr><td>● sum/callee-func=/gulfstream/unicorn/v1/serviceControl/getControlConfig,</td></tr><tr><td>● sum/callee-func=GetOrder,</td></tr><tr><td>● sum/callee-func=mget,</td></tr><tr><td>● sum/callee-func=/ihap-door-gods/passenger/query,</td></tr><tr><td>● sum/callee-func=/gulfstream/pay/v1/cashier/getBatchFeeDetail,</td></tr><tr><td>● sum/callee-func=/gulfstream/themis/v2/feeObjection/passengerCanFeeObjection,</td></tr><tr><td>● sum/callee-func=/passport/ticket/v5/validate,</td></tr><tr><td>● sum/callee-func=/cplat/uranusapi/driver/getDriver,</td></tr><tr><td>● sum/callee-func=/gulfstream/carpool/v1/travel/cGetRoutePlan,</td></tr></tbody></table><h4 id="251-方案2-缓存整个porderstatus的响应的逻辑"><a class="markdownIt-Anchor" href="#251-方案2-缓存整个porderstatus的响应的逻辑">#</a> 2.5.1 方案 2 缓存整个 pOrderStatus 的响应的逻辑：</h4><p order_id="">TTL 设置为 30s，key 命名：P_ORDER_STATUS_</p><h5 id="2511-边界-异常场景"><a class="markdownIt-Anchor" href="#2511-边界-异常场景">#</a> 2.5.1.1 边界、异常场景：</h5><h6 id="25111-porderstatus的响应除了订单的信息还有一些字段需要明确含义看是否有影响"><a class="markdownIt-Anchor" href="#25111-porderstatus的响应除了订单的信息还有一些字段需要明确含义看是否有影响">#</a> 2.5.1.1.1 pOrderStatus 的响应，除了订单的信息，还有一些字段需要明确含义，看是否有影响。</h6><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;errno&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;errmsg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SUCCESS&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sub_status&quot;</span><span class="punctuation">:</span> <span class="number">4001</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;加密订单号&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;is_mini_intrip_new_style&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 来自Apollo</span></span><br><span class="line">        <span class="attr">&quot;prepay_query&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// dos</span></span><br><span class="line">        <span class="attr">&quot;interval_time&quot;</span><span class="punctuation">:</span> <span class="number">120</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fee_objection_status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 来自themis 订单费用异议状态</span></span><br><span class="line">        <span class="attr">&quot;new_order_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 改派新订单 根据订单状态判断</span></span><br><span class="line">        <span class="attr">&quot;is_timeout&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 计算得到 订单是否播单超时，根据order信息计算</span></span><br><span class="line">        <span class="attr">&quot;timeout_msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 同上，超时文案</span></span><br><span class="line">        <span class="attr">&quot;is_driver_passenger_both_show&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 来自Apollo 设置符合显示司乘同显条件，部分场景不展示</span></span><br><span class="line">        <span class="attr">&quot;scene_type&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 计算得到  端在轮询pOrderStatus时，可以感知scene_type的变化，做相应的动作,后续有类似场景可复用该字段</span></span><br><span class="line">        <span class="attr">&quot;kf_use_bronze_door&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 来自Apollo 花小猪 是否使用青铜门</span></span><br><span class="line">        <span class="attr">&quot;from_area&quot;</span><span class="punctuation">:</span> <span class="number">82</span><span class="punctuation">,</span> <span class="comment">// 来自dos</span></span><br><span class="line">        <span class="attr">&quot;line_md5&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 路线MD5值 拼车用于去感知订单状态变化、拼友加入、路线变化等。行程中使用</span></span><br><span class="line">        <span class="attr">&quot;freeze_status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span> <span class="comment">// dos</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>挨个分析看，很多字段来着 dos，Apollo，计算所得，当我们缓存 30s 的情况下，情况不会比之前更差。</p><h6 id="25112-司机改派"><a class="markdownIt-Anchor" href="#25112-司机改派">#</a> 2.5.1.1.2 司机改派</h6><p>司机改派后会走 mq，执行 interna-api 的 driverReassignHook，push 乘客端订单状态变化</p><p>需要再这里也将 pOrderStatus 的缓存 key 删除</p><h6 id="25113-redis读写失败-甚至挂掉的情况"><a class="markdownIt-Anchor" href="#25113-redis读写失败-甚至挂掉的情况">#</a> 2.5.1.1.3 Redis 读写失败、甚至挂掉的情况</h6><p>TTL 为 30s，和之前的轮询间隔保持一致。</p><p>把 Redis 定位成一个弱依赖，用于提高接口性能，挂掉不影响正常业务流程，但是会接口负载能力会下降。</p><p>Redis 读取失败时，直接忽略，走后面的正常逻辑，此时下次的轮询时间会被重新设置为 30s，所以接口的 qps 会自然下降。</p><p>Redis 写入失败时，轮询时间还是 30s，不影响原有正常逻辑</p><p>Redis 挂掉的情况下，读写全部失败，轮询时间还是 30s，不影响原有逻辑。</p><p>yuying 回调删除 key 失败时，依靠 key 自动过期，因为 ttl 是 30s，30s 后自动失效，不会比 30s 轮询时候更差。</p><h5 id="2512-稳定性"><a class="markdownIt-Anchor" href="#2512-稳定性">#</a> 2.5.1.2 稳定性</h5><p>2.5.3.1 pOrderStatus 接口限流保障服务不会被打死</p><p>2.5.3.2 pOrderStatus 有常态的降级轮询的 911 预案，保障紧急情况下可统一降级</p><p>2.5.3.3 优化方案通过 Apollo 灰度发布，有问题及时回滚</p><p>2.5.3.4 Redis 读取、写入、删除失败时记录日志，并配置报警，增加 metric 观测使用缓存的请求数量。</p><h4 id="252-方案3-等待应答阶段依靠podermatch轮询5s"><a class="markdownIt-Anchor" href="#252-方案3-等待应答阶段依靠podermatch轮询5s">#</a> 2.5.2 方案 3 等待应答阶段依靠 pOderMatch 轮询 (5s)</h4><p>乘客发单后，会同时轮询 pOrderMatch 和 pOrderStatus，pOrderMatch 是 5s 轮询一次，在等待应答阶段，可以在 pOrderMatch 中告知端上是否被接单，被接单的情况下再去调用 pOrderStatus</p><p>原有的 pOderStatus 轮询逻辑不变</p><p>只有当 stop_query=true 时，调用一次 pOrderStatus</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;errno&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;errmsg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;stop_query&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;query_step&quot;</span><span class="punctuation">:</span> <span class="number">15</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-长连接"><a class="markdownIt-Anchor" href="#3-长连接">#</a> 3. 长连接</h2><h3 id="31-现状"><a class="markdownIt-Anchor" href="#31-现状">#</a> 3.1 现状</h3><h4 id="311-服务端统计"><a class="markdownIt-Anchor" href="#311-服务端统计">#</a> 3.1.1 服务端统计</h4><p>DMC 统计司机接单后的 push 乘客端的触达率：</p><p>其中超时占比 6.86%，代表 10s 内端上没有回复 ACK 的，这部分认为是端内 push 失败的。</p><h4 id="312-端上统计"><a class="markdownIt-Anchor" href="#312-端上统计">#</a> 3.1.2 端上统计</h4><p>小程序埋点：</p><p><strong>依靠轮询跳转司机接驾页占比：</strong></p><p>微信小程序： 2.2% =152358/(152358+6545241+152358)</p><p>支付宝小程序：11.3% = 88052/(88052+50396+635613)</p><p><strong>长连接在线状态</strong></p><hr><p>微信：连接错误率 = 连接错误 / 连接错误 + 连接成功 = 14.5%  连接打开：连接被关闭 ≈ 1:1</p><p>支付宝：连接错误率 = 连接错误 / 连接错误 + 连接成功 = 11.5%   连接打开：连接被关闭  ≈ 7:4</p><p>具体问题还需要小程序侧分析</p><p>Native 目前不好看清：</p><p>本周会上线建连失败的统计 @唐怀宝 8 月初</p><p>iOS 有 10% 左右的长链接失败导致降级短链的</p><p>Android 有 17%</p><p>这部分包含切后台的、不兼容 ipv6、弱网</p><h3 id="32-优化"><a class="markdownIt-Anchor" href="#32-优化">#</a> 3.2 优化</h3><p>需要等端上埋点发版后，看清数据，优先解决一些已知问题 （不兼容 ipv6、弱网）</p><p>pOrderStatus 的调用量很大，早晚高峰双机房 QPS 在 62k 左右，pOrderDetail32kQPS</p><p>一些问题：</p><p>如果降低轮询时间，pOrderStatus 的 qps 上涨，会把接口打挂。</p><p>可以使用缓存来抗流量上涨。</p><p>也可以对用户排队顺序进行优化。</p><p>派单成功后在 pOrderStatus 之前就把订单信息写入 redis，pOrderStatus 直接去看里面是否存在要查询的订单</p><p>（存在问题，如果司机取消订单，缓存已经写好，如何处理</p><p>司机改派后会走 mq，执行 interna-api 的 driverReassignHook,push 乘客端变化）</p><p>只缓存 30s</p><p>redis 挂了也没影响</p><p>### qps</p><p><strong>QPS</strong>：Queries Per Second 意思是 “每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</p><p>**TPS：** 是 TransactionsPerSecond 的缩写，也就是事务数 / 秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p><strong>QPS vs TPS</strong>：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个 TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入 “QPS” 之中。如，访问一个页面会请求服务器 2 次，一次访问，产生一个 “T”，产生 2 个 “Q”</p><p>### 长连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;# 乘客应答时长感知优化&lt;/p&gt;
&lt;p&gt;## 感知时长：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;乘客呼单时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;订单创建时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;订单到达 duse 时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;duse 完成播单时</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>思考</title>
    <link href="https://flowerhai.github.io/2023/08/02/qiu-zhao/si-kao/"/>
    <id>https://flowerhai.github.io/2023/08/02/qiu-zhao/si-kao/</id>
    <published>2023-08-02T08:00:55.000Z</published>
    <updated>2023-08-02T08:02:02.381Z</updated>
    
    <content type="html"><![CDATA[<p>## grpc 与注册中心相关</p><p>运行过程中，客户端链接不上注册中心怎么办</p><p>运行过程中，客户端拿到了注册数据，但是链接不上对应的服务端怎么办</p><p>运行过程中，注册中心没有收到服务端心跳怎么办</p><p>注册中心崩了，客户端和服务端怎么办</p><p>## 负载均衡相关</p><p>如果发起调用的时候，服务端调不同，那么该怎么办</p><p>什么是 fail-over?</p><p>什么是微服务广播，以及微服务广播的应用场景</p><p>什么是微服务组播</p><p>怎么设置服务器权重</p><p>为什么设置了负载均衡，还是会出现某台服务器被打爆的场景</p><p>客户端负载均衡和网关负载均衡有什么区别</p><p>什么是微服务路由</p><p>如何自定义负载均衡算法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;## grpc 与注册中心相关&lt;/p&gt;
&lt;p&gt;运行过程中，客户端链接不上注册中心怎么办&lt;/p&gt;
&lt;p&gt;运行过程中，客户端拿到了注册数据，但是链接不上对应的服务端怎么办&lt;/p&gt;
&lt;p&gt;运行过程中，注册中心没有收到服务端心跳怎么办&lt;/p&gt;
&lt;p&gt;注册中心崩了，客户端和服务端怎么</summary>
      
    
    
    
    
    <category term="秋招" scheme="https://flowerhai.github.io/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>滴滴</title>
    <link href="https://flowerhai.github.io/2023/07/24/ddmq/"/>
    <id>https://flowerhai.github.io/2023/07/24/ddmq/</id>
    <published>2023-07-24T07:37:33.000Z</published>
    <updated>2023-07-24T08:22:42.545Z</updated>
    
    <content type="html"><![CDATA[<p>实习摸鱼中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实习摸鱼中&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="实习" scheme="https://flowerhai.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>为什么收到三次重复ACK才会启动快重传？</title>
    <link href="https://flowerhai.github.io/2023/06/04/tt/"/>
    <id>https://flowerhai.github.io/2023/06/04/tt/</id>
    <published>2023-06-04T09:37:13.000Z</published>
    <updated>2023-06-04T09:37:32.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么收到三次重复ack才会启动快重传"><a class="markdownIt-Anchor" href="#为什么收到三次重复ack才会启动快重传">#</a> 为什么收到三次重复 ACK 才会启动快重传？</h3><p>一般回答都是说因为两次冗余 ACK 报文是因为网络拥塞，而三次大概率是发生了丢包，但是这是为什么呢？</p><p>假设 A 发送的 TCPsegment 的序列号为</p><p>n-1, n, n+1, n+2</p><p>B 理想收到的为</p><p>n-1, n, n+1, n+2</p><p>A 收到一个 ACK (n) 的情况如下：</p><p>n-1, n, n +1, n+2</p><p>n-1, n, n+2, n+1</p><p>A 收到 2 个 ACK (n):</p><p>n-1, n+2, n, n+1</p><p>n-1, n+1, n, n+2</p><p>A 收到 3 个 ACK (n):</p><p>n-1, n+2, n+1, n</p><p>n-1, n+1, n+2, n</p><p>当发生丢包时一定会收到三个重复 ACK，理由如下</p><p>n-1,n+2,n+1</p><p>n-1,n+1,n+2</p><p>所以此时大概率会发生丢包，但是在实际情况下抓包发现，一般都是在更多次的时候才会启动快重传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么收到三次重复ack才会启动快重传&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么收到三次重复ack才会启动快重传&quot;&gt;#&lt;/a&gt; 为什么收到三次重复 ACK 才会启动快重传？&lt;/h3&gt;
&lt;p&gt;一般回答都是说因为两次冗余 ACK</summary>
      
    
    
    
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动 一面</title>
    <link href="https://flowerhai.github.io/2023/05/22/mianshi/mian-4/"/>
    <id>https://flowerhai.github.io/2023/05/22/mianshi/mian-4/</id>
    <published>2023-05-22T13:35:50.000Z</published>
    <updated>2023-05-22T13:36:29.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字节一面"><a class="markdownIt-Anchor" href="#字节一面">#</a> 字节一面</h2><h3 id="session-key和cookie是什么两者有啥区别分别储存在哪里"><a class="markdownIt-Anchor" href="#session-key和cookie是什么两者有啥区别分别储存在哪里">#</a> session key 和 cookie 是什么，两者有啥区别，分别储存在哪里</h3><p>当涉及到网络通信和身份验证时，会涉及到 &quot;session key&quot; 和 &quot;cookie&quot; 这两个术语。</p><p>“Session key”（会话密钥）是一个用于加密和解密网络通信数据的临时密钥。在安全通信协议中，当客户端与服务器建立会话时，会生成一个随机的会话密钥。这个密钥在会话期间用于加密和解密数据，以确保通信的机密性和完整性。会话密钥一般会定期更换，以增加安全性。</p><p>“Cookie”（Cookie 文件）是在客户端（例如浏览器）存储的小型文本文件，用于跟踪和存储有关用户访问网站的信息。当用户访问一个网站时，服务器可以通过在响应中发送一个包含特定信息的 Cookie，然后客户端将该 Cookie 存储在本地。在随后的请求中，客户端会将 Cookie 发送回服务器，从而使服务器能够识别和跟踪用户的会话状态和偏好设置。Cookie 可以包含诸如会话标识符、过期时间、访问权限等信息。</p><h3 id="c中左值和右值"><a class="markdownIt-Anchor" href="#c中左值和右值">#</a> C++ 中左值和右值</h3><p>在 C++ 中，左值（lvalue）和右值（rvalue）是用于描述表达式的两个概念。它们与赋值、引用和对象生命周期等相关。</p><ol><li>左值（lvalue）：<ul><li>左值是一个标识符，代表一个具体的内存位置。可以理解为具有名称的表达式，它可以在赋值操作中作为目标或源使用。</li><li>左值可以出现在赋值语句的左边或右边。例如， <code>int x = 10;</code>  中的 <code>x</code>  就是一个左值。</li><li>左值可以取地址，可以被修改。</li></ul></li><li>右值（rvalue）：<ul><li>右值是一个临时的、无法寻址的值，没有名称。可以理解为没有持久身份的表达式。</li><li>右值通常是在表达式中产生的中间结果或临时值，例如常量、表达式的结果或函数返回的临时对象。</li><li>右值不能出现在赋值语句的左边。例如， <code>10 = x;</code>  是非法的，因为 <code>10</code>  是一个右值。</li><li>右值不能取地址，不能被修改。</li></ul></li></ol><p>C++11 引入了右值引用（rvalue references）的概念，它允许开发人员有效地识别并处理右值。右值引用可以延长右值的生命周期，允许我们移动资源而不是进行昂贵的复制操作。例如，通过使用移动语义，可以高效地将临时对象的内容转移到新对象中。</p><p>在 C++ 中，可以通过 <code>&amp;&amp;</code>  来定义右值引用类型，例如 <code>int&amp;&amp;</code>  表示一个右值引用。左值引用则使用 <code>&amp;</code>  符号，例如 <code>int&amp;</code>  表示一个左值引用。</p><p>总结： 左值是具有名称和可寻址性的表达式，而右值是临时的、无法寻址的表达式。右值通常是临时值或中间结果，而左值则可以持久存在并进行修改。右值引用是 C++ 中用于处理右值的特殊引用类型，它允许延长右值的生命周期，并支持移动语义。</p><h3 id="stdmove"><a class="markdownIt-Anchor" href="#stdmove">#</a> std::move</h3><p>在 C++ 中， <code>std::move()</code>  是一个函数模板，用于将对象标记为右值引用，以便在适当的情况下使用移动语义。它是通过将左值强制转换为对应的右值引用类型来实现的。</p><p><code>std::move()</code>  的作用是告诉编译器，我们希望以移动方式处理被标记的对象，而不是进行常规的拷贝操作。它通常用于以下情况：</p><ol><li>移动语义： <code>std::move()</code>  在移动语义中发挥重要作用。通过将对象标记为右值引用，我们可以在资源的所有权转移时避免昂贵的拷贝操作，而是直接将资源从一个对象转移到另一个对象。这对于管理动态内存、容器元素的重新分配等情况非常有用。</li><li>完美转发： <code>std::move()</code>  可以与模板和通用函数一起使用，以实现完美转发（perfect forwarding）。通过将函数参数标记为右值引用，可以在函数内部将其转发到其他函数，保持其原始的值类别（左值或右值）。这对于实现泛型代码和避免多余的拷贝非常有用。</li></ol><p>需要注意的是， <code>std::move()</code>  本身并不执行任何实际的移动操作。它只是将对象标记为右值引用，以便编译器知道可以使用移动语义。实际的移动操作由对象的移动构造函数或移动赋值运算符负责。</p><p>使用  <code>std::move()</code>  需要谨慎，因为一旦对象被标记为右值引用后，我们不能再对其进行常规的读取和修改操作，因为其状态可能已经发生了改变。确保在适当的时机使用  <code>std::move()</code> ，并且理解移动语义的工作原理非常重要。</p><h3 id="c中四种强制类型转换"><a class="markdownIt-Anchor" href="#c中四种强制类型转换">#</a> C++ 中四种强制类型转换</h3><ol><li>静态转换（Static Cast）： <code>static_cast</code>  可以执行基本类型之间的隐式或显式转换，也可以用于类层次结构中的上行转换（派生类到基类）和下行转换（基类到派生类）。它还可以执行其他类型之间的转换，如枚举类型的转换和指针之间的转换（但不进行运行时检查）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeint num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num);</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure><ol><li>动态转换（Dynamic Cast）： <code>dynamic_cast</code>  用于在类层次结构中进行类型转换，并在进行下行转换时进行运行时类型检查。它只能用于指针或引用类型，并且在转换失败时返回空指针（对于指针）或引发  <code>std::bad_cast</code>  异常（对于引用）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeBase* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>常量转换（Const Cast）： <code>const_cast</code>  用于移除对象的常量性质（const）或将对象的常量性质添加到非常量对象。它主要用于修改指针或引用的底层常量性质。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeconst <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;num);</span><br><span class="line">*ptr = <span class="number">20</span>;  <span class="comment">// Undefined behavior</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* constPtr = &amp;num;</span><br><span class="line"><span class="type">int</span>* nonConstPtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(constPtr);</span><br></pre></td></tr></table></figure><ol><li>重新解释转换（Reinterpret Cast）： <code>reinterpret_cast</code>  允许将一个类型的指针或引用转换为完全不相关的类型。它提供了一种底层的、低级别的转换，可以将任意类型的指针转换为其他任意类型的指针，或将指针类型转换为整数类型，反之亦然。这种转换非常危险，需要慎用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeint num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span>* doublePtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(&amp;num);</span><br></pre></td></tr></table></figure><p>需要注意的是，强制类型转换操作符应该谨慎使用，因为它们可能引入类型安全问题和未定义行为。在进行类型转换时，务必确保转换是正确和安全的，并尽量避免过度依赖强制类型转换。</p><h3 id="一个cpp里extern了一个变量怎么在另一个cpp中用"><a class="markdownIt-Anchor" href="#一个cpp里extern了一个变量怎么在另一个cpp中用">#</a> 一个 cpp 里 extern 了一个变量，怎么在另一个 cpp 中用</h3><p>在一个 CPP 文件中使用另一个 CPP 文件中 extern 声明的变量，需要遵循以下步骤：</p><ol><li><p>在需要使用 extern 变量的 CPP 文件中，使用 extern 关键字来声明该变量。extern 声明告诉编译器该变量是在其他 CPP 文件中定义的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="comment">// file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myVariable; <span class="comment">// 声明外部变量</span></span><br></pre></td></tr></table></figure></li><li><p>在另一个 CPP 文件中定义该变量，并赋予它一个值。此定义应该在函数定义之外，通常在头文件中定义全局变量的声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="comment">// file2.cpp</span></span><br><span class="line"><span class="type">int</span> myVariable = <span class="number">42</span>; <span class="comment">// 定义外部变量并赋值</span></span><br></pre></td></tr></table></figure></li><li><p>编译时，将这两个 CPP 文件一起编译成一个可执行文件。确保将两个 CPP 文件一起传递给编译器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line">g++ file1.cpp file2.cpp -o myProgram</span><br></pre></td></tr></table></figure></li><li><p>在需要使用该 extern 变量的 CPP 文件中，就可以直接使用该变量了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myVariable; <span class="comment">// 声明外部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; myVariable &lt;&lt; std::endl; <span class="comment">// 使用外部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过使用 extern 声明和定义变量，可以将一个变量从一个 CPP 文件传递到另一个 CPP 文件中，并在需要的地方使用它。重要的是确保在使用 extern 变量之前，该变量已经在另一个 CPP 文件中定义和赋值。</p><h3 id="static可以修饰虚函数吗"><a class="markdownIt-Anchor" href="#static可以修饰虚函数吗">#</a> static 可以修饰虚函数吗</h3><p>在 C++ 中， <code>static</code>  关键字可以修饰类的成员函数，包括虚函数。然而， <code>static</code>  修饰符与虚函数的概念存在一些冲突，因此它们通常不会同时使用。</p><p>虚函数是用于实现运行时多态的机制，允许在派生类中重写基类的虚函数。它们通过动态绑定实现函数的调用，根据对象的实际类型决定调用哪个函数。</p><p>而  <code>static</code>  关键字指示静态成员函数或静态数据成员，它们与类本身关联，而不是与类的实例相关。静态成员函数不依赖于特定的对象，因此它们无法使用动态绑定。</p><p>当  <code>static</code>  关键字用于虚函数时，它会覆盖虚函数的动态绑定特性。静态成员函数不能被继承，因此也不能在派生类中重写。这意味着无论对象的实际类型如何，静态成员函数始终是通过类名进行调用，而不是通过对象。</p><p>考虑以下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::bar()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">foo</span>();  <span class="comment">// 动态绑定，调用 Derived::foo()</span></span><br><span class="line">    obj-&gt;<span class="built_in">bar</span>();  <span class="comment">// 静态成员函数，调用 Base::bar()</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中， <code>Base</code>  类中的  <code>foo()</code>  是虚函数，因此在派生类  <code>Derived</code>  中进行了重写。当通过基类指针  <code>obj</code>  调用  <code>foo()</code>  时，由于动态绑定的作用，会调用  <code>Derived</code>  类中的  <code>foo()</code> 。</p><p>然而， <code>Base</code>  类中的  <code>bar()</code>  是静态成员函数，它不能被派生类重写，也不具备动态绑定的特性。无论  <code>obj</code>  的实际类型是什么，调用  <code>bar()</code>  都会直接调用  <code>Base</code>  类中的  <code>bar()</code> 。</p><p>因此，虽然可以在语法上使用  <code>static</code>  修饰虚函数，但它会覆盖虚函数的多态行为，导致静态成员函数的调用。在一般情况下，不建议同时将  <code>static</code>  和  <code>virtual</code>  应用于同一个函数。</p><h3 id="解决tcp黏包"><a class="markdownIt-Anchor" href="#解决tcp黏包">#</a> 解决 TCP 黏包</h3><p>在 TCP 通信中，黏包（Packet Pasting）是指发送方发送的多个数据包被接收方当作一个大的数据块接收，或者多个小的数据包被接收方合并成一个大的数据块接收。这可能导致接收方无法正确解析数据包的边界，从而造成数据解析错误。</p><p>以下是几种解决 TCP 黏包问题的常用方法：</p><ol><li>消息长度固定：发送方在每个数据包中包含固定长度的消息头，用于指示后续数据包的长度。接收方在接收数据时先读取消息头，根据消息头中的长度信息来分割数据包。</li><li>特殊字符分割：发送方在数据包之间插入特殊的分隔符，例如换行符或特定字符序列。接收方根据分隔符将接收到的数据分割为多个数据包。</li><li>使用消息边界标记：发送方在每个数据包的末尾添加一个特殊的边界标记，用于指示数据包的结束。接收方通过寻找边界标记来分割数据包。</li><li>使用消息头：发送方在每个数据包的头部包含一些元数据，例如消息的长度或消息类型。接收方先读取消息头，根据消息头中的信息来解析接收到的数据。</li><li>序列号或标识符：发送方为每个数据包分配一个唯一的序列号或标识符。接收方通过检查序列号或标识符来验证接收到的数据包的顺序和完整性。</li></ol><h3 id="析构函数使用虚函数"><a class="markdownIt-Anchor" href="#析构函数使用虚函数">#</a> 析构函数使用虚函数</h3><p>析构函数使用虚函数的主要原因是为了实现多态的析构行为。</p><p>当基类指针指向派生类对象并使用  <code>delete</code>  运算符删除指针时，如果基类的析构函数不被声明为虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类的资源无法得到正确释放，造成资源泄漏。</p><p>通过将基类的析构函数声明为虚函数，可以在运行时实现动态绑定，确保在使用基类指针删除对象时，会调用派生类的析构函数。这样就可以正确释放派生类及其成员的资源。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        <span class="comment">// Base类的析构函数（虚函数）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">// Derived类的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr; <span class="comment">// 调用Derived的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，基类  <code>Base</code>  的析构函数被声明为虚函数。当使用  <code>delete</code>  删除基类指针  <code>ptr</code>  时，由于基类的析构函数是虚函数，因此会动态绑定到派生类  <code>Derived</code>  的析构函数，从而正确地销毁  <code>Derived</code>  对象。</p><h3 id="set和unorderer_map"><a class="markdownIt-Anchor" href="#set和unorderer_map">#</a> set 和 unorderer_map</h3><p><code>std::set</code>  是一个有序集合容器，它使用红黑树（Red-Black Tree）实现。以下是  <code>std::set</code>  的特点：</p><ul><li>元素按照一定的排序规则（默认是升序）进行存储，并且每个元素在集合中是唯一的，不允许重复。</li><li>插入、删除和查找操作的平均时间复杂度为对数级别（O (log n)），具有较快的查找性能。</li><li>支持按照排序顺序进行遍历和访问元素。</li></ul><p><code>std::unordered_map</code>  是一个哈希表容器，它使用哈希函数和开链法（Separate Chaining）处理哈希冲突。以下是  <code>std::unordered_map</code>  的特点：</p><ul><li>元素按照键值对的形式存储，每个键在容器中是唯一的，而值可以重复。</li><li>插入、删除和查找操作的平均时间复杂度为常数级别（O (1)），具有快速的插入和查找性能。</li><li>元素在哈希表中的存储位置是无序的，没有固定的顺序。</li></ul><p>根据上述特点，你可以选择适合你需求的容器：</p><ul><li>如果你需要一个有序的集合，且不允许重复元素，那么  <code>std::set</code>  是更适合的选择。</li><li>如果你需要一个键值对的集合，并且对于快速的插入、删除和查找操作更为关注，而不需要元素的顺序，那么  <code>std::unordered_map</code>  是更适合的选择。</li></ul><p>需要注意的是， <code>std::unordered_map</code>  的性能可能受到哈希函数的选择和哈希冲突的影响。在选择使用  <code>std::unordered_map</code>  时，需要确保选择合适的哈希函数，并且适当调整负载因子和桶的数量以获得更好的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字节一面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#字节一面&quot;&gt;#&lt;/a&gt; 字节一面&lt;/h2&gt;
&lt;h3 id=&quot;session-key和cookie是什么两者有啥区别分别储存在哪里&quot;&gt;&lt;a class=&quot;markdownIt-Anc</summary>
      
    
    
    
    
    <category term="面试总结" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>并行计算环境搭建</title>
    <link href="https://flowerhai.github.io/2023/05/20/bingxing/ab/"/>
    <id>https://flowerhai.github.io/2023/05/20/bingxing/ab/</id>
    <published>2023-05-20T05:56:53.000Z</published>
    <updated>2023-05-20T09:15:04.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验环境配置"><a class="markdownIt-Anchor" href="#实验环境配置">#</a> 实验环境配置</h3><p>阅读实验手册发现，并没有地方需要使用 openEuler 20.03 操作系统</p><p>如果硬用 openEuler 20.03 各种恶心人的问题。</p><p>不如直接选择 Ubuntu 系统，安装各种包更方便。<br>同时推荐使用 xhell，xftp 对云服务器进行操作</p><p>这是我的开发环境，别忘了购买公网 IP。<br>注意要选择高性能计算型，否则 make -j2 那里会出现问题<br> 2vCPUs | 4GiB | h3.large.2<br>Ubuntu 22.04 server 64bit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mpich</span><br></pre></td></tr></table></figure><p>输入即可。</p><p>随后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/xianyi/OpenBLAS/archive/v0.3.8.tar.gz</span><br><span class="line">tar -zxvf v0.3.8.tar.gz &amp;&amp; cd OpenBLAS-0.3.8</span><br><span class="line">make -j2</span><br><span class="line">sudo make PREFIX=/usr/local/openblas install</span><br><span class="line">sudo chmod -R 777 /usr/local/openblas/</span><br><span class="line">sudo ln -s /usr/local/openblas/lib/libopenblas.so /usr/lib/libopenblas.so</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vim之后添加</span></span><br><span class="line">export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/openblas/include</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/openblas/lib</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line">make</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br><span class="line">ip b</span><br><span class="line">(ip是指ifconfig看到的那个ip)</span><br></pre></td></tr></table></figure><h2 id="搭建多机集群"><a class="markdownIt-Anchor" href="#搭建多机集群">#</a> 搭建多机集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>假设一个机器为 a, 另外一个机器为 b。<br>用 ifconfig 查看 ip。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 192.xxx.0.xxx</span><br><span class="line">b 192.xxx.0.xxx</span><br></pre></td></tr></table></figure><p>此处 xxx 是为了隐藏我的 ip</p><p>切入下目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ssh</span><br><span class="line">vim sshd_config</span><br></pre></td></tr></table></figure><p>随后将某些注销去掉并改值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Port 22 端口号，服务器和客户端相同即可</span><br><span class="line">ListenAddress 0.0.0.0   打开监听所有端口</span><br><span class="line">PermitRootLogin yes 允许远程客户进入根权限</span><br><span class="line">PublicAuthentication yes 打开密钥对认证模式</span><br><span class="line">AuthorizedKeysFile .ssh/yourname.pub 名称为yourname.pub的公钥放置处</span><br><span class="line">PasswordAuthentication yes 需要密码认证</span><br><span class="line">PermitEmptyPasswords yes 允许空密码</span><br></pre></td></tr></table></figure><h4 id="随后输入"><a class="markdownIt-Anchor" href="#随后输入">#</a> 随后输入</h4><p>a</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cp id_rsa.pub authorized_keys</span><br><span class="line">chmod 777 authorized_keys</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp authorized_keys a@b:~/.ssh/</span><br></pre></td></tr></table></figure><p>执行完后输入 b 的密码</p><p>b</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cp authorized_keys authorized_keys</span><br><span class="line">chmod 777 authorized_keys</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp authorized_keys b@a:~/.ssh/</span><br></pre></td></tr></table></figure><p>如果 scp authorized_keys b@a:~/.ssh/ 这行不起作用，手动更换。</p><p>将 a 和 b 生成的 authorized_keys 交换。</p><p>此时 a,b 以及搭建成为集群。</p><p>至此，开发环境搭建完毕，20min，如果是 openEuler, 此过程需要 n 小时，后续 copy 代码即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实验环境配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验环境配置&quot;&gt;#&lt;/a&gt; 实验环境配置&lt;/h3&gt;
&lt;p&gt;阅读实验手册发现，并没有地方需要使用 openEuler 20.03 操作系统&lt;/p&gt;
&lt;p&gt;如果硬用 openEul</summary>
      
    
    
    
    
    <category term="并行计算" scheme="https://flowerhai.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>微信搜索 一面</title>
    <link href="https://flowerhai.github.io/2023/05/18/mianshi/mian-3/"/>
    <id>https://flowerhai.github.io/2023/05/18/mianshi/mian-3/</id>
    <published>2023-05-18T08:27:54.000Z</published>
    <updated>2023-05-18T08:47:16.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信搜索-一面"><a class="markdownIt-Anchor" href="#微信搜索-一面">#</a> 微信搜索 一面</h2><h3 id="new和malloc区别"><a class="markdownIt-Anchor" href="#new和malloc区别">#</a> new 和 malloc 区别</h3><p>new/delete 是 C++ 运算符，可以重载，且不需要知道所需分配的空间，可自动确定</p><p>malloc/free 是 C 函数，且分配空间的时候需知道内存空间大小。</p><h4 id="如果new的内存用free会发生什么问题"><a class="markdownIt-Anchor" href="#如果new的内存用free会发生什么问题">#</a> 如果 new 的内存用 free，会发生什么问题？</h4><p>new () 函数实际过程中做了两步操作，第一步是分配内存空间，第二步是调用类的构造函数；delete () 也同样是两步，第一步是调用类的析构函数，第二步才是释放内存；而 malloc () 和 free () 仅仅是分配内存与释放内存操作；</p><p>那么如果通过 new 分配的内存，再用 free 去释放，就会少一步调用析构函数的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> *i;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A gouzao&quot;</span>&lt;&lt;<span class="built_in">endl</span>;i = new <span class="type">int</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    ~A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A xigou&quot;</span>&lt;&lt;<span class="built_in">endl</span>; delete i;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> c = <span class="number">0</span>)</span>  &#123;*i = c;&#125;</span><br><span class="line">    <span class="type">int</span> *<span class="title function_">get</span><span class="params">()</span> &#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = new A();</span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> *p = a-&gt;get();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    delete(a);</span><br><span class="line">    <span class="comment">//free(a);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 delete 输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A gouzao</span><br><span class="line">2</span><br><span class="line">A xigou</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>用 free 输出结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;cout&lt;&lt;<span class="string">&quot;A gouzao&quot;</span>&lt;&lt;endl;i = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;cout&lt;&lt;<span class="string">&quot;A xigou&quot;</span>&lt;&lt;endl; <span class="keyword">delete</span> i;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> c = <span class="number">0</span>)</span>  </span>&#123;*i = c;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> *p = a-&gt;<span class="built_in">get</span>();</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//delete(a);</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针和裸指针访问速度"><a class="markdownIt-Anchor" href="#智能指针和裸指针访问速度">#</a> 智能指针和裸指针访问速度</h3><p>智能指针和裸指针的访问速度在实际情况下通常是相同的。智能指针是一种高级抽象，它封装了裸指针，并提供了额外的功能，如自动内存管理和所有权转移。这些功能可能会导致轻微的性能开销，但在现代编译器和运行时环境下，这种开销通常是可以忽略不计的。</p><p>智能指针的主要优势在于安全性和便利性，它们可以帮助防止常见的内存错误，如空指针引用、重复释放和内存泄漏。通过使用智能指针，可以更轻松地编写安全、可维护的代码，因为它们提供了自动的资源管理。</p><p>然而，如果对性能要求非常高，或者在某些特殊情况下，使用裸指针可能更合适。裸指针直接访问内存，没有额外的开销，但也没有提供自动的内存管理或安全保证。在这种情况下，程序员需要自己负责确保内存的正确分配和释放，以及避免悬空指针和野指针等错误。</p><p>总的来说，智能指针和裸指针的访问速度在实际情况下通常没有显著的差异。选择使用哪种指针类型应该基于代码的安全性、可维护性和可读性等因素，而不是基于微小的性能差异。</p><h3 id="智能指针内部怎么实现的访问控制"><a class="markdownIt-Anchor" href="#智能指针内部怎么实现的访问控制">#</a> 智能指针内部怎么实现的访问控制</h3><ol><li>所有权管理：智能指针通常使用所有权概念来管理资源的生命周期。它们可以跟踪对象的所有权，并确保只有一个智能指针可以拥有资源。当智能指针超出范围时（例如，离开其作用域），它会自动释放资源。</li><li>引用计数：一种常见的智能指针实现是引用计数指针。它们在内部维护一个计数器，跟踪指向资源的引用数量。每当创建新的智能指针指向资源时，计数器递增；当智能指针被销毁或不再引用资源时，计数器递减。当计数器变为零时，智能指针可以自动释放资源。</li><li>生命周期跟踪：一些智能指针实现使用更复杂的生命周期跟踪机制。它们可以使用有向无环图（DAG）等数据结构来记录对象之间的依赖关系。这种方式可以检测和处理循环引用等情况，以避免内存泄漏。</li></ol><h3 id="linux排查性能"><a class="markdownIt-Anchor" href="#linux排查性能">#</a> linux 排查性能</h3><ol><li>CPU 使用率分析：使用工具如 top、htop 或 sar 来监视 CPU 使用率，识别是否存在 CPU 饱和的情况，以及确定哪些进程或线程消耗了大量的 CPU 资源。</li><li>内存使用分析：通过 free、top 或 vmstat 等工具来检查系统的内存使用情况。关注系统的内存消耗、交换空间使用情况以及内存泄漏等问题。</li><li>磁盘 I/O 分析：使用工具如 iostat、iotop 或 sar 来监测磁盘 I/O 活动。检查磁盘读写速度、I/O 等待时间以及是否存在磁盘瓶颈等问题。</li><li>网络使用分析：使用工具如 iftop、nethogs 或 sar 来监视网络使用情况，检查网络带宽使用率、连接数以及潜在的网络瓶颈。</li><li>进程和线程分析：使用工具如 ps、top 或 htop 来查看系统中运行的进程和线程。了解哪些进程或线程消耗了大量的资源，包括 CPU、内存和 I/O 等。</li><li>资源限制和调整：检查系统中是否存在资源限制，如 ulimit 或 sysctl 参数设置，以及适时调整这些限制以满足应用程序的需求。</li><li>日志分析：查看系统日志文件，如 /var/log/syslog 或应用程序的日志文件，以发现潜在的性能问题或错误信息。</li><li>使用性能分析工具：Linux 提供了一些强大的性能分析工具，如 perf、strace 和 tcpdump 等。这些工具可以用于跟踪系统调用、函数调用、网络流量等，以深入分析和解决性能问题。</li></ol><h3 id="如何处理惊群效应"><a class="markdownIt-Anchor" href="#如何处理惊群效应">#</a> 如何处理惊群效应</h3><ol><li>互斥锁：使用互斥锁来确保只有一个进程或线程可以访问资源。当一个进程或线程获得锁并访问资源时，其他等待的进程或线程将被阻塞，直到锁被释放。这样可以避免多个进程或线程同时竞争资源，减少惊群效应的发生。</li><li>信号量或条件变量：使用信号量或条件变量来实现资源的等待和唤醒机制。等待进程或线程会在资源不可用时等待，而唤醒进程或线程会在资源可用时通知其中一个进程或线程。这样可以避免同时唤醒所有等待的进程或线程，从而减少竞争和资源浪费。</li><li>优雅等待：在等待资源时，进程或线程可以选择进行优雅等待，而不是无限制地快速重试。可以使用一些延迟机制，例如指数退避策略，让进程或线程在等待资源时逐渐增加等待时间，以减少竞争和资源浪费。</li><li>预取或缓存：对于一些可预测的资源需求，可以使用预取或缓存机制来提前获取或缓存资源，以减少对共享资源的频繁竞争。这样可以减少等待资源的进程或线程的数量，从而降低惊群效应的发生。</li><li>负载均衡：在分布式系统中，可以使用负载均衡策略将请求分散到多个服务实例上，以避免单一资源点成为瓶颈。这样可以减少资源争夺和惊群效应的发生。</li></ol><h3 id="线程独占的资源有哪些"><a class="markdownIt-Anchor" href="#线程独占的资源有哪些">#</a> 线程独占的资源有哪些？</h3><ol><li>文件描述符：在某些操作系统中，打开的文件（例如磁盘文件、管道、套接字等）会被分配一个唯一的文件描述符。当一个线程打开文件并持有文件描述符时，其他线程无法直接使用该文件描述符，除非通过特定的机制（如共享文件描述符）进行共享。</li><li>锁和互斥量：线程可能会使用锁（如互斥量）来实现对共享资源的独占访问。当一个线程获取锁时，其他线程需要等待该锁的释放才能访问被保护的资源。</li><li>数据库连接：在多线程应用程序中，数据库连接通常被视为独占资源。当一个线程获得数据库连接时，其他线程需要等待连接的释放才能执行数据库操作。</li><li>共享内存段：共享内存是一种用于多个线程或进程之间共享数据的机制。当一个线程获得对共享内存段的访问权限时，其他线程需要等待访问权限的释放才能读取或写入共享内存。</li><li>设备资源：某些设备资源可能需要独占访问，例如打印机、串口、摄像头等。在多线程环境下，当一个线程使用设备时，其他线程需要等待设备的释放才能进行操作。</li></ol><h3 id="给多个文件每个文件都存储了id值每个文件都很大无法放进内存用户id的空间也很大也放不进内存如果统计出次数最多的top100"><a class="markdownIt-Anchor" href="#给多个文件每个文件都存储了id值每个文件都很大无法放进内存用户id的空间也很大也放不进内存如果统计出次数最多的top100">#</a> 给多个文件，每个文件都存储了 id 值，每个文件都很大，无法放进内存，用户 id 的空间也很大，也放不进内存，如果统计出次数最多的 top100</h3><ol><li>遍历每个文件，逐块读取数据。由于文件很大，无法一次性读取全部数据，因此需要分块读取。</li><li>对于每个文件块，使用合适的排序算法（如归并排序或快速排序）对数据进行排序。由于数据量较大，可能需要使用外部排序算法，将块内排序结果写入临时文件。</li><li>重复步骤 1 和 2，直到遍历完所有文件，并对每个文件块进行排序。</li><li>合并排序结果。在这个阶段，可以使用归并排序的思想，逐个读取已排序的块，合并它们并保持整体有序性。为了找出出现次数最多的 top100，可以使用一个适当的数据结构（如最小堆）来跟踪并更新当前的 top100。</li><li>最终，当合并排序完成后，得到的结果即为出现次数最多的 top100。</li></ol><h3 id="左值引用右值引用移动构造完美转发"><a class="markdownIt-Anchor" href="#左值引用右值引用移动构造完美转发">#</a> 左值引用，右值引用，移动构造，完美转发</h3><p>当谈到左值引用、右值引用、移动构造和完美转发时，这些概念通常与 C++ 语言中的引用和移动语义相关。下面是对这些概念的详细解释：</p><ol><li><p>左值引用（Lvalue Reference）：</p><ul><li><p>左值引用是 C++ 中的一种引用类型，用于引用具有名称和地址的左值对象。左值引用使用 <code>&amp;</code>  符号声明，并且必须绑定到具有相同类型的左值对象。</p></li><li><p>左值引用提供了对对象的别名，并允许对对象进行修改。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeint x = 10;</span><br><span class="line">int&amp; ref = x;  // 左值引用绑定到左值对象 x</span><br></pre></td></tr></table></figure></li></ul></li><li><p>右值引用（Rvalue Reference）：</p><ul><li><p>右值引用是 C++11 引入的新特性，用于引用临时对象、无名称的对象或将要销毁的对象（右值）。</p></li><li><p>右值引用使用 <code>&amp;&amp;</code>  符号声明，并且必须绑定到右值表达式或右值对象。</p></li><li><p>右值引用支持移动语义，可以在移动语义中将资源从一个对象（例如临时对象）转移到另一个对象，而无需进行昂贵的复制操作。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int&amp;&amp; rref = 42;  // 右值引用绑定到右值表达式</span><br></pre></td></tr></table></figure></li></ul></li><li><p>移动构造（Move Constructor）：</p><ul><li><p>移动构造函数是一种特殊的构造函数，用于从一个右值引用对象中 “移动” 资源（例如堆内存、文件句柄等）到另一个对象，而不是进行深层的拷贝。</p></li><li><p>移动构造函数通常采用右值引用作为参数，并通过将资源的所有权转移给新对象来实现高效的移动操作。</p></li><li><p>移动构造函数通常与移动语义一起使用，以避免不必要的复制操作并提高性能。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">  // 移动构造函数</span><br><span class="line">  MyClass(MyClass&amp;&amp; other) &#123;</span><br><span class="line">    // 从 other 移动资源到当前对象</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>完美转发（Perfect Forwarding）：</p><ul><li><p>完美转发是一种通过保留函数参数的值类别（左值或右值）来转发函数调用的机制。</p></li><li><p>完美转发通常使用模板和引用折叠规则来实现，以确保函数调用中的参数类型和值类别与原始调用保持一致。</p></li><li><p>完美转发可以用于实现通用的转发函数，将参数传递给其他函数，同时保持原始调用的值类别。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codetemplate &lt;typename T&gt;</span><br><span class="line">void forwardFunction(T&amp;&amp; arg) &#123;</span><br><span class="line">  otherFunction(std::forward&lt;T&gt;(arg));  // 完美转发 arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>以上是对左值引用、右值引用、移动构造和完美转发的详细解释。这些概念在 C++ 中提供了更灵活和高效的资源管理和函数调用机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*a)[10] int (*a[10])(int) int(*a)(int)分别是什么</span><br></pre></td></tr></table></figure><ul><li><code>int (*a)[10]</code> : 这是一个指针  <code>a</code> ，指向一个包含 10 个整数的数组。它的声明中使用了括号来明确指针的优先级，表示  <code>a</code>  是一个指针，它指向一个包含 10 个整数的数组。</li><li><code>int (*a[10])(int)</code> : 这是一个包含 10 个元素的数组  <code>a</code> ，每个元素都是一个函数指针，指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。它的声明中使用了括号来明确指针的优先级和数组的大小。</li><li><code>int (*a)(int)</code> : 这是一个指针  <code>a</code> ，指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。它的声明中没有使用括号，所以  <code>a</code>  是一个指针，指向一个函数。</li></ul><p>这些声明可以有点复杂，但我们可以通过拆解它们来理解其含义。注意到，声明中的  <code>(*a)</code>  表示  <code>a</code>  是一个指针。接着，我们可以根据  <code>*a</code>  的部分进一步理解其指向的类型。在第一个例子中， <code>*a</code>  是一个指向包含 10 个整数的数组的指针。在第二个例子中， <code>*a</code>  是一个指向以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数的指针。而在第三个例子中， <code>*a</code>  是一个指向以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数的指针。</p><p>综上所述，可以总结如下：</p><ul><li><code>int (*a)[10]</code> ： <code>a</code>  是一个指针，指向一个包含 10 个整数的数组。</li><li><code>int (*a[10])(int)</code> ： <code>a</code>  是一个包含 10 个元素的函数指针数组，每个元素都指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。</li><li><code>int (*a)(int)</code> ： <code>a</code>  是一个指针，指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微信搜索-一面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信搜索-一面&quot;&gt;#&lt;/a&gt; 微信搜索 一面&lt;/h2&gt;
&lt;h3 id=&quot;new和malloc区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#n</summary>
      
    
    
    
    
    <category term="面试总结" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>快手一面补充</title>
    <link href="https://flowerhai.github.io/2023/05/18/mianshi/mian-2/"/>
    <id>https://flowerhai.github.io/2023/05/18/mianshi/mian-2/</id>
    <published>2023-05-18T07:51:55.000Z</published>
    <updated>2023-05-18T07:52:44.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快手一面补充"><a class="markdownIt-Anchor" href="#快手一面补充">#</a> 快手一面补充</h2><h3 id="内存对齐"><a class="markdownIt-Anchor" href="#内存对齐">#</a> 内存对齐</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">char</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>int 占 4 个字节，char 占 1 个字节，按理说应该是 5 字节，实际是 8 字节，这就是发生了内存对齐。</p><h5 id="为什么要内存对齐"><a class="markdownIt-Anchor" href="#为什么要内存对齐">#</a> 为什么要内存对齐</h5><ol><li><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，四字节，8 字节，16 字节甚至 32 字节为单位来存取内存，我们将上述 这些存取单位称为内存存取粒度.</p><p>现在考虑 4 字节存取粒度的处理器取 int 类型变量（32 位系统），该处理器只能从地址为 4 的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个 int 变量存放在从地址 1 开始的联系四个字节地址中，该处理器去取数据时，要先从 0 地址开始读取第一个 4 字节块，剔除不想要的字节（0 地址）, 然后从地址 4 开始读取下一个 4 字节块，同样剔除不要的数据（5，6，7 地址）, 最后留下的两块数据合并放入寄存器。这需要做很多工作.</p><p><img src="https://pic3.zhimg.com/80/v2-3f40af513a94901b36ceb5387982277e_720w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-3f40af513a94901b36ceb5387982277e_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>现在有了内存对齐的，int 类型数据只能存放在按照对齐规则的内存中，比如说 0 地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p><p><img src="https://pic1.zhimg.com/80/v2-361e2d16876ce8383c9e6ea2dca34474_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-361e2d16876ce8383c9e6ea2dca34474_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p></li></ol><h4 id="内存对齐规则"><a class="markdownIt-Anchor" href="#内存对齐规则">#</a> 内存对齐规则</h4><p>每个特定平台上的编译器都有自己的默认 “对齐系数”（也叫对齐模数）。gcc 中默认 #pragma pack (4)，可以通过预编译命令 #pragma pack (n)，n = 1,2,4,8,16 来改变这一系数。</p><p>有效对其值：是给定值 #pragma pack (n) 和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><p>(1) 结构体第一个成员的<strong>偏移量（offset）<strong>为 0，以后每个成员相对于结构体首地址的 offset 都是</strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(3) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p>下面给出几个例子以便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2; </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">&#125;x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上测试都是在 Linux 环境下进行的，linux 下默认 #pragma pack (4)，且结构体中最长的数据类型为 4 个字节，所以有效对齐单位为 4 字节，下面根据上面所说的规则以 s2 来分析其内存布局：</p><p>首先使用规则 1，对成员变量进行对齐：</p><p>sizeof (c1) = 1 &lt;= 4 (有效对齐位)，按照 1 字节对齐，占用第 0 单元；</p><p>sizeof (i) = 4 &lt;= 4 (有效对齐位)，相对于结构体首地址的偏移要为 4 的倍数，占用第 4，5，6，7 单元；</p><p>sizeof (c2) = 1 &lt;= 4 (有效对齐位)，相对于结构体首地址的偏移要为 1 的倍数，占用第 8 单元；</p><p>然后使用规则 2，对结构体整体进行对齐：</p><p>s2 中变量 i 占用内存最大占 4 字节，而有效对齐单位也为 4 字节，两者较小值就是 4 字节。因此整体也是按照 4 字节对齐。由规则 1 得到 s2 占 9 个字节，此处再按照规则 2 进行整体的 4 字节对齐，所以整个结构体占用 12 个字节。</p><p>根据上面的分析，不难得出上面例子三个结构体的内存布局如下：</p><p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="pragma-packn"><a class="markdownIt-Anchor" href="#pragma-packn">#</a> *<strong>#pragma pack(n)*</strong></h4><p>不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令 #pragma pack (n), n= 1,2,4,8,16 来改变对齐系数。</p><p>例如，对于上个例子的三个结构体，如果前面加上 #pragma pack (1)，那么此时有效对齐值为 1 字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是 6 字节。</p><p><img src="https://pic2.zhimg.com/80/v2-672ebe0ccc1430adbda00dfd7abc0375_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-672ebe0ccc1430adbda00dfd7abc0375_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>如果前面加上 #pragma pack (2)，有效对齐值为 2 字节，此时根据对齐规则，三个结构体的大小应为 6,8,6。内存分布图如下：</p><p><img src="https://pic4.zhimg.com/80/v2-1c35bc20c76d85d07855901964488637_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-1c35bc20c76d85d07855901964488637_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>对内存对齐有了全面的认识和了解，在以后的编码中定义结构体时需要考虑成员变量定义的先后顺序了。</p><h3 id="编译的几个阶段和作用"><a class="markdownIt-Anchor" href="#编译的几个阶段和作用">#</a> 编译的几个阶段和作用</h3><p>GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程分为四个阶段：<strong>预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）、链接（Linking）</strong>。执行这四个阶段的程序（<strong>预处理器、编译器、汇编器、和链接器</strong>）一起构成了编译系统。</p><p><img src="https://pic3.zhimg.com/v2-b9e8babf753b1691039458592667121a_r.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/v2-b9e8babf753b1691039458592667121a_r.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="预处理阶段"><a class="markdownIt-Anchor" href="#预处理阶段">#</a> <strong>预处理阶段：</strong></h4><ol><li>预处理器（cpp）将所有的 #define 删除，并且展开所有的宏定义。</li><li>处理所有的条件预编译指令，比如 #if、#ifdef、#elif、#else、#endif 等。</li><li>处理 #include 预编译指令，将被包含的文件直接插入到预编译指令的位置。</li><li>删除所有的注释。</li><li>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。</li><li>保留所有的 #pragma 编译器指令，因为编译器需要使用它们。</li><li>使用 <code>gcc -E hello.c -o hello.i</code>  命令来进行预处理， 预处理得到的另一个程序通常是以.i 作为文件扩展名。</li></ol><h4 id="编译阶段"><a class="markdownIt-Anchor" href="#编译阶段">#</a> <strong>编译阶段：</strong></h4><p>编译器（ccl）将预处理完的文本文件 hello.i 进行一系列的词法分析、语法分析、语义分析和优化，翻译成文本文件 hello.s，它包含一个汇编语言程序。如下所示</p><p><img src="https://pic4.zhimg.com/80/v2-a962deac411dedc572d02affa2d24f0f_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-a962deac411dedc572d02affa2d24f0f_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>该程序包含函数 main 的定义，2-7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。</p><p>汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。</p><p>编译过程可分为 6 步：<strong>扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化</strong>。</p><ol><li>词法分析：扫描器（Scanner）将源代的字符序列分割成一系列的记号（Token）。lex 工具可实现词法扫描。</li><li>语法分析：语法分析器将记号（Token）产生语法树（Syntax Tree）。yacc 工具可实现语法分析 (yacc: Yet Another Compiler Compiler)。</li><li>语义分析：静态语义（在编译器可以确定的语义）、动态语义（只能在运行期才能确定的语义）。</li><li>源代码优化：源代码优化器 (Source Code Optimizer)，将整个语法书转化为中间代码（Intermediate Code）（中间代码是与目标机器和运行环境无关的）。中间代码使得编译器被分为前端和后端。编译器前端负责产生机器无关的中间代码；编译器后端将中间代码转化为目标机器代码。</li><li>目标代码生成：代码生成器 (Code Generator).</li><li>目标代码优化：目标代码优化器 (Target Code Optimizer)。</li></ol><h4 id="汇编阶段"><a class="markdownIt-Anchor" href="#汇编阶段">#</a> <strong>汇编阶段：</strong></h4><p>汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>的格式，并将结果保存在目标文件 hello.o 中，hello.o 是一个二进制文件。</p><h4 id="链接阶段"><a class="markdownIt-Anchor" href="#链接阶段">#</a> <strong>链接阶段：</strong></h4><p>hello 程序调用了 printf 函数，它存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。连接器（ld）就负责处理这种合并。结果就得到了 hello 文件，它是一个<strong>可执行目标文件</strong>（或者称为<strong>可执行文件</strong>），可以被加载到内存中，由系统执行。（链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件）。</p><h4 id="链接"><a class="markdownIt-Anchor" href="#链接">#</a> <strong>链接</strong></h4><h4 id="简述"><a class="markdownIt-Anchor" href="#简述">#</a> <strong>简述：</strong></h4><p>链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于<strong>编译时（compile time）</strong>，也就是在源代码被翻译成机器代码时；也可以执行于<strong>加载时（load time）</strong>，也就是在程序被<strong>加载器（loader）<strong>加载到内存并执行时；甚至执行于</strong>运行时（run time）</strong>，也就是由应用程序来执行。链接是由叫 ** 链接器（linker）** 的程序自动执行的。</p><h4 id="意义"><a class="markdownIt-Anchor" href="#意义">#</a> <strong>意义：</strong></h4><p>链接使得 ** 分离编译（separate compilation）** 成为可能，我们不用将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解成为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其他文件。</p><h3 id="select和epoll的区别以及优缺点"><a class="markdownIt-Anchor" href="#select和epoll的区别以及优缺点">#</a> select 和 epoll 的区别以及优缺点</h3><p>select 单个进程可监视的 fd 数量受到限制，epoll 和 select 都可实现同时监听多个 I/O 事件的状态。</p><ul><li>select 基于轮询机制</li><li>epoll 基于 os 支持的 I/O 通知机制。epoll 支持水平触发和边沿触发两种模式。</li></ul><h3 id="epoll的底层实现"><a class="markdownIt-Anchor" href="#epoll的底层实现">#</a> epoll 的底层实现</h3><p><a href="https://blog.csdn.net/hjlogzw/article/details/122953715">https://blog.csdn.net/hjlogzw/article/details/122953715</a></p><p>有空了读下源码吧，底层是用了 mmap ，这倒是没问题。</p><h3 id="静态链接和动态链接"><a class="markdownIt-Anchor" href="#静态链接和动态链接">#</a> 静态链接和动态链接</h3><p>静态链接和动态链接两者最大的区别就在于链接的时机不一样，静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时，下面来详细介绍这两种链接方式。</p><p>一、静态链接<br> 1. 为什么要进行静态链接<br>在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个 *.c 文件会形成一个 *.o 文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接</p><p>2. 静态链接的原理<br>由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。</p><p>​    以下面这个图来简单说明一下从静态链接到可执行文件的过程，根据在源文件中包含的头文件和程序中使用到的库函数，如 stdio.h 中定义的 printf () 函数，在 libc.a 中找到目标文件 printf.o (这里暂且不考虑 printf () 函数的依赖关系)，然后将这个目标文件和我们 hello.o 这个文件进行链接形成我们的可执行文件。</p><p><img src="https://img-blog.csdn.net/20180505235327609" class="lazyload placeholder" data-srcset="https://img-blog.csdn.net/20180505235327609" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>​    这里有一个小问题，就是从上面的图中可以看到静态运行库里面的一个目标文件只包含一个函数，如 libc.a 里面的 printf.o 只有 printf () 函数，strlen.o 里面只有 strlen () 函数。</p><p>​    我们知道，链接器在链接静态链接库的时候是以目标文件为单位的。比如我们引用了静态库中的 printf () 函数，那么链接器就会把库中包含 printf () 函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。<br>3. 静态链接的优缺点<br>​    静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了 printf () 函数，则这多个程序中都含有 printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p><p>二、动态链接<br> 1. 为什么会出现动态链接<br>动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。</p><p>2. 动态链接的原理<br>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：</p><p>​    假设现在有两个程序 program1.o 和 program2.o，这两者共用同一个库 lib.o, 假设首先运行程序 program1，系统首先加载 program1.o，当系统发现 program1.o 中用到了 lib.o，即 program1.o 依赖于 lib.o，那么系统接着加载 lib.o，如果 program1.o 和 lib.o 还依赖于其他目标文件，则依次全部加载到内存中。当 program2 运行时，同样的加载 program2.o，然后发现 program2.o 依赖于 lib.o，但是此时 lib.o 已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的 lib.o 映射到 program2 的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。</p><p>3. 动态链接的优缺点<br>动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p><p>​    据估算，动态链接和静态链接相比，性能损失大约在 5% 以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。</p><p>4. 动态链接地址是如何重定位的呢？<br>前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。</p><p>参考链接：</p><p><a href="http://www.cnblogs.com/cyyljw/p">www.cnblogs.com/cyyljw/p</a></p><p><a href="https://zhuanlan.zhihu.com/p/105936114">https://zhuanlan.zhihu.com/p/105936114</a></p><p><a href="https://zhuanlan.zhihu.com/p/30007037">https://zhuanlan.zhihu.com/p/30007037</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快手一面补充&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#快手一面补充&quot;&gt;#&lt;/a&gt; 快手一面补充&lt;/h2&gt;
&lt;h3 id=&quot;内存对齐&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存对齐&quot;&gt;#&lt;/a&gt; </summary>
      
    
    
    
    
    <category term="面试总结" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>快手一面</title>
    <link href="https://flowerhai.github.io/2023/05/17/mianshi/mian-1/"/>
    <id>https://flowerhai.github.io/2023/05/17/mianshi/mian-1/</id>
    <published>2023-05-17T14:27:27.000Z</published>
    <updated>2023-05-17T14:28:04.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经总结-1"><a class="markdownIt-Anchor" href="#面经总结-1">#</a> 面经总结 - 1</h1><h3 id="快手一面"><a class="markdownIt-Anchor" href="#快手一面">#</a> 快手一面</h3><h4 id="虚函数和多态的实现原理"><a class="markdownIt-Anchor" href="#虚函数和多态的实现原理">#</a> 虚函数和多态的实现原理</h4><p>多态主要就是靠重载和重写来实现的。</p><p>重写，主要依赖与编译器，静态多态。</p><p>因为编译器在底层会把参数也加到函数名后面。</p><p>重载，主要是靠虚表来实现。</p><p>写一个简单的程序，用 gdb 调试验证以下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;int&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(<span class="type">float</span> a)</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;float&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B-&gt;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;C-&gt;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;C-&gt;B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A aa;</span><br><span class="line">    aa.<span class="built_in">play</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">3.1</span>;</span><br><span class="line">    aa.<span class="built_in">play</span>(c);</span><br><span class="line">    aa.<span class="built_in">hhh</span>();</span><br><span class="line">    B bb;</span><br><span class="line">    bb.<span class="built_in">hhh</span>();</span><br><span class="line">    bb.<span class="built_in">hh</span>();</span><br><span class="line">    C cc;</span><br><span class="line">    cc.<span class="built_in">hhh</span>();</span><br><span class="line">    cc.<span class="built_in">hh</span>();</span><br><span class="line">    cc.<span class="built_in">h</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p aa</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;_vptr.A = 0x555555557d20 &lt;vtable <span class="keyword">for</span> A+16&gt;&#125;</span></span><br><span class="line">(gdb) p bb</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = &#123;&lt;A&gt; = &#123;_vptr.A = 0x555555557d00 &lt;vtable <span class="keyword">for</span> B+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br><span class="line">(gdb) p cc</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = &#123;&lt;A&gt; = &#123;_vptr.A = 0x555555557cd8 &lt;vtable <span class="keyword">for</span> C+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br><span class="line">(gdb) info line 5</span><br><span class="line">Line 5 of &quot;hh.cpp&quot; starts at address 0x555555555308 &lt;_ZN1A4playEi&gt; and ends at 0x55555555531b &lt;_ZN1A4playEi+19&gt;.</span><br><span class="line">(gdb) i line 6</span><br><span class="line">Line 6 of &quot;hh.cpp&quot; starts at address 0x55555555534a &lt;_ZN1A4playEf&gt; and ends at 0x55555555535f &lt;_ZN1A4playEf+21&gt;.</span><br><span class="line">(gdb) i line 8</span><br><span class="line">Line 8 of &quot;hh.cpp&quot; starts at address 0x55555555538e &lt;_ZN1A3hhhEv&gt; and ends at 0x55555555539e &lt;_ZN1A3hhhEv+16&gt;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看这里</p><p>关于重载我们可以看到一个是 playEi 一个是 playEf， 名字不一样，实现重写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info line 5</span><br><span class="line">Line 5 of &quot;hh.cpp&quot; starts at address 0x555555555308 &lt;_ZN1A4playEi&gt; and ends at 0x55555555531b &lt;_ZN1A4playEi+19&gt;.</span><br><span class="line">(gdb) i line 6</span><br><span class="line">Line 6 of &quot;hh.cpp&quot; starts at address 0x55555555534a &lt;_ZN1A4playEf&gt; and ends at 0x55555555535f &lt;_ZN1A4playEf+21&gt;.</span><br></pre></td></tr></table></figure><p>关于虚函数重载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p cc</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">11 = &#123;&lt;A&gt; = &#123;_vptr.A = 0x555555557cd8 &lt;vtable <span class="keyword">for</span> C+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br><span class="line">(gdb)  p /a *(void**)0x555555557cd8@2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">12 = &#123;0x555555555448 &lt;_ZN1C3hhhEv&gt;, 0x555555555486 &lt;_ZN1C2hhEv&gt;&#125;</span></span><br><span class="line">(gdb)  p /a *(void**)0x555555557cd8@1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">13 = &#123;0x555555555448 &lt;_ZN1C3hhhEv&gt;&#125;</span></span><br><span class="line">(gdb)  p /a *(void**)0x555555557cd8@3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">14 = &#123;0x555555555448 &lt;_ZN1C3hhhEv&gt;, 0x555555555486 &lt;_ZN1C2hhEv&gt;, 0x5555555554c4 &lt;_ZN1C1hEv&gt;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="智能指针的类型和用法"><a class="markdownIt-Anchor" href="#智能指针的类型和用法">#</a> 智能指针的类型和用法</h4><p>unique_ptr 独占，禁止右值引用和拷贝复制构造</p><p>解决该问题可以用移动语义 move</p><p>shared_ptr 带计数</p><p>weak_ptr 解决 shared_ptr 循环引用问题</p><p>何为循环引用？</p><p>两个对象互相使用一个 shared_ptr 成员变量指向对方。这样会引发一个问题，其中任何一个对象的引用计数都为 2。析构时两个资源引⽤计数会减⼀，于是两者引⽤计数还是大于 0，导致跳出函数时资源没有被释放（离开作用域时两个对象的析构函数没有被调⽤）</p><p>weak_ptr 是如何解决这个问题的？</p><p>因为 weak_ptr 指向对方，并不会增加循环引用，所以会解决这个问题。</p><h4 id="内存对齐"><a class="markdownIt-Anchor" href="#内存对齐">#</a> 内存对齐</h4><p>不熟悉，后面补一下</p><h4 id="编译的几个阶段和作用"><a class="markdownIt-Anchor" href="#编译的几个阶段和作用">#</a> 编译的几个阶段和作用</h4><p>预编译</p><p>编译</p><p>汇编</p><p>连接</p><h4 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数">#</a> 内联函数</h4><p>内联函数不会给函数开辟新的栈帧，省去了开辟栈帧回收栈帧的空间，在需要重复调用短小函数的时候能够缩短运行时间。</p><h4 id="socket编程基本流程"><a class="markdownIt-Anchor" href="#socket编程基本流程">#</a> socket 编程基本流程</h4><p>这个需要分为服务端和客户段</p><p>TCP 下如下，UDP 类似</p><p>服务端：</p><ul><li>加载套接字库</li><li>创建套接字（socket）</li><li>将套接字绑定到一个本地地址和端口上（bind）</li><li>将套接字设为监听模式，准备接收客户请求（listen）</li><li>等待客户请求到来；当请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept）</li><li>用返回的套接字和客户端进行通信（send/recv）</li><li>返回，等待另一客户请求。</li><li>关闭套接字。</li></ul><p>客户段：</p><ul><li>加载套接字库</li><li>创建套接字（socket）</li><li>向服务器发出连接请求（connect）</li><li>和服务器端进行通信（send/recv）</li><li>关闭套接字。</li></ul><h4 id="tcp和udp的区别"><a class="markdownIt-Anchor" href="#tcp和udp的区别">#</a> tcp 和 udp 的区别</h4><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个<a href="https://www.zhihu.com/search?q=%E7%AB%AF%E7%82%B9&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">端点</a>。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和<a href="https://www.zhihu.com/search?q=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">流量控制机制</a>，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是  <code>20</code>  个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是<a href="https://www.zhihu.com/search?q=%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">流式传输</a>，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP <a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%8C%85&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">数据包</a>，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><h4 id="tcp流量控制和拥塞控制的实现"><a class="markdownIt-Anchor" href="#tcp流量控制和拥塞控制的实现">#</a> tcp 流量控制和拥塞控制的实现</h4><p>滑动窗口 慢启动 拥塞避免 快重传 快恢复</p><h4 id="select和epoll的区别以及优缺点"><a class="markdownIt-Anchor" href="#select和epoll的区别以及优缺点">#</a> select 和 epoll 的区别以及优缺点</h4><p>select 每次只能注册一个时间</p><p>epoll 每次可以拿一个事件组，更加高校</p><h2 id="epoll的具体底层实现"><a class="markdownIt-Anchor" href="#epoll的具体底层实现">#</a> epoll 的具体底层实现</h2><p><a href="https://blog.csdn.net/hjlogzw/article/details/122953715">https://blog.csdn.net/hjlogzw/article/details/122953715</a></p><h4 id="delete操作后指针指向内存区的数据会被清掉吗"><a class="markdownIt-Anchor" href="#delete操作后指针指向内存区的数据会被清掉吗">#</a> delete 操作后指针指向内存区的数据会被清掉吗？</h4><p>不会立刻清除，会等待一段时间</p><h4 id="4种隔离级别以及含义"><a class="markdownIt-Anchor" href="#4种隔离级别以及含义">#</a> 4 种隔离级别以及含义？</h4><p><a href="https://zhuanlan.zhihu.com/p/76743929">https://zhuanlan.zhihu.com/p/76743929</a></p><h4 id="静态链接和动态链接"><a class="markdownIt-Anchor" href="#静态链接和动态链接">#</a> 静态链接和动态链接</h4><p><a href="https://zhuanlan.zhihu.com/p/105936114">https://zhuanlan.zhihu.com/p/105936114</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面经总结-1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面经总结-1&quot;&gt;#&lt;/a&gt; 面经总结 - 1&lt;/h1&gt;
&lt;h3 id=&quot;快手一面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#快手一面&quot;&gt;#&lt;/a</summary>
      
    
    
    
    
    <category term="面试总结" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>图床项目整体构思</title>
    <link href="https://flowerhai.github.io/2023/05/17/picturebed/all/"/>
    <id>https://flowerhai.github.io/2023/05/17/picturebed/all/</id>
    <published>2023-05-17T02:58:40.000Z</published>
    <updated>2023-05-17T02:59:33.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图床项目"><a class="markdownIt-Anchor" href="#图床项目">#</a> 图床项目</h2><p>准备自己搭一个图床，平时自己的网站老拿别人的图床用，算什么程序猿！</p><p>正好也算是自己秋招的一个项目吧。</p><h4 id="构思"><a class="markdownIt-Anchor" href="#构思">#</a> 构思</h4><p>技术点：</p><p>socket 网络编程</p><p>HTTP 解析</p><p>线程池</p><p>epoll</p><p>图片显示用随机数就可以解决 (当然图片命名得用一定范围内的整数)</p><h4 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路">#</a> 大致思路</h4><p>ECS 上运行运行一个服务端程序，监听 443 端口 (随便写的一个)，一旦监听到有 https 连接，用状态机解析报文，随后生成一个随机数拼接成图片路径返回一个 https 连接。</p><p>考虑岛图床肯定是一个多线程项目，为了提高项目的稳定性以及并发性，可以使用 epoll+thread_pool，再加一个定时器，在返回资源后的 3s 后断开连接，为了能够更加方便的维护项目，可以再使用单例模式设计一个日志系统。</p><p>完美！就先这样，慢慢来，想到什么了再继续完善。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图床项目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图床项目&quot;&gt;#&lt;/a&gt; 图床项目&lt;/h2&gt;
&lt;p&gt;准备自己搭一个图床，平时自己的网站老拿别人的图床用，算什么程序猿！&lt;/p&gt;
&lt;p&gt;正好也算是自己秋招的一个项目吧。&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    
    <category term="图床" scheme="https://flowerhai.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab:system calls</title>
    <link href="https://flowerhai.github.io/2023/05/17/s081/lab2/"/>
    <id>https://flowerhai.github.io/2023/05/17/s081/lab2/</id>
    <published>2023-05-17T02:57:06.000Z</published>
    <updated>2023-05-17T02:58:05.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-system-calls"><a class="markdownIt-Anchor" href="#lab-system-calls">#</a> Lab: system calls</h1><p>这个实验还蛮搞的 hh，关于最后的输出时候的 syscalls [p-&gt;trapframe-&gt;a7] 和示例并不一样，但是能完整通过测试，猜测是因为我的操作系统位数和要求不一样，因此寄存器的值达不到。</p><h3 id="tracing"><a class="markdownIt-Anchor" href="#tracing">#</a> tracing</h3><p>关于系统调用的流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user/user.h:用户态程序调用跳板函数 trace()</span><br><span class="line">user/usys.S:跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态</span><br><span class="line">kernel/syscall.c到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。</span><br><span class="line">kernel/syscall.csyscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。</span><br><span class="line">kernel/sysproc.c到达 sys_trace() 函数，执行具体内核操作</span><br></pre></td></tr></table></figure><p>usys.S 中部分命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sysinfo</span><br><span class="line">sysinfo:</span><br><span class="line"> li a7, SYS_sysinfo</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>仅拿 tarce 来说，首先 global 声明全局可见，然后将 SYS_trace 加载到 a7 中，ecall 会将系统调用值转移到 a0</p><p>这么繁琐的调用流程的主要目的是实现用户态和内核态的良好隔离。</p><p>并且由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。</p><p>同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。（在本 lab 第二个实验会用到）</p><p>关于如何注册一个系统调用在此不做过多说明，只说关键函数的设计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line">  myproc()-&gt;syscall_trace = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>查看</mtext><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>t</mi><mtext>以及</mtext><mi>a</mi><mi>r</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>w</mi><mtext>我们可以知道</mtext><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>t</mi><mtext>函数的作用就是返回</mtext><msub><mi>a</mi><mi>n</mi></msub><mtext>寄存器对应的值</mtext></mrow><annotation encoding="application/x-tex">查看argint以及argraw我们可以知道argint函数的作用就是返回a_{n}寄存器对应的值</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">看</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">及</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">道</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">返</span><span class="mord cjk_fallback">回</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span></span></span></span></span></p><p>sys_trace 的作用便是获取 a0 寄存器的值，因此便如上述所写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在 proc.c 中，在注册一个 proc 的时候，将其 mask 置 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line">  p-&gt;syscall_trace = <span class="number">0</span>; <span class="comment">//add here</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork 在 fork 的时候也需要保持父子进程 mask 相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *np;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = <span class="built_in">allocproc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">uvmcopy</span>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(np);</span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = <span class="built_in">filedup</span>(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = <span class="built_in">idup</span>(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(np-&gt;name, p-&gt;name, <span class="built_in">sizeof</span>(p-&gt;name));</span><br><span class="line">  np-&gt;syscall_trace = p-&gt;syscall_trace; <span class="comment">//add here</span></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;wait_lock);</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  <span class="built_in">release</span>(&amp;wait_lock);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;np-&gt;lock);</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后便是 syscall，仅需在原有基础上稍微添加以下即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;syscall_trace &amp; (<span class="number">1</span> &lt;&lt; num)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0); <span class="comment">// syscall_names[num]: 从 syscall 编号到 syscall 名的映射表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sysinfo"><a class="markdownIt-Anchor" href="#sysinfo">#</a> Sysinfo</h3><p>注册流程和上述基本一致</p><p>sys_info 设计</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;addr);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sinfo</span>;</span></span><br><span class="line">  sinfo.freemem = freemem_size();</span><br><span class="line">  sinfo.nproc = count_proc();</span><br><span class="line">  <span class="keyword">if</span> (copyout(myproc()-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;sinfo, <span class="keyword">sizeof</span>(sinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>freemem_size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">freemem_size</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;kmem.lock); <span class="comment">// prevent race condition</span></span><br><span class="line"></span><br><span class="line">  uint64 size = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    size++;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> size * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>count_proc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">count_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc[i].state != UNUSED) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="result"><a class="markdownIt-Anchor" href="#result">#</a> result</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./grade-lab-syscall</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">== Test trace 32 grep == trace 32 grep: OK (3.0s) </span><br><span class="line">== Test trace all grep == trace all grep: OK (2.2s) </span><br><span class="line">== Test trace nothing == trace nothing: OK (2.2s) </span><br><span class="line">== Test trace children == trace children: OK (95.3s) </span><br><span class="line">== Test sysinfotest == sysinfotest: OK (9.2s) </span><br></pre></td></tr></table></figure><p>完美解决，下一个！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-system-calls&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-system-calls&quot;&gt;#&lt;/a&gt; Lab: system calls&lt;/h1&gt;
&lt;p&gt;这个实验还蛮搞的 hh，关于最后的输出时候的 sysca</summary>
      
    
    
    
    
    <category term="MIT6.S081" scheme="https://flowerhai.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>day25</title>
    <link href="https://flowerhai.github.io/2023/05/15/shuati/day25/"/>
    <id>https://flowerhai.github.io/2023/05/15/shuati/day25/</id>
    <published>2023-05-15T10:56:44.000Z</published>
    <updated>2023-05-15T10:57:40.142Z</updated>
    
    <content type="html"><![CDATA[<p>让网站更适合秋招好看一点吧，刷题记录本地有就行了。<br>不再上传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;让网站更适合秋招好看一点吧，刷题记录本地有就行了。&lt;br&gt;
不再上传。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab:Xv6 and Unix utilities</title>
    <link href="https://flowerhai.github.io/2023/05/15/s081/lab1/"/>
    <id>https://flowerhai.github.io/2023/05/15/s081/lab1/</id>
    <published>2023-05-15T10:50:27.000Z</published>
    <updated>2023-05-15T10:51:22.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-xv6-and-unix-utilities"><a class="markdownIt-Anchor" href="#lab-xv6-and-unix-utilities">#</a> Lab: Xv6 and Unix utilities</h1><h4 id="sleep"><a class="markdownIt-Anchor" href="#sleep">#</a> sleep</h4><p>函数的设计还是很简单的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: number should be given...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  sleep(n);</span><br><span class="line">  <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来刚开始写的是 return 0; 通过样例是没问题的，但是编译 OS 的时候再调用无法正常退出。</p><h3 id="查阅资料发现return和exit的区别还是蛮大的"><a class="markdownIt-Anchor" href="#查阅资料发现return和exit的区别还是蛮大的">#</a> 查阅资料发现，return 和 exit 的区别还是蛮大的。</h3><ol><li>exit 用于结束正在运行的整个程序，它将参数返回给 OS，把控制权交给操作系统；而 return 是退出当前函数，返回函数值，把控制权交给调用函数。</li><li>exit 是系统调用级别，它表示一个进程的结束；而 return 是语言级别的，它表示调用堆栈的返回。</li><li>在 main 函数结束时，会隐式地调用 exit 函数，所以一般程序执行到 main () 结尾时，则结束主进程。exit 将删除进程使用的内存空间，同时把错误信息返回给父进程。</li><li>void exit (int status); 一般 status 为 0，表示正常退出，非 0 表示非正常退出。</li></ol><h4 id="1-exit函数和return函数的主要区别是"><a class="markdownIt-Anchor" href="#1-exit函数和return函数的主要区别是">#</a> 1、exit 函数和 return 函数的主要区别是：</h4><p>1）exit 用于在程序运行的过程中随时结束程序，其参数是返回给 OS 的。也可以这么讲：exit 函数是退出应用程序，并将应用程序的一个状态返回给 OS，这个状态标识了应用程序的一些运行信息。</p><p>main 函数结束时也会隐式地调用 exit 函数，exit 函数运行时首先会执行由 atexit () 函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准 I/O 函数 tmpfile () 创建的临时文件。</p><p>exit 是系统调用级别的，它表示了一个进程的结束，它将删除进程使用的内存空间，同时把错误信息返回父进程。通常情况：exit (0) 表示程序正常，exit (1) 和 exit (-1) 表示程序异常退出，exit (2) 表示系统找不到指定的文件。在整个程序中，只要调用 exit 就结束。</p><p>2）return 是语言级别的，它表示了调用堆栈的返回；return 是返回函数值并退出函数，通常 0 为正常退出，非 0 为非正常退出，请注意，如果是在主函数 main, 自然也就结束当前进程了（也就是说，在 main () 里面，你可以用 return n，也能够直接用 exit (n) 来做），如果不是在 main 函数中，那就是退回上一层调用。在多个进程时，如果有时要检测上个进程是否正常退出，就要用到上个进程的返回值。</p><h4 id="2-进程环境与进程控制"><a class="markdownIt-Anchor" href="#2-进程环境与进程控制">#</a> 2、进程环境与进程控制</h4><p>exit (int n) 其实就是直接退出程序，因为默认的标准程序入口为 int main (int argc, char** argv)，返回值是 int 型的。一般在 shell 下面，运行一个程序，然后使用命令 echo $? 就能得到该程序的返回值，也就是退出值。</p><p>理论上 exit 可以返回小于 256 的任何整数，返回的不同数值主要是给调用者作不同处理的。</p><p>对于单独的进程 exit 的返回值是返回给操作系统的，但如果是多进程，则是返回给父进程的。父进程里面调用 waitpid () 等函数得到子进程退出的状态，以便作不同处理。根据相应的返回值来让调用者作出相应的处理。</p><p>总的说来，exit（）就是当前进程把其控制权返回给调用该子程序的主程序，括号里的是返回值，告诉调用程序该程序的运行状态。</p><h4 id="pingpong"><a class="markdownIt-Anchor" href="#pingpong">#</a> pingpong</h4><p>也还行，要注意管道 0 读 1 写，并且用不着哪边端口需要将其 close，用完的端口也要 close</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: create pipe number should be given one...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> p2[<span class="number">2</span>];</span><br><span class="line">  pipe(p1);</span><br><span class="line">  pipe(p2);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    close(p1[<span class="number">1</span>]);<span class="comment">//close p1 write</span></span><br><span class="line">    close(p2[<span class="number">0</span>]);<span class="comment">//close p2 read</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">10</span>];</span><br><span class="line">    read(p1[<span class="number">0</span>],buff, <span class="number">4</span>);</span><br><span class="line">    close(p1[<span class="number">0</span>]);</span><br><span class="line">    write(p2[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;pong&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buff);</span><br><span class="line">    close(p2[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    close(p1[<span class="number">0</span>]);<span class="comment">//close p1 write</span></span><br><span class="line">    close(p2[<span class="number">1</span>]);<span class="comment">//close p2 read</span></span><br><span class="line">    write(p1[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">    close(p1[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">10</span>];</span><br><span class="line">    read(p2[<span class="number">0</span>],buff, <span class="number">4</span>);</span><br><span class="line">    close(p2[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buff);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prime"><a class="markdownIt-Anchor" href="#prime">#</a> prime</h4><p>这个题细心阅读他给的文档就行了</p><p>这个解决思路就是每一次筛一个数的倍数，筛到给定的值就行了。</p><p>递归解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subProcess</span><span class="params">(<span class="type">int</span> *oldFd)</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭原管道写端</span></span><br><span class="line">    close(oldFd[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">// 若能从原管道读到数据</span></span><br><span class="line">    <span class="keyword">if</span> (read(oldFd[<span class="number">0</span>], &amp;prime, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">// 第一个数据为质数,进行输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">        <span class="comment">// 创建管道和子进程</span></span><br><span class="line">        pipe(fd);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;    <span class="comment">//子进程</span></span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            subProcess(fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 父进程</span></span><br><span class="line">            <span class="comment">// 关闭新管道读端</span></span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 从原管道进行读取</span></span><br><span class="line">            <span class="keyword">while</span> (read(oldFd[<span class="number">0</span>], &amp;num, <span class="number">4</span>)) &#123;</span><br><span class="line">                <span class="comment">// 不能被记录的质数整除则写入新管道</span></span><br><span class="line">                <span class="keyword">if</span> (num % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(fd[<span class="number">1</span>], &amp;num, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时父进程的原管道关闭, 则关闭原管道的读端</span></span><br><span class="line">            close(oldFd[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 关闭新管道的写端</span></span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 等待子进程结束</span></span><br><span class="line">            wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 此时说明原管道已关闭,第一个数字都读不出</span></span><br><span class="line">        <span class="comment">// 不创建子进程直接关闭原管道读端</span></span><br><span class="line">        close(oldFd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        subProcess(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 遍历 2~35 写入管道写端</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i) &#123;</span><br><span class="line">            write(fd[<span class="number">1</span>], &amp;i, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写完关闭管道写端并等待子进程结束</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="find"><a class="markdownIt-Anchor" href="#find">#</a> find</h4><p>参考 ls 的实现，就简单改一下，遍历当前路径下所有文件名，如果发现当前文件是一个文件夹，就递归下去，如果发现当前是一个文件并且文件名同所要查找的一样，那就输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(<span class="type">char</span> *dir, <span class="type">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 声明 文件名缓冲区 和 指针</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="comment">// 声明文件描述符 fd</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 声明与文件相关的结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open() 函数打开路径，返回一个文件描述符，如果错误返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(dir, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 报错，提示无法打开此路径</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, dir);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int fstat(int fd, struct stat *);</span></span><br><span class="line">    <span class="comment">// 系统调用 fstat 与 stat 类似，但它以文件描述符作为参数</span></span><br><span class="line">    <span class="comment">// int stat(char *, struct stat *);</span></span><br><span class="line">    <span class="comment">// stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本</span></span><br><span class="line">    <span class="comment">// stat 以文件名作为参数，返回文件的 i 结点中的所有信息</span></span><br><span class="line">    <span class="comment">// 如果出错，则返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出错则报错</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, dir);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是目录类型</span></span><br><span class="line">    <span class="keyword">if</span> (st.type != T_DIR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 报类型不是目录错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: %s is not a directory\n&quot;</span>, dir);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径过长放不入缓冲区，则报错提示</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(dir) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: directory too long\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 dir 指向的字符串即绝对路径复制到 buf</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, dir);</span><br><span class="line">    <span class="comment">// buf 是一个绝对路径，p 是一个文件名，通过加 &quot;/&quot; 前缀拼接在 buf 的后面</span></span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="comment">// 读取 fd ，如果 read 返回字节数与 de 长度相等则循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// strcmp(s, t);</span></span><br><span class="line">        <span class="comment">// 根据 s 指向的字符串小于（s&lt;t）、等于（s==t）或大于（s&gt;t） t 指向的字符串的不同情况</span></span><br><span class="line">        <span class="comment">// 分别返回负整数、0或正整数</span></span><br><span class="line">        <span class="comment">// 不要递归 &quot;.&quot; 和 &quot;...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// memmove，把 de.name 信息复制 p，其中 de.name 代表文件名</span></span><br><span class="line">        <span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">        <span class="comment">// 设置文件名结束符</span></span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int stat(char *, struct stat *);</span></span><br><span class="line">        <span class="comment">// stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本</span></span><br><span class="line">        <span class="comment">// stat 以文件名作为参数，返回文件的 i 结点中的所有信息</span></span><br><span class="line">        <span class="comment">// 如果出错，则返回 -1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 出错则报错</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是目录类型，递归查找</span></span><br><span class="line">        <span class="keyword">if</span> (st.type == T_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">find</span>(buf, file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是文件类型 并且 名称与要查找的文件名相同</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_FILE &amp;&amp; !<span class="built_in">strcmp</span>(de.name, file))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印缓冲区存放的路径</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果参数个数不为 3 则报错</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出提示</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: input should be three\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 find 函数查找指定目录下的文件</span></span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="xargs"><a class="markdownIt-Anchor" href="#xargs">#</a> xargs</h4><p>也还行，利用 fork 子进程然后 exec 执行命令就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果参数个数小于 2</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印参数错误提示</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: xargs command\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放子进程 exec 的参数</span></span><br><span class="line">    <span class="type">char</span> * argvs[MAXARG];</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 略去 xargs ，用来保存命令行参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        argvs[index++] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓冲区存放从管道读出的数据</span></span><br><span class="line">    <span class="type">char</span> buf[MAXN] = &#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="comment">// 0 代表的是管道的 0，也就是从管道循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span>((n = read(<span class="number">0</span>, buf, MAXN)) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 临时缓冲区存放追加的参数</span></span><br><span class="line"><span class="type">char</span> temp[MAXN] = &#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// xargs 命令的参数后面再追加参数</span></span><br><span class="line">        argvs[index] = temp;</span><br><span class="line">        <span class="comment">// 内循环获取追加的参数并创建子进程执行命令</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(buf); ++i) &#123;</span><br><span class="line">            <span class="comment">// 读取单个输入行，当遇到换行符时，创建子线程</span></span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建子线程执行命令</span></span><br><span class="line">                <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                    exec(argv[<span class="number">1</span>], argvs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待子线程执行完毕</span></span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，读取管道的输出作为输入</span></span><br><span class="line">                temp[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-xv6-and-unix-utilities&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-xv6-and-unix-utilities&quot;&gt;#&lt;/a&gt; Lab: Xv6 and Unix utilities&lt;/h1&gt;
&lt;</summary>
      
    
    
    
    
    <category term="MIT6.S081" scheme="https://flowerhai.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>multi-thread-exercise</title>
    <link href="https://flowerhai.github.io/2023/05/11/mutlthread/"/>
    <id>https://flowerhai.github.io/2023/05/11/mutlthread/</id>
    <published>2023-05-11T09:38:53.000Z</published>
    <updated>2023-05-11T09:39:59.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程编程"><a class="markdownIt-Anchor" href="#多线程编程">#</a> 多线程编程</h1><p>随便找几个多线程练习题练练手</p><p>1. 实现两个线程交替打印 1-100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="comment">/*实现两个线程交替打印1-100*/</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COUNT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumber</span><span class="params">(<span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (count &lt;= MAX_COUNT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == threadId) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printNumber, <span class="number">0</span>)</span></span>;  <span class="comment">// 线程0打印奇数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printNumber, <span class="number">1</span>)</span></span>;  <span class="comment">// 线程1打印偶数</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环 50 次，试写出代码</p><p>有点怪说实话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次，试写出代码。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_LOOPS = <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB_THREAD_LOOP_COUNT = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAIN_THREAD_LOOP_COUNT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isSubThreadTurn = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subThreadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_LOOPS; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> isSubThreadTurn; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SUB_THREAD_LOOP_COUNT; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Sub Thread: &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSubThreadTurn = <span class="literal">false</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">subThread</span><span class="params">(subThreadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_LOOPS; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !isSubThreadTurn; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MAIN_THREAD_LOOP_COUNT; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Main Thread: &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSubThreadTurn = <span class="literal">true</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有四个线程 1、2、3、4。线程 1 的功能就是输出 1，线程 2 的功能就是输出 2，</p><p>以此类推… 现在有四个文件 ABCD。初始都为空。现要让四个文件呈如下格式：</p><p>A：1 2 3 4 1 2…</p><p>B：2 3 4 1 2 3…</p><p>C：3 4 1 2 3 4…</p><p>D：4 1 2 3 4 1…</p><p>这个题比前面的有意思多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有四个线程1、2、3、4。线程1的功能就是输出1，线程2的功能就是输出2，</span></span><br><span class="line"><span class="comment">以此类推.........现在有四个文件ABCD。初始都为空。现要让四个文件呈如下格式：</span></span><br><span class="line"><span class="comment">A：1 2 3 4 1 2....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">B：2 3 4 1 2 3....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C：3 4 1 2 3 4....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">D：4 1 2 3 4 1....*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">4</span>; <span class="comment">// 线程数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxCount = <span class="number">10</span>; <span class="comment">// 每个线程要输出的数字总数</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ofstream&gt; <span class="title">outputFiles</span><span class="params">(numThreads)</span></span>; <span class="comment">// 输出文件流对象</span></span><br><span class="line"><span class="function">vector&lt;mutex&gt; <span class="title">fileMutexes</span><span class="params">(numThreads)</span></span>; <span class="comment">// 互斥锁，用于对文件进行同步访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> startNumber = threadId ; <span class="comment">// 每个线程的起始数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> number = (startNumber + i) % numThreads + <span class="number">1</span>; <span class="comment">// 计算当前要写入文件的数字</span></span><br><span class="line"></span><br><span class="line">        fileMutexes[threadId].<span class="built_in">lock</span>(); <span class="comment">// 获取当前线程对应的互斥锁</span></span><br><span class="line"></span><br><span class="line">        outputFiles[threadId] &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 将数字写入对应的文件</span></span><br><span class="line"></span><br><span class="line">        fileMutexes[threadId].<span class="built_in">unlock</span>(); <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        <span class="type">char</span> fileName = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">        outputFiles[i].<span class="built_in">open</span>(<span class="built_in">string</span>(<span class="number">1</span>, fileName) + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; threads; <span class="comment">// 线程对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        outputFiles[i].<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件写入完成。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经验证，符合题意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程编程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多线程编程&quot;&gt;#&lt;/a&gt; 多线程编程&lt;/h1&gt;
&lt;p&gt;随便找几个多线程练习题练练手&lt;/p&gt;
&lt;p&gt;1. 实现两个线程交替打印 1-100&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
    <category term="多线程编程" scheme="https://flowerhai.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081Lab:Xv6 and Unix utilities-part0</title>
    <link href="https://flowerhai.github.io/2023/05/11/s081/lab0/"/>
    <id>https://flowerhai.github.io/2023/05/11/s081/lab0/</id>
    <published>2023-05-11T08:11:13.000Z</published>
    <updated>2023-05-15T10:51:14.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mit6s081lab-xv6-and-unix-utilities"><a class="markdownIt-Anchor" href="#mit6s081lab-xv6-and-unix-utilities">#</a> MIT6.S081Lab: Xv6 and Unix utilities</h1><p>先来开个头</p><p>首先是 linux 开发环境搭建，我仍旧用的是阿里云 ECS Ubuntu  22.04 64 位</p><p>然后就是安装一些必备的包喽</p><p>将 git 到本地后进入文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure><p>成功后出现如下</p><p>ls 一下成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2226</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line">cat            2 4 24192</span><br><span class="line">echo           2 5 23016</span><br><span class="line">forktest       2 6 13240</span><br><span class="line">grep           2 7 27496</span><br><span class="line">init           2 8 23752</span><br><span class="line">kill           2 9 22960</span><br><span class="line">ln             2 10 22800</span><br><span class="line">ls             2 11 26384</span><br><span class="line">mkdir          2 12 23096</span><br><span class="line">rm             2 13 23080</span><br><span class="line">sh             2 14 41912</span><br><span class="line">stressfs       2 15 23952</span><br><span class="line">usertests      2 16 157000</span><br><span class="line">grind          2 17 38128</span><br><span class="line">wc             2 18 25280</span><br><span class="line">zombie         2 19 22344</span><br><span class="line">console        3 20 0</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure><p>先开个头吧，最近好累，字节青训营也开始了。</p><p>那边 CS144 的实验也并没有完全彻彻底底搞明白，下周开始做这个，预计这个六月份之前全部做完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mit6s081lab-xv6-and-unix-utilities&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mit6s081lab-xv6-and-unix-utilities&quot;&gt;#&lt;/a&gt; MIT6.S081Lab: Xv6 </summary>
      
    
    
    
    
    <category term="MIT6.S081" scheme="https://flowerhai.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>CS144Lab 4:the summit (TCP in full)</title>
    <link href="https://flowerhai.github.io/2023/05/11/cs144/cs144lab4/"/>
    <id>https://flowerhai.github.io/2023/05/11/cs144/cs144lab4/</id>
    <published>2023-05-11T03:45:21.000Z</published>
    <updated>2023-05-11T03:47:44.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab-4-the-summit-tcp-in-full"><a class="markdownIt-Anchor" href="#cs144lab-4-the-summit-tcp-in-full">#</a> CS144Lab 4: the summit (TCP in full)</h1><p>这节 lab 主要是将前面三小节的拼起来，以及繁琐的设计，难度估计比前面的加起来都离谱。</p><p>tcp_state.cc</p><p>TCP 的 FSM</p><p>然后看哪里错了，蛮慢慢改吧</p><p>TCP 中每一段的格式</p><p>讲义慢慢琢磨</p><p>OMG，so hard!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ms_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cerr&lt;&lt;&quot;receive: &quot; &lt;&lt; seg.header().to_string() &lt;&lt; &quot;length:&quot;&lt;&lt;seg.length_in_sequence_space()&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    _ms_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> send_empty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win)) &#123;</span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fsm_ack_rst_relaxed: ack in the future -&gt; sent ack back</span></span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> recv_recv = _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="keyword">if</span> (!recv_recv) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn &amp;&amp; !_sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore out of window RST</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (recv_recv || (seg.<span class="built_in">header</span>().ack &amp;&amp; (_sender.<span class="built_in">next_seqno</span>() == seg.<span class="built_in">header</span>().ackno))) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            <span class="built_in">test_end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_sender.<span class="built_in">fin_sent</span>()) &#123;  <span class="comment">// FIN + ACK</span></span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (send_empty &amp;&amp; _receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (!_clean_shutdown) &amp;&amp; (!_unclean_shutdown) &amp;&amp; (!_rst); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> size = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    _ms_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_rst) &#123;</span><br><span class="line">        _rst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            <span class="built_in">fill_queue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test the end of TCP connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::test_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; (<span class="built_in">unassembled_bytes</span>() == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>) &amp;&amp; _sender.<span class="built_in">fin_sent</span>()) &#123;</span><br><span class="line">        <span class="comment">// bytes_in_flight==0 =&gt; state: FIN_ACKED</span></span><br><span class="line">        _clean_shutdown |= (!_linger_after_streams_finish);</span><br><span class="line">        _unclean_shutdown |= (_ms_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill queue from _sender.segments_out() to _segments_out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::fill_queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; !_rst) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_rst || (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS)) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            seg = TCPSegment&#123;&#125;;</span><br><span class="line">            seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// TCPReceiver wants to advertise a window size</span></span><br><span class="line">            <span class="keyword">if</span> (_receiver.<span class="built_in">window_size</span>() &lt; numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  cerr &lt;&lt; &quot;send: &quot; &lt;&lt; seg.header().to_string()&lt;&lt;&quot;length:&quot; &lt;&lt; seg.length_in_sequence_space() &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前四个 lab 做完，有点懵，这周继续消化这四个 lab。</p><p>因为有的地方也参考了别人的 work，感觉完成的不是很好，这周吃透。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab-4-the-summit-tcp-in-full&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab-4-the-summit-tcp-in-full&quot;&gt;#&lt;/a&gt; CS144Lab 4: the summ</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144Lab 3:the TCP sender</title>
    <link href="https://flowerhai.github.io/2023/05/11/cs144/cs144lab3/"/>
    <id>https://flowerhai.github.io/2023/05/11/cs144/cs144lab3/</id>
    <published>2023-05-11T02:12:40.000Z</published>
    <updated>2023-05-11T02:13:41.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab-3-the-tcp-sender"><a class="markdownIt-Anchor" href="#cs144lab-3-the-tcp-sender">#</a> CS144Lab 3: the TCP sender</h1><h3 id="定时器"><a class="markdownIt-Anchor" href="#定时器">#</a> 定时器</h3><p>文件中说最好在类外重新定义一个定时器，那么便如此</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPRetransmissionTimer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! retransmission timer for the connection</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _initial_RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! retransmission timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _TO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer, 1:open, 0:close</span></span><br><span class="line">    <span class="type">bool</span> _open;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Initialize a TCP retransmission timer</span></span><br><span class="line">    <span class="built_in">TCPRetransmissionTimer</span>(<span class="type">const</span> <span class="type">uint16_t</span> retx_timeout)</span><br><span class="line">        : _initial_RTO(retx_timeout), _RTO(retx_timeout), _TO(<span class="number">0</span>), _open(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">open</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _open; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! start the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">true</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! close the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">false</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! tick</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">tick</span><span class="params">(<span class="type">size_t</span> &amp;ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ms_since_last_tick &gt; _RTO - _TO) &#123;</span><br><span class="line">            ms_since_last_tick -= (_RTO - _TO);</span><br><span class="line">            _TO = _RTO;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _TO += ms_since_last_tick;</span><br><span class="line">            ms_since_last_tick = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_TO &gt;= _RTO) &#123;</span><br><span class="line">            _TO = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// the retransmission timer has expired.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="fill_window"><a class="markdownIt-Anchor" href="#fill_window">#</a> fill_window</h3><p>首先先看一下_next_seqno 的值，如果_next_seqno 为 0 则说明当前处于关闭状态，应该启动并发送一个非空的 TCPsegment。</p><p>如果_next_seqno 和_nBytes_inflight 相等，说明我们之前已经发送过了 SYN，就不用再发送了。</p><p>如果 window_size 的大小为 0，我们将其设为 1.</p><p>然后就是发送一个尽可能大的 TCPSegment 喽。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!_stream.<span class="built_in">error</span>());</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// state is CLOSE, need to send SYN</span></span><br><span class="line">        seg.<span class="built_in">header</span>().syn = <span class="number">1</span>;</span><br><span class="line">        _syn_sent = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(seg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_next_seqno == _nBytes_inflight) &#123;</span><br><span class="line">        <span class="comment">// state is SYN SENT, don&#x27;t send SYN</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero window probing</span></span><br><span class="line">    <span class="type">uint16_t</span> window_size = _window_size ? _window_size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> remaining;</span><br><span class="line">    <span class="keyword">while</span> ((remaining = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(window_size) + (_recv_ackno - _next_seqno))) &#123;</span><br><span class="line">        <span class="comment">// FIN flag occupies space in window</span></span><br><span class="line">        TCPSegment new_seg;</span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !_fin_sent) &#123;</span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">size_t</span> size = <span class="built_in">min</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(remaining), TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">        new_seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(size));</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() &lt; window_size &amp;&amp; _stream.<span class="built_in">eof</span>()) &#123;  <span class="comment">// piggy-back FIN</span></span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ack_received"><a class="markdownIt-Anchor" href="#ack_received">#</a> ack_received</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="comment">//! \returns `false` if the ackno appears invalid (acknowledges something the TCPSender hasn&#x27;t sent yet)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ackno - <span class="built_in">next_seqno</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果window_size为0，需要记录下来，&quot;zero window probing&quot;, 影响tick()和fill_window()的行为</span></span><br><span class="line">    _window_size = window_size;</span><br><span class="line">    <span class="type">uint64_t</span> abs_ackno = <span class="built_in">unwrap</span>(ackno, _isn, _recv_ackno);</span><br><span class="line">    <span class="keyword">if</span> (abs_ackno &lt;= _recv_ackno) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _recv_ackno = abs_ackno;</span><br><span class="line">    <span class="comment">// acknowledges the successful receipt of new data</span></span><br><span class="line">    _timer._RTO = _timer._initial_RTO;</span><br><span class="line">    _timer._TO = <span class="number">0</span>;</span><br><span class="line">    _consecutive_retransmissions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque fully-acknowledged segments</span></span><br><span class="line">    <span class="keyword">while</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;seg = _segments_outstanding.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (ackno - seg.<span class="built_in">header</span>().seqno &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(seg.<span class="built_in">length_in_sequence_space</span>())) &#123;</span><br><span class="line">            _nBytes_inflight -= seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            _segments_outstanding.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the window</span></span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// any outstanding segment, restart the timer.</span></span><br><span class="line">    <span class="comment">// [RFC6298](5.3)</span></span><br><span class="line">    <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _timer.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tick"><a class="markdownIt-Anchor" href="#tick">#</a> tick</h3><p>这里基本上就是和超时重传差不多吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> time_left = ms_since_last_tick;</span><br><span class="line">    <span class="keyword">if</span> (_timer.<span class="built_in">tick</span>(time_left)) &#123;</span><br><span class="line">        <span class="comment">// Notice: remove fill_the_window() here to fix the test fsm_retx_relaxed</span></span><br><span class="line">        <span class="comment">// timer has expired, retransmit at most ONE outstanding segment</span></span><br><span class="line">        <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// retransmit the outstanding segment with the lowest sequence number</span></span><br><span class="line">            _segments_out.<span class="built_in">push</span>(_segments_outstanding.<span class="built_in">front</span>());</span><br><span class="line">            <span class="keyword">if</span> (_window_size) &#123;</span><br><span class="line">                _consecutive_retransmissions++;</span><br><span class="line">                _timer._RTO *= <span class="number">2</span>;  <span class="comment">// double the RTO, exponential backoff, it slows down retransmissions on lousy</span></span><br><span class="line">                                   <span class="comment">// networks to avoid further gumming up the works</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_timer.<span class="built_in">open</span>()) &#123;  <span class="comment">//[RFC6298](5.1)</span></span><br><span class="line">                _timer.<span class="built_in">start</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">syn_sent</span>() &amp;&amp; (_next_seqno == _nBytes_inflight) &amp;&amp; (_timer._RTO &lt; <span class="number">3000</span>)) &#123;</span><br><span class="line">                _timer._RTO = <span class="number">3000</span>;  <span class="comment">// SYN_SENT, [RFC6298](5.7)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _timer.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab-3-the-tcp-sender&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab-3-the-tcp-sender&quot;&gt;#&lt;/a&gt; CS144Lab 3: the TCP sender&lt;/h1&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>刷题记录-24天</title>
    <link href="https://flowerhai.github.io/2023/05/10/shuati/day24/"/>
    <id>https://flowerhai.github.io/2023/05/10/shuati/day24/</id>
    <published>2023-05-10T14:10:46.000Z</published>
    <updated>2023-05-10T14:11:25.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1015-可被-k-整除的最小整数"><a class="markdownIt-Anchor" href="#1015-可被-k-整除的最小整数">#</a> <a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/">1015. 可被 K 整除的最小整数</a></h4><p>给定正整数  <code>k</code>  ，你需要找出可以被  <code>k</code>  整除的、仅包含数字  <code>**1**</code>  的最 <strong>小</strong> 正整数  <code>n</code>  的长度。</p><p>返回  <code>n</code>  的长度。如果不存在这样的  <code>n</code>  ，就返回 - 1。</p><p><strong>注意：</strong>  <code>n</code>  不符合 64 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的答案是 n = 1，其长度为 1。</span><br></pre></td></tr></table></figure><p>能整除 2 或 5 的肯定不行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span> || k % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> resid = <span class="number">1</span> % k, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (resid != <span class="number">0</span>) &#123;</span><br><span class="line">            resid = (resid * <span class="number">10</span> + <span class="number">1</span>) % k;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点  <code>root</code>  ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p>也还行吧，递归就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_gain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INT_MAX;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;right),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pp = r + l + root-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, pp);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">max_gain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表">#</a> <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h4><p>给你一个链表的头节点  <code>head</code>  ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪  <code>next</code>  指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数  <code>pos</code>  来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意： <code>pos</code>  不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回  <code>true</code>  。 否则，返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>典型快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="79-单词搜索"><a class="markdownIt-Anchor" href="#79-单词搜索">#</a> <a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h4><p>给定一个  <code>m x n</code>  二维字符网格  <code>board</code>  和一个字符串单词  <code>word</code>  。如果  <code>word</code>  存在于网格中，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>嗯，好像没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ex</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, string word, <span class="type">int</span> d, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == word.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; board[i][j] == word[d]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[d]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == word[d]) &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i<span class="number">-1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;board.<span class="built_in">size</span>() &amp;&amp; board[i+<span class="number">1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i+<span class="number">1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>&lt;board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[i][j+<span class="number">1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j+<span class="number">1</span>);</span><br><span class="line">            board[i][j] = word[d];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">ex</span>(board, word, <span class="number">0</span>, i, j);</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1015-可被-k-整除的最小整数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1015-可被-k-整除的最小整数&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/smallest-integ</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>CS144-summary1</title>
    <link href="https://flowerhai.github.io/2023/05/10/cs144/summary1/"/>
    <id>https://flowerhai.github.io/2023/05/10/cs144/summary1/</id>
    <published>2023-05-10T03:23:44.000Z</published>
    <updated>2023-05-10T03:24:17.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab0-1-2-summary"><a class="markdownIt-Anchor" href="#cs144lab0-1-2-summary">#</a> CS144lab0-1-2 summary</h1><p>在 lab0 中，首先实现了一个 get_url 函数，这个函数就是像指定地址发起 http 连接然后做出响应，注意一下 Htpp 报文响应格式就可以了。</p><p>随后我们又完成了 ByteStream 的实现。</p><p>这个 byteStream 主要就是实现 TCP 协议中的最基础的字节流，用来存储需要传输的字节。</p><p>在 lab1 中，实现 StreamReassembler。</p><p>这个主要是 TCP 协议中的数据流控制器，用来将传给 TCP 的数据确保有序写入 byteStream 中。</p><p>在 lab2 中，我们实现 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p><img src="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol><li>内核态下 UDP 数据包中的 payload 被解析为 TCPSegment (TCP 报文) 后，交给用户态下的 TCPConnection，即调用 segment_received 方法；</li><li>TCPConnection 收到报文后，将报文交给 TCPReceiver，即调用 TCPReceiver.segment_received 方法，并将报文中的 ackno (确认号) 与 window_size (窗口大小) 交给 TCPSender，即调用 ack_received 方法；</li><li>TCPReceiver 处理 TCP 报文，并将报文中的 payload 推入 StreamReassembler 中，并重组后交给应用程序，随后尝试发送报文；</li><li>TCPConnection 调用 TCPSender.fill_window 方法尝试得到待发送报文 (可能得不到，视具体情况而定)，若有报文，则设置报文 payload 以及其它字段，如 SYN、ackno (从 receiver 获取)、window_size 等，设置完毕后包装为 TCP 报文，将报文交给 UDP；</li><li>UDP 将其打包为数据报，并发送给远端。</li></ol><p>lab2 中只要注意这个图问题不大。</p><p><img src="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>在 TCP header 中 seqno 与 ackno 都是 32 位整数，但是 isn 是发送者随机生成的数字，那么可能会产生一个问题：如果随机生成的 isn 十分接近 2^32-1 怎么办？</p><p>这代表，TCP 数据流很快就会溢出 seqno。为了解决这个问题，sponge 实现了两个序号，一个是正常的 TCP header seqno，32 位，使用 WrappingInt32 表示，初始化为随机数，另一个是绝对 seqno 序号，使用 uint64_t 表示，初始化为 0。用绝对序号来表示数据流上字节的数量，最大数量为 2^64-1，这几乎是不可能达成的目标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab0-1-2-summary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab0-1-2-summary&quot;&gt;#&lt;/a&gt; CS144lab0-1-2 summary&lt;/h1&gt;
&lt;p&gt;在 lab0 中，首先实现了</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
</feed>
