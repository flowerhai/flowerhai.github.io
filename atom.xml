<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚迷离</title>
  
  
  <link href="https://flowerhai.github.io/atom.xml" rel="self"/>
  
  <link href="https://flowerhai.github.io/"/>
  <updated>2023-05-11T03:47:44.596Z</updated>
  <id>https://flowerhai.github.io/</id>
  
  <author>
    <name>恍惚迷离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS144Lab 4:the summit (TCP in full)</title>
    <link href="https://flowerhai.github.io/2023/05/11/cs144/cs144lab4/"/>
    <id>https://flowerhai.github.io/2023/05/11/cs144/cs144lab4/</id>
    <published>2023-05-11T03:45:21.000Z</published>
    <updated>2023-05-11T03:47:44.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab-4-the-summit-tcp-in-full"><a class="markdownIt-Anchor" href="#cs144lab-4-the-summit-tcp-in-full">#</a> CS144Lab 4: the summit (TCP in full)</h1><p>这节 lab 主要是将前面三小节的拼起来，以及繁琐的设计，难度估计比前面的加起来都离谱。</p><p>tcp_state.cc</p><p>TCP 的 FSM</p><p>然后看哪里错了，蛮慢慢改吧</p><p>TCP 中每一段的格式</p><p>讲义慢慢琢磨</p><p>OMG，so hard!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ms_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cerr&lt;&lt;&quot;receive: &quot; &lt;&lt; seg.header().to_string() &lt;&lt; &quot;length:&quot;&lt;&lt;seg.length_in_sequence_space()&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    _ms_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> send_empty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win)) &#123;</span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fsm_ack_rst_relaxed: ack in the future -&gt; sent ack back</span></span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> recv_recv = _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="keyword">if</span> (!recv_recv) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn &amp;&amp; !_sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore out of window RST</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (recv_recv || (seg.<span class="built_in">header</span>().ack &amp;&amp; (_sender.<span class="built_in">next_seqno</span>() == seg.<span class="built_in">header</span>().ackno))) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            <span class="built_in">test_end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_sender.<span class="built_in">fin_sent</span>()) &#123;  <span class="comment">// FIN + ACK</span></span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (send_empty &amp;&amp; _receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (!_clean_shutdown) &amp;&amp; (!_unclean_shutdown) &amp;&amp; (!_rst); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> size = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    _ms_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_rst) &#123;</span><br><span class="line">        _rst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            <span class="built_in">fill_queue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test the end of TCP connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::test_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; (<span class="built_in">unassembled_bytes</span>() == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>) &amp;&amp; _sender.<span class="built_in">fin_sent</span>()) &#123;</span><br><span class="line">        <span class="comment">// bytes_in_flight==0 =&gt; state: FIN_ACKED</span></span><br><span class="line">        _clean_shutdown |= (!_linger_after_streams_finish);</span><br><span class="line">        _unclean_shutdown |= (_ms_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill queue from _sender.segments_out() to _segments_out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::fill_queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; !_rst) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_rst || (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS)) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            seg = TCPSegment&#123;&#125;;</span><br><span class="line">            seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// TCPReceiver wants to advertise a window size</span></span><br><span class="line">            <span class="keyword">if</span> (_receiver.<span class="built_in">window_size</span>() &lt; numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  cerr &lt;&lt; &quot;send: &quot; &lt;&lt; seg.header().to_string()&lt;&lt;&quot;length:&quot; &lt;&lt; seg.length_in_sequence_space() &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前四个 lab 做完，有点懵，这周继续消化这四个 lab。</p><p>因为有的地方也参考了别人的 work，感觉完成的不是很好，这周吃透。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab-4-the-summit-tcp-in-full&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab-4-the-summit-tcp-in-full&quot;&gt;#&lt;/a&gt; CS144Lab 4: the summ</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144Lab 3:the TCP sender</title>
    <link href="https://flowerhai.github.io/2023/05/11/cs144/cs144lab3/"/>
    <id>https://flowerhai.github.io/2023/05/11/cs144/cs144lab3/</id>
    <published>2023-05-11T02:12:40.000Z</published>
    <updated>2023-05-11T02:13:41.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab-3-the-tcp-sender"><a class="markdownIt-Anchor" href="#cs144lab-3-the-tcp-sender">#</a> CS144Lab 3: the TCP sender</h1><h3 id="定时器"><a class="markdownIt-Anchor" href="#定时器">#</a> 定时器</h3><p>文件中说最好在类外重新定义一个定时器，那么便如此</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPRetransmissionTimer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! retransmission timer for the connection</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _initial_RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! retransmission timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _TO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer, 1:open, 0:close</span></span><br><span class="line">    <span class="type">bool</span> _open;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Initialize a TCP retransmission timer</span></span><br><span class="line">    <span class="built_in">TCPRetransmissionTimer</span>(<span class="type">const</span> <span class="type">uint16_t</span> retx_timeout)</span><br><span class="line">        : _initial_RTO(retx_timeout), _RTO(retx_timeout), _TO(<span class="number">0</span>), _open(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">open</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _open; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! start the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">true</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! close the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">false</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! tick</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">tick</span><span class="params">(<span class="type">size_t</span> &amp;ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ms_since_last_tick &gt; _RTO - _TO) &#123;</span><br><span class="line">            ms_since_last_tick -= (_RTO - _TO);</span><br><span class="line">            _TO = _RTO;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _TO += ms_since_last_tick;</span><br><span class="line">            ms_since_last_tick = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_TO &gt;= _RTO) &#123;</span><br><span class="line">            _TO = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// the retransmission timer has expired.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="fill_window"><a class="markdownIt-Anchor" href="#fill_window">#</a> fill_window</h3><p>首先先看一下_next_seqno 的值，如果_next_seqno 为 0 则说明当前处于关闭状态，应该启动并发送一个非空的 TCPsegment。</p><p>如果_next_seqno 和_nBytes_inflight 相等，说明我们之前已经发送过了 SYN，就不用再发送了。</p><p>如果 window_size 的大小为 0，我们将其设为 1.</p><p>然后就是发送一个尽可能大的 TCPSegment 喽。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!_stream.<span class="built_in">error</span>());</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// state is CLOSE, need to send SYN</span></span><br><span class="line">        seg.<span class="built_in">header</span>().syn = <span class="number">1</span>;</span><br><span class="line">        _syn_sent = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(seg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_next_seqno == _nBytes_inflight) &#123;</span><br><span class="line">        <span class="comment">// state is SYN SENT, don&#x27;t send SYN</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero window probing</span></span><br><span class="line">    <span class="type">uint16_t</span> window_size = _window_size ? _window_size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> remaining;</span><br><span class="line">    <span class="keyword">while</span> ((remaining = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(window_size) + (_recv_ackno - _next_seqno))) &#123;</span><br><span class="line">        <span class="comment">// FIN flag occupies space in window</span></span><br><span class="line">        TCPSegment new_seg;</span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !_fin_sent) &#123;</span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">size_t</span> size = <span class="built_in">min</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(remaining), TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">        new_seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(size));</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() &lt; window_size &amp;&amp; _stream.<span class="built_in">eof</span>()) &#123;  <span class="comment">// piggy-back FIN</span></span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ack_received"><a class="markdownIt-Anchor" href="#ack_received">#</a> ack_received</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="comment">//! \returns `false` if the ackno appears invalid (acknowledges something the TCPSender hasn&#x27;t sent yet)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ackno - <span class="built_in">next_seqno</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果window_size为0，需要记录下来，&quot;zero window probing&quot;, 影响tick()和fill_window()的行为</span></span><br><span class="line">    _window_size = window_size;</span><br><span class="line">    <span class="type">uint64_t</span> abs_ackno = <span class="built_in">unwrap</span>(ackno, _isn, _recv_ackno);</span><br><span class="line">    <span class="keyword">if</span> (abs_ackno &lt;= _recv_ackno) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _recv_ackno = abs_ackno;</span><br><span class="line">    <span class="comment">// acknowledges the successful receipt of new data</span></span><br><span class="line">    _timer._RTO = _timer._initial_RTO;</span><br><span class="line">    _timer._TO = <span class="number">0</span>;</span><br><span class="line">    _consecutive_retransmissions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque fully-acknowledged segments</span></span><br><span class="line">    <span class="keyword">while</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;seg = _segments_outstanding.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (ackno - seg.<span class="built_in">header</span>().seqno &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(seg.<span class="built_in">length_in_sequence_space</span>())) &#123;</span><br><span class="line">            _nBytes_inflight -= seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            _segments_outstanding.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the window</span></span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// any outstanding segment, restart the timer.</span></span><br><span class="line">    <span class="comment">// [RFC6298](5.3)</span></span><br><span class="line">    <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _timer.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tick"><a class="markdownIt-Anchor" href="#tick">#</a> tick</h3><p>这里基本上就是和超时重传差不多吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> time_left = ms_since_last_tick;</span><br><span class="line">    <span class="keyword">if</span> (_timer.<span class="built_in">tick</span>(time_left)) &#123;</span><br><span class="line">        <span class="comment">// Notice: remove fill_the_window() here to fix the test fsm_retx_relaxed</span></span><br><span class="line">        <span class="comment">// timer has expired, retransmit at most ONE outstanding segment</span></span><br><span class="line">        <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// retransmit the outstanding segment with the lowest sequence number</span></span><br><span class="line">            _segments_out.<span class="built_in">push</span>(_segments_outstanding.<span class="built_in">front</span>());</span><br><span class="line">            <span class="keyword">if</span> (_window_size) &#123;</span><br><span class="line">                _consecutive_retransmissions++;</span><br><span class="line">                _timer._RTO *= <span class="number">2</span>;  <span class="comment">// double the RTO, exponential backoff, it slows down retransmissions on lousy</span></span><br><span class="line">                                   <span class="comment">// networks to avoid further gumming up the works</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_timer.<span class="built_in">open</span>()) &#123;  <span class="comment">//[RFC6298](5.1)</span></span><br><span class="line">                _timer.<span class="built_in">start</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">syn_sent</span>() &amp;&amp; (_next_seqno == _nBytes_inflight) &amp;&amp; (_timer._RTO &lt; <span class="number">3000</span>)) &#123;</span><br><span class="line">                _timer._RTO = <span class="number">3000</span>;  <span class="comment">// SYN_SENT, [RFC6298](5.7)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _timer.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab-3-the-tcp-sender&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab-3-the-tcp-sender&quot;&gt;#&lt;/a&gt; CS144Lab 3: the TCP sender&lt;/h1&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>刷题记录-24天</title>
    <link href="https://flowerhai.github.io/2023/05/10/shuati/day24/"/>
    <id>https://flowerhai.github.io/2023/05/10/shuati/day24/</id>
    <published>2023-05-10T14:10:46.000Z</published>
    <updated>2023-05-10T14:11:25.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1015-可被-k-整除的最小整数"><a class="markdownIt-Anchor" href="#1015-可被-k-整除的最小整数">#</a> <a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/">1015. 可被 K 整除的最小整数</a></h4><p>给定正整数  <code>k</code>  ，你需要找出可以被  <code>k</code>  整除的、仅包含数字  <code>**1**</code>  的最 <strong>小</strong> 正整数  <code>n</code>  的长度。</p><p>返回  <code>n</code>  的长度。如果不存在这样的  <code>n</code>  ，就返回 - 1。</p><p><strong>注意：</strong>  <code>n</code>  不符合 64 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的答案是 n = 1，其长度为 1。</span><br></pre></td></tr></table></figure><p>能整除 2 或 5 的肯定不行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span> || k % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> resid = <span class="number">1</span> % k, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (resid != <span class="number">0</span>) &#123;</span><br><span class="line">            resid = (resid * <span class="number">10</span> + <span class="number">1</span>) % k;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点  <code>root</code>  ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p>也还行吧，递归就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_gain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INT_MAX;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;right),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pp = r + l + root-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, pp);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">max_gain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表">#</a> <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h4><p>给你一个链表的头节点  <code>head</code>  ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪  <code>next</code>  指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数  <code>pos</code>  来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意： <code>pos</code>  不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回  <code>true</code>  。 否则，返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>典型快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="79-单词搜索"><a class="markdownIt-Anchor" href="#79-单词搜索">#</a> <a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h4><p>给定一个  <code>m x n</code>  二维字符网格  <code>board</code>  和一个字符串单词  <code>word</code>  。如果  <code>word</code>  存在于网格中，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>嗯，好像没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ex</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, string word, <span class="type">int</span> d, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == word.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; board[i][j] == word[d]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[d]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == word[d]) &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i<span class="number">-1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;board.<span class="built_in">size</span>() &amp;&amp; board[i+<span class="number">1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i+<span class="number">1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>&lt;board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[i][j+<span class="number">1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j+<span class="number">1</span>);</span><br><span class="line">            board[i][j] = word[d];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">ex</span>(board, word, <span class="number">0</span>, i, j);</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1015-可被-k-整除的最小整数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1015-可被-k-整除的最小整数&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/smallest-integ</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>CS144-summary1</title>
    <link href="https://flowerhai.github.io/2023/05/10/cs144/summary1/"/>
    <id>https://flowerhai.github.io/2023/05/10/cs144/summary1/</id>
    <published>2023-05-10T03:23:44.000Z</published>
    <updated>2023-05-10T03:24:17.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab0-1-2-summary"><a class="markdownIt-Anchor" href="#cs144lab0-1-2-summary">#</a> CS144lab0-1-2 summary</h1><p>在 lab0 中，首先实现了一个 get_url 函数，这个函数就是像指定地址发起 http 连接然后做出响应，注意一下 Htpp 报文响应格式就可以了。</p><p>随后我们又完成了 ByteStream 的实现。</p><p>这个 byteStream 主要就是实现 TCP 协议中的最基础的字节流，用来存储需要传输的字节。</p><p>在 lab1 中，实现 StreamReassembler。</p><p>这个主要是 TCP 协议中的数据流控制器，用来将传给 TCP 的数据确保有序写入 byteStream 中。</p><p>在 lab2 中，我们实现 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p><img src="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol><li>内核态下 UDP 数据包中的 payload 被解析为 TCPSegment (TCP 报文) 后，交给用户态下的 TCPConnection，即调用 segment_received 方法；</li><li>TCPConnection 收到报文后，将报文交给 TCPReceiver，即调用 TCPReceiver.segment_received 方法，并将报文中的 ackno (确认号) 与 window_size (窗口大小) 交给 TCPSender，即调用 ack_received 方法；</li><li>TCPReceiver 处理 TCP 报文，并将报文中的 payload 推入 StreamReassembler 中，并重组后交给应用程序，随后尝试发送报文；</li><li>TCPConnection 调用 TCPSender.fill_window 方法尝试得到待发送报文 (可能得不到，视具体情况而定)，若有报文，则设置报文 payload 以及其它字段，如 SYN、ackno (从 receiver 获取)、window_size 等，设置完毕后包装为 TCP 报文，将报文交给 UDP；</li><li>UDP 将其打包为数据报，并发送给远端。</li></ol><p>lab2 中只要注意这个图问题不大。</p><p><img src="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>在 TCP header 中 seqno 与 ackno 都是 32 位整数，但是 isn 是发送者随机生成的数字，那么可能会产生一个问题：如果随机生成的 isn 十分接近 2^32-1 怎么办？</p><p>这代表，TCP 数据流很快就会溢出 seqno。为了解决这个问题，sponge 实现了两个序号，一个是正常的 TCP header seqno，32 位，使用 WrappingInt32 表示，初始化为随机数，另一个是绝对 seqno 序号，使用 uint64_t 表示，初始化为 0。用绝对序号来表示数据流上字节的数量，最大数量为 2^64-1，这几乎是不可能达成的目标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab0-1-2-summary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab0-1-2-summary&quot;&gt;#&lt;/a&gt; CS144lab0-1-2 summary&lt;/h1&gt;
&lt;p&gt;在 lab0 中，首先实现了</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>刷题记录-第23天</title>
    <link href="https://flowerhai.github.io/2023/05/09/shuati/day23/"/>
    <id>https://flowerhai.github.io/2023/05/09/shuati/day23/</id>
    <published>2023-05-09T12:45:13.000Z</published>
    <updated>2023-05-09T12:45:50.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="池塘计数"><a class="markdownIt-Anchor" href="#池塘计数">#</a> 池塘计数</h3><p>农夫约翰有一片 N∗M ∗  的矩形土地。</p><p>最近，由于降雨的原因，部分土地被水淹没了。</p><p>现在用一个字符矩阵来表示他的土地。</p><p>每个单元格内，如果包含雨水，则用”W” 表示，如果不含雨水，则用”.” 表示。</p><p>现在，约翰想知道他的土地中形成了多少片池塘。</p><p>每组相连的积水单元格集合可以看作是一片池塘。</p><p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p><p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W” 块。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含两个整数 N  和 M 。</p><p>接下来 N  行，每行包含 M  个字符，字符为”W” 或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出一个整数，表示池塘数目。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤N,M≤10001≤ , ≤1000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>经典连通块问题喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    f[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//上、下、左、右、左上、右上、左下、右下</span></span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; f[x+<span class="number">1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (y+<span class="number">1</span>&lt;m &amp;&amp; f[x][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x<span class="number">-1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x+<span class="number">1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="type">char</span> a;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;W&#x27;</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;.&#x27;</span>) f[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热浪"><a class="markdownIt-Anchor" href="#热浪">#</a> 热浪</h3><p>德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！</p><p>他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。</p><p>农夫 John 此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p><p>John 已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。</p><p>这些路线包括起始点和终点一共有 T  个城镇，为了方便标号为 11 到 T 。</p><p>除了起点和终点外的每个城镇都由 <strong>双向道路</strong> 连向至少两个其它的城镇。</p><p>每条道路有一个通过费用（包括油费，过路费等等）。</p><p>给定一个地图，包含 C  条直接连接 22 个城镇的道路。</p><p>每条道路由道路的起点 Rs  ，终点 Re   和花费 Ci   组成。</p><p>求从起始的城镇 Ts   到终点的城镇 Te   最小的总费用。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>第一行: 44 个由空格隔开的整数: T,C,Ts,Te , ,  ,  ;</p><p>第 22 到第 C+1 +1 行：第 i+1 +1 行描述第 i  条道路，包含 33 个由空格隔开的整数: Rs,Re,Ci  ,  ,  。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>一个单独的整数表示从 Ts   到 Te   的最小总费用。</p><p>数据保证至少存在一条道路。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤T≤25001≤ ≤2500,<br>1≤C≤62001≤ ≤6200,<br>1≤Ts,Te,Rs,Re≤T1≤  ,  ,  ,  ≤ ,<br>1≤Ci≤10001≤  ≤1000</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><p>dijkstra 算法板子题算是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,c, nbeg, nend;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[nbeg] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c&gt;&gt;nbeg&gt;&gt;nend;</span><br><span class="line">    <span class="keyword">while</span> (c --) &#123;</span><br><span class="line">        <span class="type">int</span> k, p, l;</span><br><span class="line">        cin&gt;&gt;k&gt;&gt;p&gt;&gt;l;</span><br><span class="line">        g[k][p] = g[p][k] = <span class="built_in">min</span>(g[k][p], l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout&lt;&lt;dist[nend];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dijkstra 的整体思路比较清晰<br>即进行 n（n 为 n 的个数）次迭代去确定每个点到起点的最小值 最后输出的终点的即为我们要找的最短路的距离</p><p>所以按照这个思路除了存储图外我们还需要存储两个量</p><p>dist [n] // 用于存储每个点到起点的最短距离<br> st [n]   // 用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新</p><p>每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点<br>（至于为什么是这样那么这就涉及到 Dijkstra 算法的具体数学证明了 有兴趣的同学可以百度一下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t=<span class="number">-1</span>;       <span class="comment">//将t设置为-1 因为Dijkstra算法适用于不存在负权边的图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j])    <span class="comment">//该步骤即寻找还未确定最短路的点中路径最短的点</span></span><br><span class="line">        t=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述操作当前我们的 t 代表就是剩余未确定最短路的点中 路径最短的点<br>而与此同时该点的最短路径也已经确定我们将该点标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st[t]=true;</span><br></pre></td></tr></table></figure><p>然后用这个去更新其余未确定点的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离</span></span><br><span class="line"><span class="comment">//但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响</span></span><br><span class="line"><span class="comment">//当然你也可以在循环判断条件里加上if(!st[i])</span></span><br><span class="line"><span class="comment">//这里j从1开始只是为了代码的简洁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行 n 次迭代后最后就可以确定每个点的最短距离</p><h4 id="面试题-0101-判定字符是否唯一"><a class="markdownIt-Anchor" href="#面试题-0101-判定字符是否唯一">#</a> <a href="https://leetcode.cn/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一</a></h4><p>实现一个算法，确定一个字符串  <code>s</code>  的所有字符是否全都不同。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;</span><br><span class="line">输出: false </span><br></pre></td></tr></table></figure><p>题目说了全是小写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; astr.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[astr[i]-<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            a[astr[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍">#</a> <a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>典</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">max</span>(f[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(f[<span class="number">0</span>], f[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], <span class="built_in">max</span>(nums[i]+f[i<span class="number">-2</span>],f[i<span class="number">-1</span>]));</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="面试题-0202-返回倒数第-k-个节点"><a class="markdownIt-Anchor" href="#面试题-0202-返回倒数第-k-个节点">#</a> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></h4><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p>** 注意：** 本题相对原题稍作改动</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p>双指针喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">while</span> (h!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast ++;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;池塘计数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#池塘计数&quot;&gt;#&lt;/a&gt; 池塘计数&lt;/h3&gt;
&lt;p&gt;农夫约翰有一片 N∗M ∗  的矩形土地。&lt;/p&gt;
&lt;p&gt;最近，由于降雨的原因，部分土地被水淹没了。&lt;/p&gt;
&lt;p&gt;现在用一个字符</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day22</title>
    <link href="https://flowerhai.github.io/2023/05/08/shuati/day22/"/>
    <id>https://flowerhai.github.io/2023/05/08/shuati/day22/</id>
    <published>2023-05-08T13:32:35.000Z</published>
    <updated>2023-05-08T13:33:05.491Z</updated>
    
    <content type="html"><![CDATA[<h4 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站">#</a> <a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h4><p>在一条环路上有  <code>n</code>  个加油站，其中第  <code>i</code>  个加油站有汽油  <code>gas[i]</code>  升。</p><p>你有一辆油箱容量无限的的汽车，从第  <code>i</code>  个加油站开往第  <code>i+1</code>  个加油站需要消耗汽油  <code>cost[i]</code>  升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组  <code>gas</code>  和  <code>cost</code>  ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回  <code>-1</code>  。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p>贪心即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">                start = i + <span class="number">1</span>;  </span><br><span class="line">                curSum = <span class="number">0</span>;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="135-分发糖果"><a class="markdownIt-Anchor" href="#135-分发糖果">#</a> <a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h4><p><code>n</code>  个孩子站成一排。给你一个整数数组  <code>ratings</code>  表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到  <code>1</code>  个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure><p>从左向右，从右向左，各来一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="860-柠檬水找零"><a class="markdownIt-Anchor" href="#860-柠檬水找零">#</a> <a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h4><p>在柠檬水摊上，每一杯柠檬水的售价为  <code>5</code>  美元。顾客排队购买你的产品，（按账单  <code>bills</code>  支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付  <code>5</code>  美元、 <code>10</code>  美元或  <code>20</code>  美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付  <code>5</code>  美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组  <code>bills</code>  ，其中  <code>bills[i]</code>  是第  <code>i</code>  位顾客付的账。如果你能给每位顾客正确找零，返回  <code>true</code>  ，否则返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bill : bills) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="comment">// 情况二</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况三</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着</span></span><br><span class="line">                <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                    twenty++; <span class="comment">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                    twenty++; <span class="comment">// 同理，这行代码也可以删了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="406-根据身高重建队列"><a class="markdownIt-Anchor" href="#406-根据身高重建队列">#</a> <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><p>假设有打乱顺序的一群人站成一个队列，数组  <code>people</code>  表示队列中一些人的属性（不一定按顺序）。每个  <code>people[i] = [hi, ki]</code>  表示第  <code>i</code>  个人的身高为  <code>hi</code>  ，前面 <strong>正好</strong> 有  <code>ki</code>  个身高大于或等于  <code>hi</code>  的人。</p><p>请你重新构造并返回输入数组  <code>people</code>  所表示的队列。返回的队列应该格式化为数组  <code>queue</code>  ，其中  <code>queue[j] = [hj, kj]</code>  是队列中第  <code>j</code>  个人的属性（ <code>queue[0]</code>  是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 身高从大到小排（身高相同k小的站前面）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span> (people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que; <span class="comment">// list底层是链表实现，插入效率比vector高的多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>]; <span class="comment">// 插入到下标为position的位置</span></span><br><span class="line">            std::list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (position--) &#123; <span class="comment">// 寻找在插入位置</span></span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(it, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>感觉有时候贪心和动态规划有时候好像。</p><p>很想用动态规划上去结题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;134-加油站&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#134-加油站&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/gas-station/&quot;&gt;134. 加油站&lt;/a&gt;&lt;/h4&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>Lab 2:the TCP receiver</title>
    <link href="https://flowerhai.github.io/2023/05/08/cs144/cs144lab2/"/>
    <id>https://flowerhai.github.io/2023/05/08/cs144/cs144lab2/</id>
    <published>2023-05-08T12:54:52.000Z</published>
    <updated>2023-05-10T02:54:48.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#lab-2-the-tcp-receiver">#</a> Lab 2: the TCP receiver</h1><p>在 Lab2，我们将实现一个 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p>TCPReceiver 除了将读入的数据写入至 ByteStream 中以外，它还需要<strong>告诉发送者两个属性</strong>：</p><ul><li>第一个未组装的字节索引，称为<strong>确认号 ackno</strong>，它是接收者需要的第一个字节的索引。</li><li><strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的距离，称为 <strong>窗口长度 window size</strong>。</li></ul><p>ackno 和 window size 共同描述了接收者当前的<strong>接收窗口</strong>。接收窗口是 发送者允许发送数据的一个范围，通常 TCP 接收方使用接收窗口来进行<strong>流量控制</strong>，限制发送方发送数据。</p><p>总的来说，我们将要实现的 TCPReceiver 需要做以下几件事情：</p><ul><li>接收 TCP segment</li><li>重新组装字节流（包括 EOF）</li><li>确定应该发回给发送者的信号，以进行数据确认和流量控制</li></ul><h2 id="索引转换"><a class="markdownIt-Anchor" href="#索引转换">#</a> 索引转换</h2><p>TCP 报文中用来描述 ** 当前数据首字节的索引（序列号 seqno）** 是 32 位类型的，这意味着在处理上增加了一些需要考虑的东西：</p><p>在传输的 TCP 报文头部中，由于空间限制，字节序列号只能用 32 位的索引来表示。但是 32 位可能无法完全一一对应一串字节流，所以需要我们在接收端人为将索引转换为 64 位以保证不会溢出。</p><ul><li><p>由于 32 位类型最大能表达的值是 4GB，存在上溢的可能。因此当 32 位的 seqno 上溢后，下一个字节的 seqno 就重新从 0 开始。</p></li><li><p>处于安全性考虑，以及避免与之前的 TCP 报文混淆，TCP 需要让每个 seqno 都不可被猜测到，并且降低重复的可能性。因此 TCP seqno 不会从 0 开始，而是从一个 32 位随机数起步（称为<strong>初始序列号 ISN</strong>）。</p><p>而 ISN 是表示 SYN 包（用以表示 TCP 流的开始）的序列号。</p></li><li><p>TCP 流的<strong>逻辑开始数据包</strong>和<strong>逻辑结束数据包</strong>各占用一个 seqno。除了确保<strong>接收到所有字节的数据</strong>以外，TCP 还需要确保接收到<strong>流的开头和结尾</strong>。 因此，在 TCP 中，SYN（流开始）和 FIN（流结束）控制标志将会被分别分配一个序列号（SYN 标志占用的序列号就是 ISN）。</p><p>流中的每个数据字节也占用一个序列号。</p><p>但需要注意的是，SYN 和 FIN 不是流本身的一部分，也不是传输的字节数据。它们只是代表字节流本身的开始和结束。</p></li></ul><p>字节索引类型一多就容易乱。当前总共有三种索引：</p><ul><li>序列号 seqno。<strong>从 ISN 起步</strong>，包含 SYN 和 FIN，<strong>32 位循环</strong>计数</li><li>绝对序列号 absolute seqno。<strong>从 0 起步</strong>，包含 SYN 和 FIN，<strong>64 位非循环</strong>计数</li><li>流索引 stream index。<strong>从 0 起步</strong>，<strong>排除 SYN 和 FIN</strong>，<strong>64 位非循环</strong>计数。</li></ul><p>这是一个简单浅显的例子，用于区分开三种索引的区别：</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" class="lazyload placeholder" data-srcset="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211107105751818"></p><p>序列号和<strong>绝对</strong>序列号之间相互转换稍微有点麻烦，因为序列号是<strong>循环计数</strong>的。在该实验中，CS144 使用自定义类型 WrappingInt32 表示序列号，并编写了它与绝对序列号之间的转换。</p><p>这个实现稍微有点麻烦，而且实现的时候也最好避免各类循环，减少使用条件判断的次数，以提高执行效率。</p><h4 id="wrap"><a class="markdownIt-Anchor" href="#wrap">#</a> wrap</h4><p>该函数时将 64 位转化为 64 位，还是比较容易</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn); </span></span><br><span class="line">    <span class="comment">// return WrappingInt32&#123;0&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(isn.<span class="built_in">raw_value</span>() + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="unwrap"><a class="markdownIt-Anchor" href="#unwrap">#</a> unwrap</h4><p>该函数将 32 位转化为 64 位，需要动点脑子</p><p>因为 64 位变成 32 位肯定会有些数字代表的并不是一个，可能是多个 64 位的数据，所以这个时候就需要 checkpoint 来告诉我们是哪个</p><p>离得近就是！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn, checkpoint);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">uint64_t</span> offset = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n.<span class="built_in">raw_value</span>()-isn.<span class="built_in">raw_value</span>());</span><br><span class="line">    <span class="type">uint64_t</span> mod = checkpoint&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> ii  = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add = ii&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add_1 = offset + add*mod;</span><br><span class="line">    <span class="type">uint64_t</span> add_2 = offset + add*(mod+<span class="number">1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> add_3 = offset + add*(mod<span class="number">-1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> r_1 = add_1 &gt; checkpoint ? add_1 - checkpoint : checkpoint - add_1;</span><br><span class="line">    <span class="type">uint64_t</span> r_2 = add_2 &gt; checkpoint ? add_2 - checkpoint : checkpoint - add_2;</span><br><span class="line">    <span class="type">uint64_t</span> r_3 = add_3 &gt; checkpoint ? add_3 - checkpoint : checkpoint - add_3;</span><br><span class="line">    r_3 ++;</span><br><span class="line">    r_3 --;</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="number">0</span>) r_3 = INT64_MAX;</span><br><span class="line">    <span class="type">uint64_t</span> min_off = <span class="built_in">min</span>(<span class="built_in">min</span>(r_1, r_2), r_3);</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_1) <span class="keyword">return</span> add_1;</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_2) <span class="keyword">return</span> add_2;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> add_3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 1: t_wrapping_ints_cmp</span><br><span class="line">1/3 Test #1: t_wrapping_ints_cmp ..............   Passed    0.01 sec</span><br><span class="line">    Start 2: t_wrapping_ints_unwrap</span><br><span class="line">2/3 Test #2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span><br><span class="line">    Start 3: t_wrapping_ints_wrap</span><br><span class="line">3/3 Test #3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 3</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.02 sec</span><br></pre></td></tr></table></figure><h4 id="implementing-the-tcp-receiver"><a class="markdownIt-Anchor" href="#implementing-the-tcp-receiver">#</a> Implementing the TCP receiver</h4><p>调试还是蛮麻烦的，很难一下子考虑到所有情况欸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> abs_seqno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_syn_flag) &#123;  <span class="comment">// already get a SYN, refuse other SYN.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _syn_flag = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">        _isn = seg.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>();</span><br><span class="line">        abs_seqno = <span class="number">1</span>;</span><br><span class="line">        _base = <span class="number">1</span>;</span><br><span class="line">        length = seg.<span class="built_in">length_in_sequence_space</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;  <span class="comment">// segment&#x27;s content only have a SYN flag</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_syn_flag) &#123;  <span class="comment">// before get a SYN, refuse any segment</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// not a SYN segment, compute it&#x27;s abs_seqno</span></span><br><span class="line">        abs_seqno = <span class="built_in">unwrap</span>(<span class="built_in">WrappingInt32</span>(seg.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>()), <span class="built_in">WrappingInt32</span>(_isn), abs_seqno);</span><br><span class="line">        length = seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_fin_flag) &#123;  <span class="comment">// already get a FIN, refuse other FIN</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _fin_flag = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// not FIN and not one size&#x27;s SYN, check border</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp; abs_seqno == _base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (abs_seqno &gt;= _base + <span class="built_in">window_size</span>() || abs_seqno + length &lt;= _base) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(), abs_seqno - <span class="number">1</span>, seg.<span class="built_in">header</span>().fin);</span><br><span class="line">    _base = _reassembler.<span class="built_in">head_index</span>() + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">input_ended</span>())  <span class="comment">// FIN be count as one byte</span></span><br><span class="line">        _base++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_base &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(<span class="built_in">wrap</span>(_base, <span class="built_in">WrappingInt32</span>(_isn)));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _reassembler.<span class="built_in">stream_out</span>().<span class="built_in">buffer_size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>测试结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">      Start  <span class="number">1</span>: t_wrapping_ints_cmp</span><br><span class="line"> <span class="number">1</span>/<span class="number">25</span> Test  #<span class="number">1</span>: t_wrapping_ints_cmp ..............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">2</span>: t_wrapping_ints_unwrap</span><br><span class="line"> <span class="number">2</span>/<span class="number">25</span> Test  #<span class="number">2</span>: t_wrapping_ints_unwrap ...........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">3</span>: t_wrapping_ints_wrap</span><br><span class="line"> <span class="number">3</span>/<span class="number">25</span> Test  #<span class="number">3</span>: t_wrapping_ints_wrap .............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">4</span>: t_recv_connect</span><br><span class="line"> <span class="number">4</span>/<span class="number">25</span> Test  #<span class="number">4</span>: t_recv_connect ...................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">5</span>: t_recv_transmit</span><br><span class="line"> <span class="number">5</span>/<span class="number">25</span> Test  #<span class="number">5</span>: t_recv_transmit ..................   Passed    <span class="number">0.06</span> sec</span><br><span class="line">      Start  <span class="number">6</span>: t_recv_window</span><br><span class="line"> <span class="number">6</span>/<span class="number">25</span> Test  #<span class="number">6</span>: t_recv_window ....................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">7</span>: t_recv_reorder</span><br><span class="line"> <span class="number">7</span>/<span class="number">25</span> Test  #<span class="number">7</span>: t_recv_reorder ...................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">8</span>: t_recv_close</span><br><span class="line"> <span class="number">8</span>/<span class="number">25</span> Test  #<span class="number">8</span>: t_recv_close .....................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">15</span>: t_strm_reassem_single</span><br><span class="line"> <span class="number">9</span>/<span class="number">25</span> Test #<span class="number">15</span>: t_strm_reassem_single ............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">16</span>: t_strm_reassem_seq</span><br><span class="line"><span class="number">10</span>/<span class="number">25</span> Test #<span class="number">16</span>: t_strm_reassem_seq ...............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">17</span>: t_strm_reassem_dup</span><br><span class="line"><span class="number">11</span>/<span class="number">25</span> Test #<span class="number">17</span>: t_strm_reassem_dup ...............   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">18</span>: t_strm_reassem_holes</span><br><span class="line"><span class="number">12</span>/<span class="number">25</span> Test #<span class="number">18</span>: t_strm_reassem_holes .............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">19</span>: t_strm_reassem_many</span><br><span class="line"><span class="number">13</span>/<span class="number">25</span> Test #<span class="number">19</span>: t_strm_reassem_many ..............   Passed    <span class="number">0.13</span> sec</span><br><span class="line">      Start <span class="number">20</span>: t_strm_reassem_overlapping</span><br><span class="line"><span class="number">14</span>/<span class="number">25</span> Test #<span class="number">20</span>: t_strm_reassem_overlapping .......   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">21</span>: t_strm_reassem_win</span><br><span class="line"><span class="number">15</span>/<span class="number">25</span> Test #<span class="number">21</span>: t_strm_reassem_win ...............   Passed    <span class="number">0.12</span> sec</span><br><span class="line">      Start <span class="number">22</span>: t_strm_reassem_cap</span><br><span class="line"><span class="number">16</span>/<span class="number">25</span> Test #<span class="number">22</span>: t_strm_reassem_cap ...............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">23</span>: t_byte_stream_construction</span><br><span class="line"><span class="number">17</span>/<span class="number">25</span> Test #<span class="number">23</span>: t_byte_stream_construction .......   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">24</span>: t_byte_stream_one_write</span><br><span class="line"><span class="number">18</span>/<span class="number">25</span> Test #<span class="number">24</span>: t_byte_stream_one_write ..........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">25</span>: t_byte_stream_two_writes</span><br><span class="line"><span class="number">19</span>/<span class="number">25</span> Test #<span class="number">25</span>: t_byte_stream_two_writes .........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">26</span>: t_byte_stream_capacity</span><br><span class="line"><span class="number">20</span>/<span class="number">25</span> Test #<span class="number">26</span>: t_byte_stream_capacity ...........   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">27</span>: t_byte_stream_many_writes</span><br><span class="line"><span class="number">21</span>/<span class="number">25</span> Test #<span class="number">27</span>: t_byte_stream_many_writes ........   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">28</span>: t_webget</span><br><span class="line"><span class="number">22</span>/<span class="number">25</span> Test #<span class="number">28</span>: t_webget .........................   Passed    <span class="number">0.50</span> sec</span><br><span class="line">      Start <span class="number">48</span>: t_address_dt</span><br><span class="line"><span class="number">23</span>/<span class="number">25</span> Test #<span class="number">48</span>: t_address_dt .....................   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">49</span>: t_parser_dt</span><br><span class="line"><span class="number">24</span>/<span class="number">25</span> Test #<span class="number">49</span>: t_parser_dt ......................   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">50</span>: t_socket_dt</span><br><span class="line"><span class="number">25</span>/<span class="number">25</span> Test #<span class="number">50</span>: t_socket_dt ......................   Passed    <span class="number">0.01</span> sec</span><br><span class="line"></span><br><span class="line"><span class="number">100</span>% tests passed, <span class="number">0</span> tests failed out of <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="function">Total Test <span class="title">time</span> <span class="params">(real)</span> </span>=   <span class="number">0.98</span> sec</span><br><span class="line">[<span class="number">100</span>%] Built target check_lab2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-2-the-tcp-receiver&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-2-the-tcp-receiver&quot;&gt;#&lt;/a&gt; Lab 2: the TCP receiver&lt;/h1&gt;
&lt;p&gt;在 Lab2，我们将</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144- 太可恶了!</title>
    <link href="https://flowerhai.github.io/2023/05/08/cs144/css144/"/>
    <id>https://flowerhai.github.io/2023/05/08/cs144/css144/</id>
    <published>2023-05-08T04:08:07.000Z</published>
    <updated>2023-05-09T08:54:04.643Z</updated>
    
    <content type="html"><![CDATA[<p>强烈声讨</p><p>CS144lab2cmake文件</p><p>库文件写错了，一直只会给出not found</p><p>搞得我还以为自己没安装成功</p><p>头痛一上午</p><p>寻找了各种方法</p><p>mmp</p><p>最后忍不了了直接查看cmake文件</p><p>好啊</p><p>原来是你在那个地方一直给了一个not found</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;强烈声讨&lt;/p&gt;
&lt;p&gt;CS144lab2cmake文件&lt;/p&gt;
&lt;p&gt;库文件写错了，一直只会给出not found&lt;/p&gt;
&lt;p&gt;搞得我还以为自己没安装成功&lt;/p&gt;
&lt;p&gt;头痛一上午&lt;/p&gt;
&lt;p&gt;寻找了各种方法&lt;/p&gt;
&lt;p&gt;mmp&lt;/p&gt;
&lt;p&gt;最后忍不了了直接查看c</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>new-malloc-free-delete</title>
    <link href="https://flowerhai.github.io/2023/05/07/c-basic/new-malloc/"/>
    <id>https://flowerhai.github.io/2023/05/07/c-basic/new-malloc/</id>
    <published>2023-05-07T13:44:07.000Z</published>
    <updated>2023-05-07T13:44:55.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-delete"><a class="markdownIt-Anchor" href="#new-delete">#</a> new delete</h3><h3 id="new-和malloc的区别"><a class="markdownIt-Anchor" href="#new-和malloc的区别">#</a> new 和 malloc 的区别</h3><p>new 不仅可以开辟内存还可以初始化</p><p>malloc 开辟内存失败，是通过返回值和 nullptr 做比较的；而 new 开辟内存失败，是通过抛出 bad_alloc 类型的异常来判断的。</p><h3 id="delete和free的区别"><a class="markdownIt-Anchor" href="#delete和free的区别">#</a> delete 和 free 的区别</h3><p>malloc 和 free，C 的库函数</p><p>new 和 delete 运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">*p =<span class="number">20</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure><p>关于 delete 数组的时候</p><p>需要 delete [] p</p><p>如果不加的话只删第一个 (<strong>why?</strong>)</p><p>数组是一片连续的内存，释放时候你传递的数组名，也仅是一个指针，。<br>C++ 规定，delete p 时，仅删除指针指向的第一块内存。<br>delete [] p 才能把指针指向的一片连续内存都删除，因为在底层有一个变量，保存着需要删除的对象的数目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-delete&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#new-delete&quot;&gt;#&lt;/a&gt; new delete&lt;/h3&gt;
&lt;h3 id=&quot;new-和malloc的区别&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    
    <category term="C++基础" scheme="https://flowerhai.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>刷题day21</title>
    <link href="https://flowerhai.github.io/2023/05/07/shuati/day21/"/>
    <id>https://flowerhai.github.io/2023/05/07/shuati/day21/</id>
    <published>2023-05-07T12:59:45.000Z</published>
    <updated>2023-05-07T13:00:11.024Z</updated>
    
    <content type="html"><![CDATA[<p>今天是贪心专题 KMP 暂且缓缓 调试 lab1 花了太久太久</p><h3 id="贪心本质局部最优推出全局最优"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优">#</a> 贪心本质：局部最优推出全局最优。</h3><h4 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干">#</a> <a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子  <code>i</code> ，都有一个胃口值  <code>g[i]</code> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干  <code>j</code> ，都有一个尺寸  <code>s[j]</code>  。如果  <code>s[j] &gt;= g[i]</code> ，我们可以将这个饼干  <code>j</code>  分配给孩子  <code>i</code>  ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gl = <span class="number">0</span>, sl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (gl &lt; g.<span class="built_in">size</span>() &amp;&amp; sl &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sl] &gt;= g[gl]) &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">                gl ++;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="376-摆动序列"><a class="markdownIt-Anchor" href="#376-摆动序列">#</a> <a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 ** 摆动序列 。** 第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如，  <code>[1, 7, 4, 9, 2, 5]</code>  是一个 <strong>摆动序列</strong> ，因为差值  <code>(6, -3, 5, -7, 3)</code>  是正负交替出现的。</li><li>相反， <code>[1, 4, 7, 2, 5]</code>  和  <code>[1, 7, 4, 5, 5]</code>  不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组  <code>nums</code>  ，返回  <code>nums</code>  中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p>这题可以用 DP，当然今天是贪心专题，贪心做法就是去掉连续上升值中然后制造峰值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201126%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E5%91%A8">https://www.programmercarl.com/ 周总结 / 20201126 贪心周末总结.html# 周</a></p><h3 id="贪心本质局部最优推出全局最优-2"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优-2">#</a> 贪心本质：局部最优推出全局最优。</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是贪心专题 KMP 暂且缓缓 调试 lab1 花了太久太久&lt;/p&gt;
&lt;h3 id=&quot;贪心本质局部最优推出全局最优&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#贪心本质局部最优推出全局最优&quot;&gt;#&lt;/a&gt; 贪心本质：局部最优推出全局最优。&lt;/h</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>CS144Lab 1:stitching substrings into a byte stream</title>
    <link href="https://flowerhai.github.io/2023/05/07/cs144/cs144lab1/"/>
    <id>https://flowerhai.github.io/2023/05/07/cs144/cs144lab1/</id>
    <published>2023-05-07T12:17:15.000Z</published>
    <updated>2023-05-07T12:18:06.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#lab-1-stitching-substrings-into-a-byte-stream">#</a> Lab 1: stitching substrings into a byte stream</h1><h4 id="putting-substrings-in-sequence"><a class="markdownIt-Anchor" href="#putting-substrings-in-sequence">#</a> Putting substrings in sequence</h4><p>刚开始似乎思路出现了一些小小的偏差</p><p>想着用 unordered_map&lt;int,char&gt; 去直接把所有的信息都存进去。</p><p>实践发现，不太合适。</p><p>一直都是只能过 66.7%.</p><p>因为如果用 unordered_map 的话，其实不是很好把握住区间关系，虽然刚开始我是像借用数字寻找 char，然后就算是重复区间利用哈希表的特性完成问题，但是老是有意想不到的意外发生。</p><p>其实时间复杂度也不会低。</p><p>而且前后顺序出现问题是不能很好的解决的。</p><p>所以最后还是看了下别人写的，使用了两个 deque 来存，其实不用 deque 也可以的，这样也好吧，vector 也行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">char</span>&gt; buffer ;</span><br><span class="line">   std::deque&lt;<span class="type">bool</span>&gt; bufer_state ;</span><br><span class="line">   <span class="type">size_t</span> _unassembled_bytes = <span class="number">0</span>;<span class="comment">//已到地方索引</span></span><br><span class="line">   <span class="type">size_t</span> eof_index = <span class="number">0</span>;<span class="comment">//结束索引</span></span><br><span class="line">   <span class="type">bool</span> eof_ = <span class="literal">false</span>;</span><br><span class="line">   ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">   <span class="type">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就是具体的实现了</p><p>因为数据发送方可能是乱序发送的数据，所以这里需要注意下前后顺序啊，然后对区间进行截取。</p><p>相当于实现了 tcp 协议中的对数据流进行排序</p><p>气死我了 调试了一天不知道问题所在，忘记初始化</p><p>以及如果实在函数外初始化切记要按照定义先后顺序初始化，否则大坑</p><p>然后像这种取交集啊，一般都是左取大，右取小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DUMMY_CODE(data, index, eof);</span></span><br><span class="line">    <span class="type">size_t</span> first_unassembled_bytes = _output.<span class="built_in">bytes_written</span>();</span><br><span class="line">    <span class="type">size_t</span> first_unaccept = first_unassembled_bytes + _capacity;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= first_unaccept || index+data.<span class="built_in">size</span>() &lt; first_unassembled_bytes) <span class="keyword">return</span> ;<span class="comment">//两端之外，去掉</span></span><br><span class="line">    <span class="comment">//左取大，右取小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> first_begin = <span class="built_in">max</span>(first_unassembled_bytes, index);</span><br><span class="line">    <span class="type">size_t</span> first_end = <span class="built_in">min</span>(first_unaccept, index+data.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向buffer里写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = first_begin; i &lt; first_end; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !bufer_state[i-first_unassembled_bytes]) &#123;</span><br><span class="line">            buffer[i-first_unassembled_bytes] = data[i-index];</span><br><span class="line">            _unassembled_bytes++;</span><br><span class="line">            bufer_state[i-first_unassembled_bytes] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (bufer_state.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        res += buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">        bufer_state.<span class="built_in">pop_front</span>();</span><br><span class="line">        buffer.<span class="built_in">emplace_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">        bufer_state.<span class="built_in">emplace_back</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stream_out</span>().<span class="built_in">write</span>(res);</span><br><span class="line">        _unassembled_bytes -= res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        eof_ = <span class="literal">true</span>;</span><br><span class="line">        eof_index = first_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eof_ &amp;&amp; _output.<span class="built_in">bytes_written</span>() == eof_index) _output.<span class="built_in">end_input</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调了一天，终于过了，再多调一下就会爆炸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Testing the stream reassembler...</span></span><br><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">      Start 15: t_strm_reassem_single</span><br><span class="line"> 1/16 Test #15: t_strm_reassem_single ............   Passed    0.00 sec</span><br><span class="line">      Start 16: t_strm_reassem_seq</span><br><span class="line"> 2/16 Test #16: t_strm_reassem_seq ...............   Passed    0.00 sec</span><br><span class="line">      Start 17: t_strm_reassem_dup</span><br><span class="line"> 3/16 Test #17: t_strm_reassem_dup ...............   Passed    0.01 sec</span><br><span class="line">      Start 18: t_strm_reassem_holes</span><br><span class="line"> 4/16 Test #18: t_strm_reassem_holes .............   Passed    0.00 sec</span><br><span class="line">      Start 19: t_strm_reassem_many</span><br><span class="line"> 5/16 Test #19: t_strm_reassem_many ..............   Passed    0.11 sec</span><br><span class="line">      Start 20: t_strm_reassem_overlapping</span><br><span class="line"> 6/16 Test #20: t_strm_reassem_overlapping .......   Passed    0.00 sec</span><br><span class="line">      Start 21: t_strm_reassem_win</span><br><span class="line"> 7/16 Test #21: t_strm_reassem_win ...............   Passed    0.12 sec</span><br><span class="line">      Start 22: t_byte_stream_construction</span><br><span class="line"> 8/16 Test #22: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">      Start 23: t_byte_stream_one_write</span><br><span class="line"> 9/16 Test #23: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">      Start 24: t_byte_stream_two_writes</span><br><span class="line">10/16 Test #24: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">      Start 25: t_byte_stream_capacity</span><br><span class="line">11/16 Test #25: t_byte_stream_capacity ...........   Passed    0.00 sec</span><br><span class="line">      Start 26: t_byte_stream_many_writes</span><br><span class="line">12/16 Test #26: t_byte_stream_many_writes ........   Passed    0.01 sec</span><br><span class="line">      Start 27: t_webget</span><br><span class="line">13/16 Test #27: t_webget .........................   Passed    0.47 sec</span><br><span class="line">      Start 47: t_address_dt</span><br><span class="line">14/16 Test #47: t_address_dt .....................   Passed    0.01 sec</span><br><span class="line">      Start 48: t_parser_dt</span><br><span class="line">15/16 Test #48: t_parser_dt ......................   Passed    0.00 sec</span><br><span class="line">      Start 49: t_socket_dt</span><br><span class="line">16/16 Test #49: t_socket_dt ......................   Passed    0.01 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 16</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-1-stitching-substrings-into-a-byte-stream&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-1-stitching-substrings-into-a-byte-stream&quot;&gt;#&lt;</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144 Lab Checkpoint 0:networking warmup</title>
    <link href="https://flowerhai.github.io/2023/05/06/cs144/cs144lab0/"/>
    <id>https://flowerhai.github.io/2023/05/06/cs144/cs144lab0/</id>
    <published>2023-05-06T15:20:47.000Z</published>
    <updated>2023-05-06T15:22:12.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144-lab-checkpoint-0-networking-warmup"><a class="markdownIt-Anchor" href="#cs144-lab-checkpoint-0-networking-warmup">#</a> CS144 Lab Checkpoint 0: networking warmup</h1><p>visit  <a href="http://cs144.keithw.org/hello">http://cs144.keithw.org/hello</a></p><p>the result is Hello, CS144!</p><h4 id="on-ecs"><a class="markdownIt-Anchor" href="#on-ecs">#</a> on ECS</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet cs144.keithw.org http</span><br><span class="line"></span><br><span class="line">Trying 104.196.238.229...</span><br><span class="line">Connected to cs144.keithw.org.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /hello HTTP/1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="listening-and-connecting"><a class="markdownIt-Anchor" href="#listening-and-connecting">#</a> Listening and connecting</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netcat -v -l -p 9090</span><br><span class="line">telnet localhost 9090</span><br></pre></td></tr></table></figure><h3 id="writing-a-network-program-using-an-os-stream-socket"><a class="markdownIt-Anchor" href="#writing-a-network-program-using-an-os-stream-socket">#</a> Writing a network program using an OS stream socket</h3><p>我真蠢，真的，配了一天环境。</p><h4 id="writing-webget"><a class="markdownIt-Anchor" href="#writing-webget">#</a> Writing webget</h4><p>这个还是比较简单的，轻松就可以拿下</p><p>是让我们实现 get_url 这个函数，就是向指定地址发送一个 http 请求，然后做出响应即可。</p><p>注意讲义的要求就可以完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line">    TCPSocket socket;</span><br><span class="line">    socket.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    socket.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span>+path+<span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span>+host+<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    socket.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    <span class="keyword">while</span>(!socket.<span class="built_in">eof</span>())&#123;</span><br><span class="line">        cout&lt;&lt;socket.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    socket.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 06 May 2023 03:25:15 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT</span><br><span class="line">ETag: &quot;e-57ce93446cb64&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 14</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Hello, CS144!</span><br></pre></td></tr></table></figure><p>运行测试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 27: t_webget</span><br><span class="line">1/1 Test #27: t_webget .........................   Passed    0.54 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 1</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.55 sec</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target check_webget</span></span><br></pre></td></tr></table></figure><h4 id="an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#an-in-memory-reliable-byte-stream">#</a> An in-memory reliable byte stream</h4><p>这个也还行，就是中间修改完一直忘记重新 make 了，一直 66.7%, 不知道脑子在抽风什么。</p><p>我这个人 remake 得了</p><p>对 ByteStream 定义如下私有变量</p><p>缓冲区就选 deque，因为这是双端的，实验其实要求就是一端读，一端写，正好 deque 符合啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; buffer= &#123;&#125;;<span class="comment">//缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> Capacity_ ;<span class="comment">//容量</span></span><br><span class="line">    <span class="type">size_t</span> Read_Cnt_ = <span class="number">0</span>;<span class="comment">//读计数</span></span><br><span class="line">    <span class="type">size_t</span> Write_Cnt_ = <span class="number">0</span>;<span class="comment">//写计数</span></span><br><span class="line">    <span class="type">bool</span> Input_End_flag_= <span class="literal">false</span>;<span class="comment">//输入终止标识</span></span><br><span class="line">    <span class="type">bool</span> _error = <span class="literal">false</span>;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br></pre></td></tr></table></figure><p>然后就是写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(data);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">min</span>(data.<span class="built_in">size</span>(), Capacity_ - buffer.<span class="built_in">size</span>());</span><br><span class="line">    Write_Cnt_ += len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        buffer.<span class="built_in">emplace_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的一看便知，lab0 还是蛮 easy 的，只要把环境调试好，别搞太多幺蛾子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(len);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">min</span>(len, buffer.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(buffer.<span class="built_in">begin</span>(), buffer.<span class="built_in">begin</span>() + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">min</span>(len, buffer.<span class="built_in">size</span>());</span><br><span class="line">    Read_Cnt_ += length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i ++) buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Input_End_flag_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Input_End_flag_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; <span class="built_in">input_ended</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Write_Cnt_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Read_Cnt_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Capacity_ - <span class="built_in">buffer_size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 22: t_byte_stream_construction</span><br><span class="line">1/9 Test #22: t_byte_stream_construction .......   Passed    0.00 sec</span><br><span class="line">    Start 23: t_byte_stream_one_write</span><br><span class="line">2/9 Test #23: t_byte_stream_one_write ..........   Passed    0.00 sec</span><br><span class="line">    Start 24: t_byte_stream_two_writes</span><br><span class="line">3/9 Test #24: t_byte_stream_two_writes .........   Passed    0.00 sec</span><br><span class="line">    Start 25: t_byte_stream_capacity</span><br><span class="line">4/9 Test #25: t_byte_stream_capacity ...........   Passed    0.00 sec</span><br><span class="line">    Start 26: t_byte_stream_many_writes</span><br><span class="line">5/9 Test #26: t_byte_stream_many_writes ........   Passed    0.01 sec</span><br><span class="line">    Start 27: t_webget</span><br><span class="line">6/9 Test #27: t_webget .........................   Passed    0.89 sec</span><br><span class="line">    Start 47: t_address_dt</span><br><span class="line">7/9 Test #47: t_address_dt .....................   Passed    0.01 sec</span><br><span class="line">    Start 48: t_parser_dt</span><br><span class="line">8/9 Test #48: t_parser_dt ......................   Passed    0.01 sec</span><br><span class="line">    Start 49: t_socket_dt</span><br><span class="line">9/9 Test #49: t_socket_dt ......................   Passed    0.01 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 9</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.95 sec</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target check_lab0</span></span><br></pre></td></tr></table></figure><p>lab0 还是比较 easy，只要把环境配置好，然后注意下 Git 以及 Cmake。</p><p>其余问题不大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144-lab-checkpoint-0-networking-warmup&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144-lab-checkpoint-0-networking-warmup&quot;&gt;#&lt;/a&gt; CS144 </summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>刷题day20</title>
    <link href="https://flowerhai.github.io/2023/05/06/shuati/day20/"/>
    <id>https://flowerhai.github.io/2023/05/06/shuati/day20/</id>
    <published>2023-05-06T13:20:38.000Z</published>
    <updated>2023-05-06T13:20:59.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="131-分割回文串"><a class="markdownIt-Anchor" href="#131-分割回文串">#</a> <a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h4><p>给你一个字符串  <code>s</code> ，请你将  <code>s</code>  分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回  <code>s</code>  所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; r;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d;i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ishuiwen</span>(s, d, i)) &#123;</span><br><span class="line">                string str = s.<span class="built_in">substr</span>(d, i-d+<span class="number">1</span>);</span><br><span class="line">                r.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ishuiwen</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="93-复原-ip-地址"><a class="markdownIt-Anchor" href="#93-复原-ip-地址">#</a> <a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于  <code>0</code>  到  <code>255</code>  之间组成，且不能含有前导  <code>0</code> ），整数之间用  <code>'.'</code>  分隔。</p><ul><li>例如： <code>&quot;0.1.2.201&quot;</code>  和 <code> &quot;192.168.1.1&quot;</code>  是 <strong>有效</strong> IP 地址，但是  <code>&quot;0.011.255.245&quot;</code> 、 <code>&quot;192.168.1.312&quot;</code>  和  <code>&quot;192.168@1.1&quot;</code>  是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串  <code>s</code>  ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在  <code>s</code>  中插入  <code>'.'</code>  来形成。你 <strong>不能</strong> 重新排序或删除  <code>s</code>  中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isrule</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; l != r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt;<span class="string">&#x27;0&#x27;</span> || s[i] &gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = n * <span class="number">10</span> + s[i] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> d, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s, d, s.<span class="built_in">size</span>()<span class="number">-1</span>)) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isrule</span>(s,d,i)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">&#x27;.&#x27;</span>); </span><br><span class="line">                p ++;</span><br><span class="line">                <span class="built_in">dfs</span>(s, i+<span class="number">2</span>, p);</span><br><span class="line">                p --;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> res; </span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集">#</a> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p>给你一个整数数组  <code>nums</code>  ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (d == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不在状态，困死惹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;131-分割回文串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#131-分割回文串&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/palindrome-partitioning/&quot;&gt;131.</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day19</title>
    <link href="https://flowerhai.github.io/2023/05/05/shuati/day19/"/>
    <id>https://flowerhai.github.io/2023/05/05/shuati/day19/</id>
    <published>2023-05-05T11:40:52.000Z</published>
    <updated>2023-05-05T11:41:16.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合">#</a> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数  <code>n</code>  和  <code>k</code> ，返回范围  <code>[1, n]</code>  中所有可能的  <code>k</code>  个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= n; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="216-组合总和-iii"><a class="markdownIt-Anchor" href="#216-组合总和-iii">#</a> <a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><p>找出所有相加之和为  <code>n</code>  的  <code>k</code>  个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k, <span class="type">int</span> tar, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == tar) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; tar) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= <span class="number">9</span>-(k-r.<span class="built_in">size</span>())+<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">dfs</span>(n, i+<span class="number">1</span>, k, tar, sum);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, k, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合">#</a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字  <code>2-9</code>  的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;string&gt; board = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//表示按到了键盘上的第几个键</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board[num].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(board[num][i]);  </span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, digits);  <span class="comment">//递归下一层</span></span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();      <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28-找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#28-找出字符串中第一个匹配项的下标">#</a> <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><p>给你两个字符串  <code>haystack</code>  和  <code>needle</code>  ，请你在  <code>haystack</code>  字符串中找出  <code>needle</code>  字符串的第一个匹配项的下标（下标从 0 开始）。如果  <code>needle</code>  不是  <code>haystack</code>  的一部分，则返回  <code>-1</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pipei</span><span class="params">(string haystack, string needle, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle[y] == haystack[x] &amp;&amp; y == needle.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> haystack[x] == needle[y] &amp;&amp; <span class="built_in">pipei</span>(haystack, needle, x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="built_in">size</span>() &lt; needle.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pipei</span>(haystack, needle, i, <span class="number">0</span>)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP 优化版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置哨兵</span></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//预处理next数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="459-重复的子字符串"><a class="markdownIt-Anchor" href="#459-重复的子字符串">#</a> <a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><p>给定一个非空的字符串  <code>s</code>  ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string&amp; query, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = query.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kmp</span>(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是 KMP，掌握不是很熟练，明日重点 KMP.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;77-组合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#77-组合&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/combinations/&quot;&gt;77. 组合&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给定两个</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://flowerhai.github.io/2023/05/04/c/"/>
    <id>https://flowerhai.github.io/2023/05/04/c/</id>
    <published>2023-05-04T13:57:46.000Z</published>
    <updated>2023-05-04T13:58:33.755Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内联函数和普通函数的区别"><a class="markdownIt-Anchor" href="#内联函数和普通函数的区别">#</a> 内联函数和普通函数的区别</h4><p>省去函数调用开销</p><h4 id="c为什么支持函数重载c语言不支持"><a class="markdownIt-Anchor" href="#c为什么支持函数重载c语言不支持">#</a> C++ 为什么支持函数重载，C 语言不支持</h4><p>C++ 产生函数符号的时候，是由函数名 + 参数列表类型组成</p><p>C 代码是由函数名来决定的</p><h4 id="函数重载需要注意什么"><a class="markdownIt-Anchor" href="#函数重载需要注意什么">#</a> 函数重载需要注意什么</h4><h4 id="c和c语言代码之间如何调用"><a class="markdownIt-Anchor" href="#c和c语言代码之间如何调用">#</a> C++ 和 C 语言代码之间如何调用</h4><p><strong>extern &quot;C&quot; 的主要作用就是为了能够正确实现 C<ins> 代码调用其他 C 语言代码。加上 extern &quot;C&quot; 后，会指示编译器这部分代码按 C 语言（而不是 C</ins>）的方式进行编译。由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</strong></p><p>这个功能十分有用处，因为在 C<ins> 出现以前，很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，** 为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C</ins> 中尽可能的支持 C，而 extern &quot;C&quot; 就是其中的一个策略。**</p><p><strong>这个功能主要用在下面的情况：</strong></p><ol><li><strong>C++ 代码调用 C 语言代码</strong></li><li><strong>在 C++ 的头文件中使用</strong></li><li><strong>在多个人协同开发时，可能有的人比较擅长 C 语言，而有的人擅长 C++，这样的情况下也会有用到</strong></li></ol><p>看一个简单的例子：</p><p>有 moduleA、moduleB 两个模块，B 调用 A 中的代码，其中 A 是用 C 语言实现的，而 B 是利用 C++ 实现的，下面给出一种实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//moduleA头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MODULE_A_H <span class="comment">//对于模块A来说，这个宏是为了防止头文件的重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_A_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleA实现文件moduleA.C //模块A的实现部分并没有改变</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB头文件</span></span><br><span class="line"><span class="meta">#idndef __MODULE_B_H <span class="comment">//很明显这一部分也是为了防止重复引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MODULE_B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">//而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件， extern &quot;C&quot;&#123; //因为cpp文件默认定义了该宏),则采用C语言方式进行编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">… <span class="comment">//其他代码</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//moduleB实现文件 moduleB.cpp //B模块的实现也没有改变，只是头文件的设计变化了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;moduleB.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充介绍：</p><p>由于 C、C<ins> 编译器对函数的编译处理是不完全相同的，尤其对于 C</ins> 来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。</p><p>例如函数<strong> void fun (int, int)，编译后的可能是_fun_int_int (不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而 C 语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun 这样的名字。</strong></p><p>看下面的一个面试题：为什么标准头文件都有类似的结构？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __INCvxWorksh <span class="comment">/*防止该头文件被重复引用*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INCvxWorksh</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus             <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*…*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*end of __INCvxWorksh*/</span></span></span><br></pre></td></tr></table></figure><p><strong>extern &quot;C&quot; 包含双重含义</strong>，从字面上可以知道，首先，被它修饰的目标是 &quot;extern&quot; 的；其次，被它修饰的目标代码是 &quot;C&quot; 的。</p><ul><li>被 extern &quot;C&quot; 限定的函数或变量是 extern 类型的</li></ul><p>extern 是 C/C++ 语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。</p><p><strong>记住</strong>，语句：<strong>extern int a; 仅仅是一个变量的声明，其并不是在定义变量 a，也并未为 a 分配空间。变量 a 在所有模块中作为一种全局变量只能被定义一次，否则会出错。</strong></p><p>通常来说 **，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字 extern 生命。** 例如，如果模块 B 要引用模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但并不会报错；它会在链接阶段从模块 A 编译生成的目标代码中找到该函数。</p><p><strong>extern 对应的关键字是 static，static 表明变量或者函数只能在本模块中使用，因此，被 static 修饰的变量或者函数不可能被 extern C 修饰。</strong></p><ul><li><strong>被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式进行编译和链接的：这点很重要！！！！</strong></li></ul><p>上面也提到过，由于 C<ins> 支持函数重载，而 C 语言不支持，因此函数被 C</ins> 编译后在<strong>符号库</strong>中的名字是与 C 语言不同的；C++ 编译后的函数需要加上参数的类型才能唯一标定重载后的函数，而加上 extern &quot;C&quot; 后，是为了向编译器指明这段代码按照 C 语言的方式进行编译</p><p>未加 extern &quot;C&quot; 声明时的链接方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//模块A头文件 moduleA.h</span><br><span class="line">#idndef _MODULE_A_H</span><br><span class="line">#define _MODULE_A_H</span><br><span class="line"> </span><br><span class="line">int foo(int x, int y);</span><br><span class="line">#endif　</span><br></pre></td></tr></table></figure><p>在模块 B 中调用该函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//模块B实现文件 moduleB.cpp</span><br><span class="line">#include&quot;moduleA.h&quot;</span><br><span class="line">foo(2,3);　</span><br></pre></td></tr></table></figure><p>实际上，<strong>在链接阶段，链接器会从模块 A 生成的目标文件 moduleA.obj 中找_foo_int_int 这样的符号，显然这是不可能找到的，因为 foo () 函数被编译成了_foo 的符号，因此会出现链接错误。</strong></p><p><strong>extern &quot;C&quot; 的使用要点总结</strong></p><p>1，可以是如下的单一语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; double sqrt(double);</span><br></pre></td></tr></table></figure><p>2，可以是复合语句，相当于复合语句中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">      double sqrt(double);</span><br><span class="line">      int min(int, int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，可以包含头文件，相当于头文件中的声明都加了 extern “C”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    ＃include &lt;cmath&gt;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure><ul><li>不可以将 extern “C” 添加在函数内部</li><li>如果函数有多个声明，可以都加 extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。</li><li>除 extern “C”, 还有 extern “FORTRAN” 等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内联函数和普通函数的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内联函数和普通函数的区别&quot;&gt;#&lt;/a&gt; 内联函数和普通函数的区别&lt;/h4&gt;
&lt;p&gt;省去函数调用开销&lt;/p&gt;
&lt;h4 id=&quot;c为什么支持函数重载c语言不支持&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="C++" scheme="https://flowerhai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>day18</title>
    <link href="https://flowerhai.github.io/2023/05/04/shuati/day18/"/>
    <id>https://flowerhai.github.io/2023/05/04/shuati/day18/</id>
    <published>2023-05-04T13:38:01.000Z</published>
    <updated>2023-05-04T13:38:22.182Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-38-字符串的排列"><a class="markdownIt-Anchor" href="#剑指-offer-38-字符串的排列">#</a> <a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><p>开个数组记录一下不重复，开一个哈希表避免结果里有重复元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; jud;</span><br><span class="line">    unordered_map &lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,  <span class="type">int</span> d, <span class="type">int</span> n, string r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == n &amp;&amp; m.<span class="built_in">count</span>(r) == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">            m[r] == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jud[i]) &#123;</span><br><span class="line">                r.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                jud[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s, d + <span class="number">1</span>, n, r);</span><br><span class="line">                r.<span class="built_in">pop_back</span>();</span><br><span class="line">                jud[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        jud.<span class="built_in">resize</span>(<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">        string r;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>(), r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-43-1~n-整数中-1-出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-43-1~n-整数中-1-出现的次数">#</a> <a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p>输入一个整数  <code>n</code>  ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。</p><p>例如，输入 12，1～12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mulk = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; n &gt;= mulk; ++k) &#123;</span><br><span class="line">            ans += (n / (mulk * <span class="number">10</span>)) * mulk + <span class="built_in">min</span>(<span class="built_in">max</span>(n % (mulk * <span class="number">10</span>) - mulk + <span class="number">1</span>, <span class="number">0LL</span>), mulk);</span><br><span class="line">            mulk *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="541-反转字符串-ii"><a class="markdownIt-Anchor" href="#541-反转字符串-ii">#</a> <a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串  <code>s</code>  和一个整数  <code>k</code> ，从字符串开头算起，每计数至  <code>2k</code>  个字符，就反转这  <code>2k</code>  字符中的前  <code>k</code>  个字符。</p><ul><li>如果剩余字符少于  <code>k</code>  个，则将剩余字符全部反转。</li><li>如果剩余字符小于  <code>2k</code>  但大于或等于  <code>k</code>  个，则反转前  <code>k</code>  个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; i += 2 * k) &#123;</span><br><span class="line">            reverse(s.begin() + i, s.begin() + min(i + k, n));</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-05-替换空格"><a class="markdownIt-Anchor" href="#剑指-offer-05-替换空格">#</a> <a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串  <code>s</code>  中的每个空格替换成 &quot;%20&quot;。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a class="markdownIt-Anchor" href="#151-反转字符串中的单词">#</a> <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><p>给你一个字符串  <code>s</code>  ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。 <code>s</code>  中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>** 注意：** 输入字符串  <code>s</code>  中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p>好几种写法，用了下双端队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span>) ++left;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">&#x27; &#x27;</span>) --right;</span><br><span class="line">        deque&lt;string&gt; d;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[left];</span><br><span class="line">            <span class="keyword">if</span> (word.<span class="built_in">size</span>() &amp;&amp; c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += c;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_front</span>(<span class="built_in">move</span>(word));</span><br><span class="line">        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans += d.<span class="built_in">front</span>();</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-38-字符串的排列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-38-字符串的排列&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/zi-fu-chuan-</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://flowerhai.github.io/2023/05/04/qmi/"/>
    <id>https://flowerhai.github.io/2023/05/04/qmi/</id>
    <published>2023-05-04T03:34:11.000Z</published>
    <updated>2023-05-04T03:34:31.463Z</updated>
    
    <content type="html"><![CDATA[<p>\875. 快速幂</p><p>给定 n  组 ai,bi,pi  ,  ,  ，对于每组数据，求出 abiimodpi    mod   的值。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含整数 n 。</p><p>接下来 n  行，每行包含三个整数 ai,bi,pi  ,  ,  。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>对于每组数据，输出一个结果，表示 abiimodpi    mod   的值。</p><p>每个结果占一行。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤n≤1000001≤ ≤100000,<br>1≤ai,bi,pi≤2×1091≤  , ≤2×109</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 2 5</span><br><span class="line">4 3 9</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>快速幂，类似于二进制优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * t % p;</span><br><span class="line">        t = (<span class="type">long</span> <span class="type">long</span>) t * t % p;</span><br><span class="line">        k &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">qmi</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;\875. 快速幂&lt;/p&gt;
&lt;p&gt;给定 n  组 ai,bi,pi  ,  ,  ，对于每组数据，求出 abiimodpi    mod   的值。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#输入格式&quot;&gt;#&lt;</summary>
      
    
    
    
    
    <category term="快速幂" scheme="https://flowerhai.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>刷题day17</title>
    <link href="https://flowerhai.github.io/2023/05/03/shuati/day17/"/>
    <id>https://flowerhai.github.io/2023/05/03/shuati/day17/</id>
    <published>2023-05-03T13:43:00.000Z</published>
    <updated>2023-05-03T13:43:46.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-60-n个骰子的点数"><a class="markdownIt-Anchor" href="#剑指-offer-60-n个骰子的点数">#</a> <a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n 个骰子的点数</a></h4><p>把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure><p>Dp，找到状态转移方程就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">70</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i ++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">6</span>*i; j &gt;= i; j --) &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> cur = <span class="number">1</span>; cur &lt;= <span class="number">6</span>; cur ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - cur &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] += dp[j-cur];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> all = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= <span class="number">6</span> * n; i ++) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(dp[i] * <span class="number">1.0</span> / all);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-63-股票的最大利润"><a class="markdownIt-Anchor" href="#剑指-offer-63-股票的最大利润">#</a> <a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p>一个维护最大值，一个维护最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i]-m);</span><br><span class="line">            m = <span class="built_in">min</span>(m, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-66-构建乘积数组"><a class="markdownIt-Anchor" href="#剑指-offer-66-构建乘积数组">#</a> <a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p>给定一个数组  <code>A[0,1,…,n-1]</code> ，请构建一个数组  <code>B[0,1,…,n-1]</code> ，其中  <code>B[i]</code>  的值是数组  <code>A</code>  中除了下标  <code>i</code>  以外的元素的积，即  <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code> 。不能使用除法。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><p>各开一个数组记录左右乘积</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            l[i] = l[i<span class="number">-1</span>]*a[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            r[i] = r[i+<span class="number">1</span>]*a[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            b[i] *= l[i];</span><br><span class="line">            b[i] *= r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#剑指-offer-46-把数字翻译成字符串">#</a> <a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><p>爬楼梯进阶版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num); </span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="type">int</span> t = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>)    </span><br><span class="line">                    f[i] += f[i - <span class="number">2</span>];     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#剑指-offer-45-把数组排成最小的数">#</a> <a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p>排序就行，自定义一下排序规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> n1, <span class="type">int</span> n2) &#123;</span><br><span class="line">            string s1 = <span class="built_in">to_string</span>(n1), s2 = <span class="built_in">to_string</span>(n2);</span><br><span class="line">            <span class="built_in">return</span> (s1 + s2) &lt; (s2 + s1);</span><br><span class="line">        &#125;);</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) ret += <span class="built_in">to_string</span>(e);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-44-数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#剑指-offer-44-数字序列中某一位的数字">#</a> <a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p>数字以 0123456789101112131415… 的格式序列化到一个字符序列中。在这个序列中，第 5 位（从下标 0 开始计数）是 5，第 13 位是 1，第 19 位是 4，等等。</p><p>请写一个函数，求任意第 n 位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; (<span class="type">long</span>) d * count) &#123;</span><br><span class="line">            n -= d * count;</span><br><span class="line">            d++;</span><br><span class="line">            count *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start = (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">10</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> num = start + index / d;</span><br><span class="line">        <span class="type">int</span> digitIndex = index % d;</span><br><span class="line">        <span class="type">int</span> digit = (num / (<span class="type">int</span>) (<span class="built_in">pow</span>(<span class="number">10</span>, d - digitIndex - <span class="number">1</span>))) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-60-n个骰子的点数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-60-n个骰子的点数&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/nge-tou-zi</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day16</title>
    <link href="https://flowerhai.github.io/2023/04/30/shuati/day16/"/>
    <id>https://flowerhai.github.io/2023/04/30/shuati/day16/</id>
    <published>2023-04-30T14:40:16.000Z</published>
    <updated>2023-04-30T14:41:30.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#剑指-offer-33-二叉搜索树的后序遍历序列">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回  <code>true</code> ，否则返回  <code>false</code> 。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>注意下二叉搜索树的性质即可快速求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p ++;</span><br><span class="line">        <span class="type">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, i, m - <span class="number">1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, j - <span class="number">1</span>) &amp;&amp; (p == j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的大小顺序排列是：左中右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#剑指-offer-48-最长不含重复字符的子字符串">#</a> <a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>动态规划</p><p>哈希表 + 动态规划</p><p>开一个哈希表存上次出现的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        mp[s[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> j = mp[s[i]];</span><br><span class="line">                <span class="keyword">if</span> (i-j &gt; f[i<span class="number">-1</span>]) f[i] = f[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i] = i-j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])==<span class="number">0</span>) &#123;</span><br><span class="line">                f[i] = f[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-56-i-数组中数字出现的次数"><a class="markdownIt-Anchor" href="#剑指-offer-56-i-数组中数字出现的次数">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组  <code>nums</code>  里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 O (n)，空间复杂度是 O (1)。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p>此题甚妙</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-33-二叉搜索树的后序遍历序列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-33-二叉搜索树的后序遍历序列&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法实现</title>
    <link href="https://flowerhai.github.io/2023/04/30/lru/"/>
    <id>https://flowerhai.github.io/2023/04/30/lru/</id>
    <published>2023-04-30T08:05:27.000Z</published>
    <updated>2023-04-30T08:05:55.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现lru算法"><a class="markdownIt-Anchor" href="#实现lru算法">#</a> 实现 LRU 算法</h3><p>LRU-least recently used - 最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</p><p>可以使用双向链表加哈希表</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现LRU缓存机制</span></span><br><span class="line"><span class="comment">//LRU-least recently used-最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_lru.<span class="built_in">count</span>(x)==<span class="number">0</span>) &#123; <span class="comment">//此事时没有这个key</span></span><br><span class="line">            <span class="keyword">if</span> (size_lru &lt; v) &#123;<span class="comment">//此时LRU未满</span></span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">                size_lru ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> front_node = node_lru.<span class="built_in">front</span>();</span><br><span class="line">                hash_lru.<span class="built_in">erase</span>(front_node);</span><br><span class="line">                node_lru.<span class="built_in">pop_front</span>();</span><br><span class="line">                node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                hash_lru.<span class="built_in">emplace</span>(x,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//存在这个</span></span><br><span class="line">            node_lru.<span class="built_in">remove</span>(x);</span><br><span class="line">            node_lru.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash_lru[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = node_lru.<span class="built_in">back</span>();</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k:node_lru) cout&lt;&lt;k&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LRU</span>(<span class="type">int</span> x,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">v</span>(x), <span class="built_in">size_lru</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash_lru;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; node_lru;</span><br><span class="line">    <span class="type">int</span> size_lru;<span class="comment">//当前节点数量</span></span><br><span class="line">    <span class="type">int</span> v;<span class="comment">//容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">0 </span><br><span class="line">3 </span><br><span class="line">0 </span><br><span class="line">4 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LRU* lru_cache = <span class="keyword">new</span> <span class="built_in">LRU</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">7</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">2</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">3</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line">lru_cache-&gt;<span class="built_in">put</span>(<span class="number">4</span>);</span><br><span class="line">lru_cache-&gt;<span class="built_in">get_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">7 0 </span><br><span class="line">0 1 </span><br><span class="line">1 2 </span><br><span class="line">2 0 </span><br><span class="line">0 3 </span><br><span class="line">3 0 </span><br><span class="line">0 4 </span><br></pre></td></tr></table></figure><p>7<br>7 0<br>7 0 1<br>0 1 2<br>1 2 0<br>2 0 3<br>2 3 0<br>3 0 4</p><p>没问题，表现良好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现lru算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现lru算法&quot;&gt;#&lt;/a&gt; 实现 LRU 算法&lt;/h3&gt;
&lt;p&gt;LRU-least recently used - 最近最少使用算法，是一种内存数据淘汰策略，使用常见是当内</summary>
      
    
    
    
    
    <category term="LRU算法实现" scheme="https://flowerhai.github.io/tags/LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
</feed>
