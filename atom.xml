<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚迷离</title>
  
  
  <link href="https://flowerhai.github.io/atom.xml" rel="self"/>
  
  <link href="https://flowerhai.github.io/"/>
  <updated>2023-04-27T09:26:08.696Z</updated>
  <id>https://flowerhai.github.io/</id>
  
  <author>
    <name>恍惚迷离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生产者消费者练习题</title>
    <link href="https://flowerhai.github.io/2023/04/27/con-pro/"/>
    <id>https://flowerhai.github.io/2023/04/27/con-pro/</id>
    <published>2023-04-27T09:25:40.000Z</published>
    <updated>2023-04-27T09:26:08.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者消费者练习题"><a class="markdownIt-Anchor" href="#生产者消费者练习题">#</a> 生产者消费者练习题</h3><p>线程 A 每隔 10~200ms 按顺序生成 1-100 的数字，放入队列中</p><p>三个线程 B,C,D 即时消费这些数据，线程 B 打印所有被 2 整除的数，线程 C 打印所有被 3 整除的数，线程 D 打印其他数。</p><p>且打印出来的数字得有序</p><p>刷到牛友分享的一道面试题，于是随手做一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line">std::mutex mutex_;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(i);</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0.2</span>);</span><br><span class="line">        i ++;</span><br><span class="line">        i %= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cv.notify_all();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者B线程函数，打印所有被2整除的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerB: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者C线程函数，打印所有被3整除的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerC: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者D线程函数，打印其他数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumerD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> x = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; x%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;consumerD: &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">            data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g++ pruduct_cumsor.cpp -o a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动生产者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">consumerB_thread</span><span class="params">(consumerB)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerC_thread</span><span class="params">(consumerC)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumerD_thread</span><span class="params">(consumerD)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerB_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerC_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumerD_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumerD: 1</span><br><span class="line">consumerB: 2</span><br><span class="line">consumerC: 3</span><br><span class="line">consumerB: 4</span><br><span class="line">consumerD: 5</span><br><span class="line">consumerC: 6</span><br><span class="line">consumerD: 7</span><br><span class="line">consumerB: 8</span><br><span class="line">consumerC: 9</span><br><span class="line">consumerB: 10</span><br><span class="line">consumerD: 11</span><br><span class="line">consumerB: 12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出没啥问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;生产者消费者练习题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#生产者消费者练习题&quot;&gt;#&lt;/a&gt; 生产者消费者练习题&lt;/h3&gt;
&lt;p&gt;线程 A 每隔 10~200ms 按顺序生成 1-100 的数字，放入队列中&lt;/p&gt;
&lt;p&gt;三个线程</summary>
      
    
    
    
    
    <category term="生产者消费者" scheme="https://flowerhai.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>刷题day13</title>
    <link href="https://flowerhai.github.io/2023/04/27/shuati/day13/"/>
    <id>https://flowerhai.github.io/2023/04/27/shuati/day13/</id>
    <published>2023-04-27T06:49:26.000Z</published>
    <updated>2023-04-27T06:49:53.649Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-20-表示数值的字符串"><a class="markdownIt-Anchor" href="#剑指-offer-20-表示数值的字符串">#</a> <a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个  <code>'e'</code>  或  <code>'E'</code>  ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（ <code>'+'</code>  或  <code>'-'</code> ）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点  <code>'.'</code></li><li>至少一位数字，后面跟着一个点  <code>'.'</code>  ，后面再跟着至少一位数字</li><li>一个点  <code>'.'</code>  ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（ <code>'+'</code>  或  <code>'-'</code> ）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>吐血，本来还想着是否有什么算法可以求解，解决直接来一个有限状态机，算了这种题，再次碰见类似的估计还是想不出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CharType</span> &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">CharType <span class="title">toCharType</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_SPACE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                STATE_INITIAL, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_INITIAL&#125;,</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_INT_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INT_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INTEGER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT_WITHOUT_INT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_FRACTION,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_EXP_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_NUMBER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_END, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        State st = STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            CharType typ = <span class="built_in">toCharType</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (transfer[st].<span class="built_in">find</span>(typ) == transfer[st].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st = transfer[st][typ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-offer-17-打印从1到最大的n位数"><a class="markdownIt-Anchor" href="#剑指-offer-17-打印从1到最大的n位数">#</a> <a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从 1 到最大的 n 位数</a></h4><p>输入数字  <code>n</code> ，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure><p>很简单的一道题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">            r *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; r; i ++) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-14-i-剪绳子"><a class="markdownIt-Anchor" href="#剑指-offer-14-i-剪绳子">#</a> <a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><p>给你一根长度为  <code>n</code>  的绳子，请把绳子剪成整数长度的  <code>m</code>  段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为  <code>k[0],k[1]...k[m-1]</code>  。请问  <code>k[0]*k[1]*...*k[m-1]</code>  可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><p>此题动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dp[3] = 2;</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">max</span>(<span class="number">0</span>, dp[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j*(i-j), j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-40-最小的k个数"><a class="markdownIt-Anchor" href="#剑指-offer-40-最小的k个数">#</a> <a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的 k 个数</a></h4><p>输入整数数组  <code>arr</code>  ，找出其中最小的  <code>k</code>  个数。例如，输入 4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>排序…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) res.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-55-ii-平衡二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-55-ii-平衡二叉树">#</a> <a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong></p><p>给定二叉树  <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回  <code>true</code>  。</p><p>对每个节点都判断一下是否满足，随后看一下子节点是否满足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="built_in">return</span> ((<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right))*(<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right)) &lt;= <span class="number">1</span>) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-27-二叉树的镜像"><a class="markdownIt-Anchor" href="#剑指-offer-27-二叉树的镜像">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p><code>   4  /  \ 2   7 / \  / \1  3 6  9</code> <br> 镜像输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4  /  \ 7   2 / \  / \9  6 3  1</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p>没什么好说的，直接翻转就完事了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="built_in">mirror</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">mirror</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">mirror</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-68-i-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#剑指-offer-68-i-二叉搜索树的最近公共祖先">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* ancestor = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-089-房屋偷盗"><a class="markdownIt-Anchor" href="#剑指-offer-ii-089-房屋偷盗">#</a> <a href="https://leetcode.cn/problems/Gu0c2T/">剑指 Offer II 089. 房屋偷盗</a></h4><p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组  <code>nums</code>  ，请计算 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        res[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="number">0</span>, res[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res[i] = <span class="built_in">max</span>(res[i<span class="number">-1</span>], res[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">            r = <span class="built_in">max</span>(r, res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-20-表示数值的字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-20-表示数值的字符串&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/biao-shi</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day12</title>
    <link href="https://flowerhai.github.io/2023/04/25/day12/"/>
    <id>https://flowerhai.github.io/2023/04/25/day12/</id>
    <published>2023-04-25T03:57:39.000Z</published>
    <updated>2023-04-25T03:58:14.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-57-和为s的两个数字"><a class="markdownIt-Anchor" href="#剑指-offer-57-和为s的两个数字">#</a> <a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为 s 的两个数字</a></h4><p>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (slow &lt; fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] &gt; target) fast --;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] &lt; target) slow ++;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] + nums[fast] == target) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[slow]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[fast]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-26-树的子结构"><a class="markdownIt-Anchor" href="#剑指-offer-26-树的子结构">#</a> <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构)</p><p>B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。</p><p>例如:<br> 给定的树 A:</p><p><code>   3  / \  4  5 / \ 1  2</code> <br> 给定的树 B：</p><p><code>  4  / 1</code> <br> 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>递归判断呗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">iszi</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!A ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iszi</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">iszi</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (A != nullptr &amp;&amp; !B) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (!A || A != <span class="literal">nullptr</span> &amp;&amp; !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">iszi</span>(A, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-57-ii-和为s的连续正数序列"><a class="markdownIt-Anchor" href="#剑指-offer-57-ii-和为s的连续正数序列">#</a> <a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为 s 的连续正数序列</a></h4><p>输入一个正整数  <code>target</code>  ，输出所有和为  <code>target</code>  的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; target; i ++) &#123;</span><br><span class="line">            cnt += i;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (cnt == target) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">                <span class="comment">//return true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; target) &#123;</span><br><span class="line">                <span class="comment">//return false;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; target; i ++) &#123;</span><br><span class="line">            <span class="built_in">get</span>(i, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上来直接暴力了一下，发现超时了</p><p>随后想如何优化，可以用滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">            rr += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) &gt; target) l ++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) &lt; target) r ++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_sum</span>(l,r) == target) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) re.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(re);</span><br><span class="line">                l ++;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-58-ii-左旋转字符串"><a class="markdownIt-Anchor" href="#剑指-offer-58-ii-左旋转字符串">#</a> <a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串 &quot;abcdefg&quot; 和数字 2，该函数将返回左旋转两位得到的结果 &quot;cdefgab&quot;。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p>没啥难度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        n %= len;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-32-i-从上到下打印二叉树"><a class="markdownIt-Anchor" href="#剑指-offer-32-i-从上到下打印二叉树">#</a> <a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br> 给定二叉树:  <code>[3,9,20,null,null,15,7]</code> ,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><p>层序遍历而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-04-二维数组中的查找"><a class="markdownIt-Anchor" href="#剑指-offer-04-二维数组中的查找">#</a> <a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target =  <code>5</code> ，返回  <code>true</code> 。</p><p>给定 target =  <code>20</code> ，返回  <code>false</code> 。</p><p>真是烧脑筋，想了又想，还是得结合这个图长得样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-57-和为s的两个数字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-57-和为s的两个数字&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/he-wei-s</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>实现线程安全的懒汉单例模式</title>
    <link href="https://flowerhai.github.io/2023/04/25/danli/"/>
    <id>https://flowerhai.github.io/2023/04/25/danli/</id>
    <published>2023-04-25T00:41:36.000Z</published>
    <updated>2023-04-25T00:42:43.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现线程安全的懒汉单例模式并定义一个函数获取单例地址"><a class="markdownIt-Anchor" href="#实现线程安全的懒汉单例模式并定义一个函数获取单例地址">#</a> 实现线程安全的懒汉单例模式并定义一个函数获取单例地址</h3><p>昨天面试居然没实现出来，痛定思痛，今天好好写一遍。</p><p>创建这个单例类需要使用静态变量，利用了静态变量的一些性质，静态变量在整个代码运行周期内只会定义一次。</p><p><strong>对于 static 静态局部变量的初始化，编译器会自动对它的初始化进行加锁和解锁控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single *<span class="title">get_single</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Single single_only;</span><br><span class="line">        <span class="keyword">return</span> &amp;single_only;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_dizhi</span><span class="params">(Single *a)</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;create victory&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Single *ah = Single::<span class="built_in">get_single</span>();</span><br><span class="line">    ah-&gt;<span class="built_in">get_dizhi</span>(ah);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(create_thread)</span></span>;</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create victory</span><br><span class="line">0x560ecd8d9152</span><br><span class="line">0x560ecd8d9152</span><br><span class="line">0x560ecd8d9152</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现线程安全的懒汉单例模式并定义一个函数获取单例地址&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现线程安全的懒汉单例模式并定义一个函数获取单例地址&quot;&gt;#&lt;/a&gt; 实现线程安全的懒汉单例模式并定义一个函数获取单例地址&lt;/h3&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="设计模式" scheme="https://flowerhai.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="线程安全的懒汉单例模式" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>某厂面试(被薄纱)</title>
    <link href="https://flowerhai.github.io/2023/04/24/mianshi/"/>
    <id>https://flowerhai.github.io/2023/04/24/mianshi/</id>
    <published>2023-04-24T12:39:39.000Z</published>
    <updated>2023-04-24T12:43:40.852Z</updated>
    
    <content type="html"><![CDATA[<p>怎么这样捏，太紧张了，很多东西都没想起来</p><p>自我介绍开场</p><h4 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C++</h4><h4 id="智能指针熟悉吗介绍下智能指针"><a class="markdownIt-Anchor" href="#智能指针熟悉吗介绍下智能指针">#</a> 智能指针熟悉吗，介绍下智能指针</h4><p>智能指针（Smart Pointer）是一种 C++ 中的类，它的主要作用是管理动态分配的内存资源，从而避免内存泄漏和野指针等常见的内存安全问题。</p><p>智能指针通过重载指针操作符，提供与原生指针类似的使用方式，但其具有以下几个重要的特点：</p><ol><li>自动内存管理：智能指针会在其生命周期结束时自动释放其所管理的内存资源，从而避免了内存泄漏的风险。</li><li>所有权转移：智能指针支持所有权转移，即可以将一个智能指针的所有权转移给另一个智能指针，从而避免了多个指针同时管理同一块内存的问题。</li><li>引用计数：智能指针通常会维护一个引用计数器，用于记录有多少个智能指针共享同一块内存。当引用计数器减为 0 时，智能指针会自动释放其所管理的内存资源。</li><li>类型安全：智能指针可以防止类型不匹配的错误，从而提高程序的稳定性和安全性。</li></ol><h4 id="智能指针是为了解决什么问题提出来的"><a class="markdownIt-Anchor" href="#智能指针是为了解决什么问题提出来的">#</a> 智能指针是为了解决什么问题提出来的</h4><h4 id="为什么会有unique_ptr"><a class="markdownIt-Anchor" href="#为什么会有unique_ptr">#</a> 为什么会有 unique_ptr</h4><p>unique_ptr 是一种独占式智能指针，它的主要特点是只能有一个指针拥有它所管理的内存资源。unique_ptr 的出现主要是为了解决动态内存分配和释放过程中的一些常见问题，具有以下几个优点：</p><ol><li>防止内存泄漏：unique_ptr 能够确保在其生命周期结束时自动释放所管理的内存资源，从而避免了内存泄漏的风险。</li><li>防止多个指针同时访问同一块内存：由于 unique_ptr 是独占式的，即只能有一个指针拥有它所管理的内存资源，因此可以有效避免多个指针同时访问同一块内存的问题。</li><li>支持移动语义：unique_ptr 支持移动语义，即可以将其所有权转移给另一个 unique_ptr 对象，从而避免了显式内存管理过程中的复制和赋值问题。</li><li>更好的性能：unique_ptr 相比原生指针可以更好地支持现代 C++ 的一些高级特性，例如使用 RAII（Resource Acquisition Is Initialization）技术和模板元编程等。</li></ol><p>总之，unique_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以有效避免内存泄漏和野指针等常见问题。在编写 C</ins> 程序时，使用 unique_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="为什么会有shared_ptr"><a class="markdownIt-Anchor" href="#为什么会有shared_ptr">#</a> 为什么会有 shared_ptr</h4><p>shared_ptr 是一种共享式智能指针，它可以实现多个指针共享同一块内存资源，具有以下优点：</p><ol><li>引用计数机制：shared_ptr 会维护一个引用计数器，用于记录有多少个 shared_ptr 共享同一块内存。当引用计数器减为 0 时，shared_ptr 会自动释放其所管理的内存资源，从而避免了内存泄漏的风险。</li><li>所有权转移：shared_ptr 支持所有权转移，即可以将一个 shared_ptr 的所有权转移给另一个 shared_ptr，从而避免了多个指针同时管理同一块内存的问题。</li><li>方便使用：shared_ptr 与原生指针类似，可以使用普通的指针操作符和普通的函数调用方式，非常方便易用。</li><li>高效性能：shared_ptr 采用的是 “写时复制”（copy-on-write）机制，即只有在多个 shared_ptr 共享同一块内存资源时才进行复制，从而提高了内存和性能的效率。</li><li>支持自定义删除器：shared_ptr 支持自定义删除器（deleter），可以通过自定义删除器来控制内存资源的释放方式，增加了灵活性和可扩展性。</li></ol><p>总之，shared_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以实现多个指针共享同一块内存资源，并且能够自动管理内存资源，避免了内存泄漏和野指针等常见问题。在编写 C</ins> 程序时，使用 shared_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="为什么会有weak_ptr"><a class="markdownIt-Anchor" href="#为什么会有weak_ptr">#</a> 为什么会有 weak_ptr</h4><p>weak_ptr 是一种弱引用智能指针，它用于解决 shared_ptr 的循环引用问题。当两个或多个对象通过 shared_ptr 相互引用时，可能会形成一个环形引用，从而导致内存泄漏的问题。为了解决这个问题，C++11 引入了 weak_ptr，它具有以下优点：</p><ol><li>弱引用：weak_ptr 只是对所管理的对象的一个弱引用，它不会增加引用计数，也不会影响对象的生命周期。因此，当 shared_ptr 对象释放了它所管理的内存资源时，weak_ptr 并不会导致内存泄漏。</li><li>防止循环引用：当两个或多个对象通过 shared_ptr 相互引用时，可以将其中的某些指针替换为 weak_ptr，从而避免形成循环引用，减少内存泄漏的风险。</li><li>空指针检查：通过 lock () 函数可以检查所管理的对象是否存在，如果对象已经被释放，则返回一个空的 shared_ptr，从而避免了使用已经释放的内存资源的问题。</li></ol><p>总之，weak_ptr 是 C<ins> 中一种非常有用的内存管理工具，它可以有效避免 shared_ptr 的循环引用问题，并且能够检查所管理的对象是否存在，避免了使用已经释放的内存资源的问题。在编写 C</ins> 程序时，使用 weak_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量，值得开发人员深入了解和应用。</p><h4 id="智能指针底层是如何实现的"><a class="markdownIt-Anchor" href="#智能指针底层是如何实现的">#</a> 智能指针底层是如何实现的</h4><h4 id="除了计数还有其他的什么解决方法吗"><a class="markdownIt-Anchor" href="#除了计数还有其他的什么解决方法吗">#</a> 除了计数，还有其他的什么解决方法吗</h4><p>除了引用计数，还有其他一些方法可以解决循环引用的问题，例如：</p><ol><li>弱回调：可以使用回调函数来避免循环引用。当对象之间需要相互引用时，可以将其中一个对象作为回调函数的参数传递给另一个对象，并在需要释放内存时，调用回调函数释放所管理的内存资源。这种方式可以避免引用计数的问题，但是需要手动管理回调函数的注册和调用，比较繁琐。</li><li>其他智能指针：除了 shared_ptr 和 weak_ptr，还有其他一些智能指针可以用于管理内存资源，例如 unique_ptr 和 auto_ptr。这些指针不支持循环引用，因此可以用于避免循环引用的问题。但是需要注意，使用 unique_ptr 和 auto_ptr 时需要确保对象之间不存在循环引用。</li><li>弱化对象之间的关系：可以通过重新设计对象之间的关系，将原本相互引用的关系弱化，从而避免循环引用的问题。例如，可以将对象之间的关系转化为单向依赖关系，或者使用事件机制来解耦对象之间的依赖关系。</li></ol><p>总之，除了引用计数之外，还有其他一些方法可以用于解决循环引用的问题。在设计和实现程序时，应该根据具体的需求和场景选择合适的方法，避免出现内存泄漏和野指针等问题。</p><h4 id="介绍下循环引用问题以及如何用weak_ptr解决循环引用问题的"><a class="markdownIt-Anchor" href="#介绍下循环引用问题以及如何用weak_ptr解决循环引用问题的">#</a> 介绍下循环引用问题，以及如何用 weak_ptr 解决循环引用问题的</h4><p>循环引用是指在两个或多个对象之间相互引用的情况下，可能会导致内存泄漏和野指针等问题。在 C++ 中，循环引用通常出现在使用 shared_ptr 管理内存资源的场景中。</p><p>当两个或多个对象通过 shared_ptr 相互引用时，每个 shared_ptr 都会增加所管理的对象的引用计数。如果其中一个对象被释放时，它所管理的内存资源可能并不会被释放，因为另一个对象仍然持有对它的引用，从而导致内存泄漏。此外，当所有对象都释放后，如果某个 shared_ptr 继续持有对已经释放的内存资源的引用，就会导致野指针问题。</p><p>为了解决循环引用问题，C++11 引入了 weak_ptr。weak_ptr 是一种弱引用智能指针，它不会增加引用计数，也不会影响对象的生命周期。当两个或多个对象通过 shared_ptr 相互引用时，可以将其中的某些指针替换为 weak_ptr，从而避免形成循环引用。当所有的 shared_ptr 对象释放了它们所管理的内存资源时，weak_ptr 并不会导致内存泄漏。此外，可以使用 lock () 函数来检查所管理的对象是否存在，从而避免了使用已经释放的内存资源的问题。</p><p>具体来说，使用 weak_ptr 解决循环引用问题的步骤如下：</p><ol><li>将其中的某些 shared_ptr 指针替换为 weak_ptr，避免形成循环引用。</li><li>在需要访问所管理的对象时，先使用 lock () 函数检查对象是否存在。如果对象已经被释放，则返回一个空的 shared_ptr；否则，返回一个新的 shared_ptr，可以安全地访问所管理的内存资源。</li></ol><p>总之，使用 weak_ptr 可以有效避免 shared_ptr 的循环引用问题，并且能够检查所管理的对象是否存在，避免了使用已经释放的内存资源的问题。在编写 C++ 程序时，使用 weak_ptr 可以提高程序的稳定性和安全性，减少手动内存管理的工作量。</p><h4 id="你说到了死锁为什么多个shared_ptr互相引用会发生死锁"><a class="markdownIt-Anchor" href="#你说到了死锁为什么多个shared_ptr互相引用会发生死锁">#</a> 你说到了死锁，为什么多个 shared_ptr 互相引用会发生死锁</h4><h4 id="什么是拷贝构造函数什么是赋值构造函数"><a class="markdownIt-Anchor" href="#什么是拷贝构造函数什么是赋值构造函数">#</a> 什么是拷贝构造函数，什么是赋值构造函数</h4><p>拷贝构造函数和赋值构造函数都是 C++ 中的特殊函数，用于创建新对象或将一个对象的值复制到另一个对象。</p><p>拷贝构造函数是一个特殊的构造函数，用于创建一个新对象，并将已有对象的值复制到新对象中。当用已有对象初始化一个新对象或者将一个对象作为参数传递给函数时，拷贝构造函数会被自动调用。拷贝构造函数的函数签名通常是类名 (const 类名 &amp; other)，其中 const 表示被复制的对象是只读的，&amp; 表示传递的是一个引用。</p><p>赋值构造函数是另一个特殊的函数，用于将一个对象的值复制到另一个已经存在的对象中。当使用一个对象为另一个对象赋值时，赋值构造函数会被自动调用。赋值构造函数的函数签名通常是类名 &amp; operator=(const 类名 &amp; other)，其中 = 表示赋值操作，&amp; 表示返回的是一个引用。</p><p>需要注意的是，拷贝构造函数和赋值构造函数是不同的函数，其函数签名也不同。拷贝构造函数创建新对象时，需要分配新的内存；而赋值构造函数则是将一个已有对象的值复制到另一个已经存在的对象中，不需要分配新的内存。</p><p>在 C++ 中，如果没有定义拷贝构造函数和赋值构造函数，编译器会自动生成默认的拷贝构造函数和赋值构造函数。默认的拷贝构造函数和赋值构造函数只是将每个成员变量的值从一个对象复制到另一个对象，因此如果类中存在指针等需要手动管理的资源，就需要自定义拷贝构造函数和赋值构造函数来确保正确的资源管理。</p><h4 id="这两个是为了解决一个什么问题"><a class="markdownIt-Anchor" href="#这两个是为了解决一个什么问题">#</a> 这两个是为了解决一个什么问题</h4><h4 id="拷贝构造函数和赋值构造函数时干什么用的可以告诉我你都知道什么吗"><a class="markdownIt-Anchor" href="#拷贝构造函数和赋值构造函数时干什么用的可以告诉我你都知道什么吗">#</a> 拷贝构造函数和赋值构造函数时干什么用的，可以告诉我你都知道什么吗</h4><h4 id="什么是浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#什么是浅拷贝和深拷贝">#</a> 什么是浅拷贝和深拷贝</h4><h4 id="newdelete-mallocfree是干什么用的具体有什么区别"><a class="markdownIt-Anchor" href="#newdelete-mallocfree是干什么用的具体有什么区别">#</a> new/delete malloc/free 是干什么用的，具体有什么区别</h4><p>new/delete 和 malloc/free 都是用于动态内存管理的 C++ 和 C 语言函数，用于在程序运行时分配和释放内存空间。</p><p>new/delete 是 C++ 语言中的运算符，用于动态地分配和释放内存空间，并在内存中构造和销毁对象。new 返回一个指向已分配内存的指针，而 delete 则释放已分配的内存空间。</p><p>malloc/free 是 C 语言中的函数，用于动态地分配和释放内存空间，但它们并不会自动构造和销毁对象。malloc 返回一个指向已分配内存的指针，而 free 则释放已分配的内存空间。</p><p>虽然 new/delete 和 malloc/free 都用于动态内存管理，但它们之间存在一些重要的区别：</p><ol><li>语法：new/delete 是 C++ 运算符，malloc/free 是 C 语言函数，因此它们的语法不同。</li><li>类型安全：new/delete 是类型安全的，可以自动调用对象的构造函数和析构函数，确保了类型安全。而 malloc/free 并不具备类型安全的特性，需要手动调用构造函数和析构函数。</li><li>内存分配方式：new/delete 分配的内存是从自由存储区（heap）中分配的，而 malloc/free 分配的内存是从堆（heap）中分配的。</li><li>内存分配大小：new/delete 在分配内存时，需要指定对象的类型，因此可以自动计算对象的大小。而 malloc/free 需要手动计算分配内存的大小，因此可能会产生错误。</li><li>重载：new/delete 可以被重载，可以自定义内存分配和释放方式。而 malloc/free 是 C 语言函数，不能被重载。</li></ol><p>综上所述，虽然 new/delete 和 malloc/free 都是用于动态内存管理，但它们的语法、类型安全、内存分配方式、内存分配大小和重载等方面都存在一定的区别。在 C++ 中，建议使用 new/delete 来管理动态内存，以确保类型安全和内存分配的正确性。</p><h4 id="如果new的一片内存用free会发生什么"><a class="markdownIt-Anchor" href="#如果new的一片内存用free会发生什么">#</a> 如果 new 的一片内存用 free，会发生什么</h4><p>如果使用 free 释放由 new 分配的内存，会导致未定义的行为。因为 new 和 free 是不同的内存分配函数，它们使用不同的内存管理机制。new 操作符在分配内存时，会调用 C++ 运行库的 operator new () 函数，它使用了动态分配内存的底层机制，例如 malloc 等。而 free 函数只能释放由 malloc 等函数分配的内存。所以，如果使用 free 函数释放由 new 分配的内存，会导致未定义的行为，可能会发生内存泄漏或者其他的错误。</p><p>在 C++ 中，建议使用 delete 操作符来释放由 new 分配的内存，而不是使用 free 函数。使用 delete 操作符可以确保内存分配和释放的正确性，同时也可以调用对象的析构函数来进行资源释放。</p><h4 id="我们知道如果new一个数组的话会是new-a这种格式为什么delete的也要delete-a"><a class="markdownIt-Anchor" href="#我们知道如果new一个数组的话会是new-a这种格式为什么delete的也要delete-a">#</a> 我们知道如果 new 一个数组的话会是 new a [] 这种格式，为什么 delete 的也要 delete a []</h4><h4 id="new-和-malloc分配的内存空间都在哪个地方"><a class="markdownIt-Anchor" href="#new-和-malloc分配的内存空间都在哪个地方">#</a> new 和 malloc 分配的内存空间都在哪个地方</h4><p>在 C++ 中， <code>new</code>  和  <code>malloc</code>  都可以用来动态分配内存。但是它们在分配内存的方式和位置上有一些不同。</p><p><code>new</code>  运算符分配内存的位置在 C++ 的自由存储区 (heap) 上，它会在运行时在堆上分配一段连续的内存区域来存储数据，并返回这段内存的首地址。使用  <code>new</code>  分配内存时，系统会自动调用构造函数来对分配的内存进行初始化。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int *ptr = new int;  // 分配一个整数的内存空间，并初始化为0</span><br></pre></td></tr></table></figure><p><code>malloc</code>  函数分配内存的位置在 C 的堆 (heap) 上，它也会在运行时在堆上分配一段连续的内存区域来存储数据，并返回这段内存的首地址。与  <code>new</code>  不同的是， <code>malloc</code>  只是简单地分配了一块内存空间，并不会自动调用构造函数来初始化这块内存。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int *ptr = (int*)malloc(sizeof(int));  // 分配一个整数的内存空间，但是不会初始化</span><br></pre></td></tr></table></figure><p>需要注意的是，使用  <code>malloc</code>  分配内存时，必须使用  <code>free</code>  函数来释放内存。而使用  <code>new</code>  分配内存时，则需要使用  <code>delete</code>  运算符来释放内存。</p><p>总之， <code>new</code>  和  <code>malloc</code>  的不同之处在于它们所在的存储区域不同、分配内存的方式和返回内存地址的类型不同，同时也涉及到了对象构造和析构等语义的差异。因此，在使用时需要根据实际需求来选择适合的内存分配方式。</p><h4 id="分配一段内存都有什么方法说说你都知道哪些"><a class="markdownIt-Anchor" href="#分配一段内存都有什么方法说说你都知道哪些">#</a> 分配一段内存都有什么方法，说说你都知道哪些</h4><p>在 C++ 中，常用的动态分配内存的方法主要有以下几种：</p><ol><li><code>new</code>  运算符：使用  <code>new</code>  运算符可以动态地分配指定类型的内存空间。例如，可以使用  <code>new int</code>  来分配一个  <code>int</code>  类型的内存空间，或者使用  <code>new int[10]</code>  来分配一个包含 10 个  <code>int</code>  类型元素的数组。</li><li><code>malloc</code>  函数：使用  <code>malloc</code>  函数可以在堆上动态地分配指定大小的内存空间，它的函数原型为  <code>void *malloc(size_t size)</code> 。需要注意的是，使用  <code>malloc</code>  分配内存时，必须使用  <code>free</code>  函数来释放内存。</li><li><code>calloc</code>  函数：使用  <code>calloc</code>  函数可以在堆上动态地分配指定数量、指定大小的内存空间，并且会将分配的内存空间清零，它的函数原型为  <code>void *calloc(size_t nmemb, size_t size)</code> 。</li><li><code>realloc</code>  函数：使用  <code>realloc</code>  函数可以重新分配之前由  <code>malloc</code>  或  <code>calloc</code>  分配的内存空间，它的函数原型为  <code>void *realloc(void *ptr, size_t size)</code> 。需要注意的是，使用  <code>realloc</code>  函数时，必须将之前分配的内存空间的地址作为第一个参数传递给该函数，而且不能用于  <code>new</code>  分配的内存空间。</li></ol><p>除了上述方法，C++ 标准库中还提供了一些内存分配函数，例如  <code>std::malloc</code> 、 <code>std::calloc</code> 、 <code>std::realloc</code> 、 <code>std::aligned_alloc</code> 、 <code>std::new_handler</code>  等，这些函数可以方便地进行内存分配、重新分配、对齐等操作。</p><h4 id="知道static吗详细介绍下static的功能"><a class="markdownIt-Anchor" href="#知道static吗详细介绍下static的功能">#</a> 知道 static 吗，详细介绍下 static 的功能</h4><p>在 C++ 中， <code>static</code>  关键字可以用于以下三个方面：</p><ol><li>静态变量：使用  <code>static</code>  关键字声明的变量被称为静态变量，它们存储在静态存储区中，并且只会被初始化一次。在函数内部声明的静态变量在函数执行完毕后不会被销毁，而是会一直存在于程序的生命周期中。在类中声明的静态变量被称为类变量或静态成员变量，它们被所有类对象共享，并且不依赖于任何类对象而存在。</li><li>静态函数：使用  <code>static</code>  关键字声明的函数被称为静态函数或类函数，它们与类的静态成员变量类似，不依赖于任何类对象而存在。因此，静态函数只能访问类的静态成员变量或其他静态函数，不能访问类的非静态成员变量或成员函数。</li><li>静态类：使用  <code>static</code>  关键字声明的类被称为静态类，它们只包含静态成员变量和静态成员函数，不能创建任何对象。静态类通常用于实现一些辅助函数或工具类，例如数学库、字符串库等。</li></ol><p>除了上述功能之外， <code>static</code>  关键字还可以用于限制变量和函数的作用域，使其仅在当前文件或代码块中可见。在这种情况下， <code>static</code>  关键字相当于将变量或函数的链接类型改为内部链接。这种用法可以用于隐藏实现细节，防止变量和函数被其他文件或代码块访问，从而增强程序的安全性和可维护性。</p><h4 id="知道const吗详细介绍下const的功能"><a class="markdownIt-Anchor" href="#知道const吗详细介绍下const的功能">#</a> 知道 const 吗，详细介绍下 const 的功能</h4><p>在 C++ 中， <code>const</code>  关键字用于修饰变量、函数和类成员函数等，其功能如下：</p><ol><li>常量变量：使用  <code>const</code>  关键字声明的变量称为常量变量，其值在程序运行过程中不可修改。常量变量可以在声明时进行初始化，也可以在构造函数中进行初始化。</li><li>常量函数：使用  <code>const</code>  关键字修饰的函数称为常量函数，其内部不能修改对象的状态或调用非常量成员函数。常量函数可以被常量对象和非常量对象调用，但在常量对象中只能调用常量成员函数。</li><li>常量类成员函数：使用  <code>const</code>  关键字修饰的类成员函数称为常量类成员函数，其作用与常量函数类似，但只能在类的成员函数中使用。常量类成员函数不能修改类的成员变量，但可以访问类的非常量成员函数。</li><li>常量对象：使用  <code>const</code>  关键字修饰的对象称为常量对象，其状态不能在程序运行过程中被修改。常量对象只能调用常量成员函数和常量类成员函数，不能调用非常量成员函数和非常量类成员函数。</li></ol><p>通过使用  <code>const</code>  关键字，可以增加程序的可读性、可靠性和安全性，减少代码中的错误和 bug。例如，常量变量可以防止在程序运行过程中意外修改变量的值，常量函数可以确保对象的状态不会被修改，常量类成员函数可以避免在类内部误用非常量成员函数等。</p><h4 id="关于c内存管理机制详细介绍一下"><a class="markdownIt-Anchor" href="#关于c内存管理机制详细介绍一下">#</a> 关于 C++ 内存管理机制，详细介绍一下</h4><h4 id="介绍下堆区和栈区他们有什么区别"><a class="markdownIt-Anchor" href="#介绍下堆区和栈区他们有什么区别">#</a> 介绍下堆区和栈区，他们有什么区别</h4><p>C++ 的内存管理机制主要包括两个方面：栈内存管理和堆内存管理。</p><ol><li>栈内存管理</li></ol><p>在 C++ 中，函数调用时会在栈内存中为函数创建一个新的栈帧，用于存储函数的局部变量、函数参数、返回地址和临时变量等。栈内存是由操作系统分配和管理的，因此其大小和位置是固定的。栈内存管理具有以下特点：</p><ul><li>自动分配和释放：栈内存的分配和释放是自动的，程序员不需要显式地调用函数进行内存管理。</li><li>后进先出：栈内存采用后进先出的方式进行管理，即最后进入栈的变量最先被释放。</li><li>快速访问：栈内存的访问速度非常快，因为栈内存是连续的、顺序存储的，可以直接通过栈指针进行访问。</li></ul><ol><li>堆内存管理</li></ol><p>堆内存是由程序员手动分配和释放的，其大小和位置不固定，可以动态调整。在 C++ 中，使用  <code>new</code>  运算符分配堆内存，使用  <code>delete</code>  运算符释放堆内存。堆内存管理具有以下特点：</p><ul><li>动态分配和释放：堆内存的分配和释放是由程序员手动控制的，需要使用  <code>new</code>  和  <code>delete</code>  运算符进行操作。</li><li>不连续存储：堆内存是不连续存储的，其分配和释放涉及到内存的分配和释放算法，比较复杂。</li><li>慢速访问：堆内存的访问速度比栈内存慢，因为堆内存是不连续存储的，访问需要通过指针进行间接访问。</li></ul><p>C++ 的内存管理机制是基于 RAII（Resource Acquisition Is Initialization）原则的，即资源获取即初始化。该原则要求程序员在使用资源（如堆内存、文件、锁等）时，通过对象的构造函数获取资源，在对象的析构函数中释放资源，从而避免资源泄漏和错误。例如，使用智能指针可以自动管理堆内存的分配和释放，避免手动控制  <code>new</code>  和  <code>delete</code>  运算符的问题。同时，C++ 标准库提供了多种容器和算法，可以更方便地管理内存和数据结构。</p><h4 id="你说到栈区比堆区快为什么栈快"><a class="markdownIt-Anchor" href="#你说到栈区比堆区快为什么栈快">#</a> 你说到栈区比堆区快，为什么栈快</h4><h4 id="你说到os对其做了许多优化os究竟做了什么优化为什么要这样优化呢"><a class="markdownIt-Anchor" href="#你说到os对其做了许多优化os究竟做了什么优化为什么要这样优化呢">#</a> 你说到 OS 对其做了许多优化，OS 究竟做了什么优化，为什么要这样优化呢</h4><h4 id="我们知道在递归层数太深的时候会发生栈溢出为什么会发生栈溢出呢"><a class="markdownIt-Anchor" href="#我们知道在递归层数太深的时候会发生栈溢出为什么会发生栈溢出呢">#</a> 我们知道在递归层数太深的时候会发生栈溢出，为什么会发生栈溢出呢</h4><p>栈溢出（stack overflow）是指在程序运行时，栈内存中的数据超出了栈的大小，导致无法继续正常执行程序的现象。</p><p>在函数调用时，函数的参数、局部变量、返回地址等信息都会被压入栈中，每次函数调用都会在栈上分配一段内存，称为栈帧（stack frame），当函数执行结束后，栈帧就被销毁，栈顶指针回到上一层调用函数的位置，继续执行后续的代码。</p><p>当递归层数太深时，栈空间被不断地分配和销毁，如果栈的空间不足以存储所有的栈帧，就会导致栈溢出。这通常是因为程序中使用了过多的递归调用，或者函数中分配了过多的局部变量或数组等占用了大量的栈空间。</p><p>另外，有些编译器还可以检测到递归的循环调用，从而避免栈溢出的问题。例如 GCC 编译器的 - O2 优化级别会启用尾递归优化，将递归调用转化为循环调用，从而减少栈帧的使用。</p><h4 id="你知道什么是压栈和入栈吗"><a class="markdownIt-Anchor" href="#你知道什么是压栈和入栈吗">#</a> 你知道什么是压栈和入栈吗</h4><p>在内存管理中，栈（stack）是一种线性的数据结构，具有先进后出（Last-In-First-Out，LIFO）的特点。栈通常用来存储临时变量、函数调用返回地址、函数参数以及一些其他的上下文信息。</p><p>压栈和入栈都是指将数据放入栈中的操作，但它们的含义略有不同：</p><ul><li>压栈（push）通常指将一个数据压入栈顶，即栈指针向下移动一个位置，指向新压入的数据。</li><li>入栈（push）通常指将一组数据按照某种顺序依次压入栈中，其中包括多个数据元素和可能的一些控制信息。这个操作通常用于函数调用时将参数和返回地址压入栈中。</li></ul><p>举个例子，假设我们有一个栈，其中已经有两个元素 10 和 20，栈指针指向第三个空位。此时，我们执行以下操作：</p><ul><li>压栈 30，即将数据 30 放入栈顶，栈指针指向第四个位置。</li><li>入栈函数调用信息，即将函数调用的参数和返回地址按照一定的顺序压入栈中，同时更新栈指针的位置。</li></ul><p>需要注意的是，栈的大小是有限的，当栈满了之后，就会发生栈溢出（stack overflow）的错误，这通常是因为递归调用过多或者占用了过多的栈空间导致的。因此，在编写程序时，需要谨慎使用栈，并保证栈空间的合理分配和管理。</p><h4 id="你知道什么是栈争吗详细解释下"><a class="markdownIt-Anchor" href="#你知道什么是栈争吗详细解释下">#</a> 你知道什么是栈争吗，详细解释下</h4><p>栈争（Stack Clash）是一种计算机安全漏洞，可以被黑客用来攻击目标系统并获取系统权限。该漏洞最初于 2017 年被发现，但其基本原理已经存在了很长时间。</p><p>栈争漏洞的基本原理是，当程序的堆栈空间与另一个内存区域（例如堆或共享库）发生冲突时，黑客可以利用这个漏洞来覆盖栈中的数据，从而控制程序的执行流程。具体来说，黑客会通过精心构造的输入数据来使程序在堆栈和其他内存区域之间跳转，从而实现代码注入和控制流劫持。</p><p>栈争漏洞通常发生在使用静态栈分配的程序中，这种程序在编译时会为每个线程分配固定大小的堆栈空间。黑客可以通过超出堆栈空间的边界来覆盖栈中的数据，从而实现攻击。</p><p>为了防止栈争漏洞，开发人员可以采用一些措施，例如：</p><ol><li>使用动态栈分配：动态栈分配可以使程序在运行时动态地分配堆栈空间，从而减少堆栈与其他内存区域发生冲突的可能性。</li><li>限制堆栈空间的大小：开发人员可以限制程序的堆栈空间大小，从而减少栈与其他内存区域发生冲突的可能性。</li><li>栈随机化：开发人员可以采用栈随机化技术来使每个线程的堆栈空间的地址随机化，从而使攻击者难以确定正确的地址。</li></ol><p>总之，栈争漏洞是一种常见的安全漏洞，可以通过采用适当的措施来减少其发生的可能性。</p><h4 id="什么变量分配在堆上什么变量分配在栈上"><a class="markdownIt-Anchor" href="#什么变量分配在堆上什么变量分配在栈上">#</a> 什么变量分配在堆上，什么变量分配在栈上</h4><p>在计算机编程中，内存被划分为栈（stack）和堆（heap），它们都用于存储变量。</p><p>栈（stack）：栈是一种线性数据结构，具有后进先出（LIFO）的特性。栈上的变量由编译器自动分配和释放内存。当程序执行一个函数时，该函数的参数、局部变量和返回地址被压入栈中。当函数返回时，这些变量被弹出栈。因此，栈上的变量的生命周期是由函数的调用和返回决定的。栈的大小通常是固定的，由操作系统或编译器定义。</p><p>堆（heap）：堆是一种非线性数据结构，由程序员动态分配和释放内存。堆上的变量可以在程序的任何位置被访问，因此它们的生命周期可以由程序员控制。在堆上分配内存需要显式地调用分配函数（如 malloc () 或 new），在不需要变量时，需要显式地释放它们（如 free () 或 delete）。</p><p>一般来说，较小的变量（如基本数据类型）通常分配在栈上，而较大的变量（如数组、对象等）通常分配在堆上。但是，这也取决于编译器和操作系统的实现方式，所以并非所有的编程语言和平台都遵循这种规则。</p><h4 id="关于操作系统是如何实现堆和栈的堆和栈究竟是一个怎么样的结构"><a class="markdownIt-Anchor" href="#关于操作系统是如何实现堆和栈的堆和栈究竟是一个怎么样的结构">#</a> 关于操作系统是如何实现堆和栈的，堆和栈究竟是一个怎么样的结构</h4><h4 id="c中一个很重要的特性是多态关于c中多态是如何实现的呢"><a class="markdownIt-Anchor" href="#c中一个很重要的特性是多态关于c中多态是如何实现的呢">#</a> C<ins> 中一个很重要的特性是多态，关于 C</ins> 中多态是如何实现的呢？</h4><h4 id="讲到了虚函数然后问虚函数是如何实现的呢"><a class="markdownIt-Anchor" href="#讲到了虚函数然后问虚函数是如何实现的呢">#</a> 讲到了虚函数，然后问虚函数是如何实现的呢？</h4><p>在 C<ins> 中，多态是通过虚函数（virtual function）实现的。虚函数是在基类中声明的一种特殊的成员函数，它可以被派生类重写以实现特定的行为。通过虚函数，C</ins> 能够实现运行时多态性（runtime polymorphism）。</p><p>当一个类中包含至少一个虚函数时，编译器会为该类生成一个虚函数表（virtual table，也称为 vtable），用于存储类的虚函数地址。当一个对象被创建时，它会包含一个指向虚函数表的指针。当调用一个虚函数时，C++ 会根据该对象的指针找到虚函数表，并调用相应的函数。</p><p>通过使用虚函数，C++ 可以实现动态绑定（dynamic binding）或晚绑定（late binding）的特性，即在运行时确定调用哪个函数。这样可以实现在运行时根据对象的实际类型调用相应的函数，而不是根据变量类型调用函数，从而实现多态性。</p><p>下面是一个使用虚函数实现多态的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;This is an animal sound.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Meow!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Woof!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal *ptr;</span><br><span class="line">    Cat cat;</span><br><span class="line">    Dog dog;</span><br><span class="line">    ptr = &amp;cat;</span><br><span class="line">    ptr-&gt;makeSound(); // 输出：Meow!</span><br><span class="line">    ptr = &amp;dog;</span><br><span class="line">    ptr-&gt;makeSound(); // 输出：Woof!</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Animal 类包含一个虚函数 makeSound ()，Cat 类和 Dog 类都重写了这个函数。在 main 函数中，定义了一个 Animal 类型的指针 ptr，并分别让它指向 Cat 对象和 Dog 对象。当调用 ptr 的 makeSound () 函数时，C++ 会根据 ptr 指向的对象的实际类型调用相应的函数，输出相应的结果。这就是多态的表现。</p><h4 id="c如何找到虚表的如何确定每一个子类对应的虚表就是这个虚表呢"><a class="markdownIt-Anchor" href="#c如何找到虚表的如何确定每一个子类对应的虚表就是这个虚表呢">#</a> C++ 如何找到虚表的，如何确定每一个子类对应的虚表就是这个虚表呢</h4><p>在 C++ 中，每个包含虚函数的类都会有一个虚函数表（vtable），这个表中存储了虚函数的地址。每个对象都有一个指向其对应类的虚函数表的指针（通常被称为虚表指针或 vptr），通过这个指针可以动态地调用虚函数。</p><p>在编译时，编译器为每个包含虚函数的类生成一个虚表，虚表中存储了该类中所有虚函数的地址。当派生类继承了基类的虚函数时，派生类也会包含基类的虚表，而且在该虚表的末尾添加自己的虚函数地址。这样，派生类就可以重写基类的虚函数，并添加自己的虚函数。</p><p>在运行时，当调用一个虚函数时，C++ 会根据对象的虚表指针找到对应的虚表，然后根据虚函数在虚表中的位置，调用相应的虚函数。</p><p>在实际编程中，可以使用指针操作虚表。例如，可以将一个指向虚函数的指针与一个指向对象的虚表指针相加，从而获取对象中某个虚函数的地址。这个技巧在某些情况下可以提高程序的效率。</p><p>需要注意的是，不同的编译器可能会对虚表的实现方式有所不同，因此在使用指针操作虚表时需要注意不同编译器的差异。</p><h4 id="什么是纯虚函数纯虚函数是如何实现的"><a class="markdownIt-Anchor" href="#什么是纯虚函数纯虚函数是如何实现的">#</a> 什么是纯虚函数，纯虚函数是如何实现的</h4><p>纯虚函数是在 C++ 中的一种特殊的虚函数，它没有函数体，只有函数原型，而且必须被子类重写。纯虚函数的定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">virtual return_type function_name(parameters) = 0;</span><br></pre></td></tr></table></figure><p>其中， <code>= 0</code>  表示这是一个纯虚函数。</p><p>纯虚函数的作用是为了定义一个接口，强制子类实现该接口中的方法，从而实现多态性。例如，我们可以定义一个抽象类，其中包含一个纯虚函数，子类必须实现这个函数才能被实例化。下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void draw() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Circle : public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        // 实现画圆的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle : public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        // 实现画矩形的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Shape *ptr;</span><br><span class="line">    Circle circle;</span><br><span class="line">    Rectangle rectangle;</span><br><span class="line">    ptr = &amp;circle;</span><br><span class="line">    ptr-&gt;draw(); // 调用Circle的draw函数</span><br><span class="line">    ptr = &amp;rectangle;</span><br><span class="line">    ptr-&gt;draw(); // 调用Rectangle的draw函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Shape 类包含一个纯虚函数 draw ()，表示它是一个抽象类，不能被实例化。Circle 类和 Rectangle 类继承自 Shape 类，并重写了 draw () 函数。在 main 函数中，使用 Shape 类型的指针 ptr 分别指向 Circle 对象和 Rectangle 对象，并调用它们的 draw () 函数。由于 draw () 是一个虚函数，并且在 Shape 中被声明为纯虚函数，因此在运行时会根据 ptr 指向的对象的实际类型调用相应的函数，从而实现多态性。</p><p>纯虚函数是通过将虚函数表中的函数指针设为 NULL 来实现的。由于纯虚函数没有函数体，因此编译器不会为它生成函数的代码，而是在虚函数表中将对应的函数指针设为 NULL。这就表示该函数没有实现，必须由子类重写并实现。当派生类实现了纯虚函数后，虚函数表中对应的函数指针会被更新为子类中的函数地址，从而实现动态绑定。</p><h4 id="为什么纯虚函数不能初始化"><a class="markdownIt-Anchor" href="#为什么纯虚函数不能初始化">#</a> 为什么纯虚函数不能初始化</h4><h4 id="定义了虚函数如何在子类中访问父类的虚函数方法"><a class="markdownIt-Anchor" href="#定义了虚函数如何在子类中访问父类的虚函数方法">#</a> 定义了虚函数，如何在子类中访问父类的虚函数方法</h4><p>在 C++ 中，如果子类定义了一个和父类同名的虚函数，子类的这个函数会覆盖父类的函数，使得父类的函数在子类对象中无法直接访问。</p><p>但是，在子类中可以通过使用作用域限定符来显式地调用父类的虚函数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void foo() &#123;</span><br><span class="line">        // 父类中的虚函数实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        // 子类中的虚函数实现</span><br><span class="line">        Base::foo(); // 调用父类中的虚函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的示例中，Derived 类继承自 Base 类，并覆盖了 Base 类中的虚函数 foo ()。在 Derived 类中，我们可以使用作用域限定符 <code>Base::</code>  来调用父类中的 foo () 函数。</p><p>使用作用域限定符可以在子类中显式地调用父类的虚函数，从而保留父类的实现，并添加子类的特定功能。需要注意的是，如果父类的虚函数是纯虚函数，子类必须重写该函数，否则编译器会报错。</p><h4 id="你说的这个多态是编译器多态还是运行时多态"><a class="markdownIt-Anchor" href="#你说的这个多态是编译器多态还是运行时多态">#</a> 你说的这个多态是编译器多态还是运行时多态？</h4><p>在 C++ 中，多态分为两种类型：编译时多态和运行时多态。</p><p>在编译时多态中，函数的调用在编译期就已经确定了，具体调用哪个函数由函数的静态类型（即声明时的类型）决定。这种多态性也称为静态多态性，它是通过函数重载和模板实现的。</p><p>而在运行时多态中，函数的调用是在运行时确定的，具体调用哪个函数由函数的实际类型（即运行时对象的类型）决定。这种多态性也称为动态多态性，它是通过虚函数和继承实现的。</p><p>所以，我之前提到的多态是指运行时多态，即通过虚函数和继承实现的多态。在运行时多态中，函数的调用是在运行时才确定的，具体调用哪个函数取决于对象的实际类型，而不是声明时的类型。</p><h4 id="你知道什么是编译器多态以及运行时多态吗"><a class="markdownIt-Anchor" href="#你知道什么是编译器多态以及运行时多态吗">#</a> 你知道什么是编译器多态以及运行时多态吗？</h4><h4 id="动态库和静态库有什么区别为什么有动态库和静态库关于动态库和静态库你都知道什么"><a class="markdownIt-Anchor" href="#动态库和静态库有什么区别为什么有动态库和静态库关于动态库和静态库你都知道什么">#</a> 动态库和静态库有什么区别，为什么有动态库和静态库，关于动态库和静态库你都知道什么</h4><p>动态库和静态库都是编译后的可执行文件所依赖的库，它们的主要区别在于链接方式不同。</p><p>静态库是在编译时将库的代码链接到可执行文件中，因此可执行文件中包含了完整的库代码。静态库的好处是使用简单，只需要将库的头文件和库文件一起编译即可，不需要在运行时再去加载库。但是，静态库会使得可执行文件变得比较大，而且如果多个可执行文件都使用同一个静态库，这些可执行文件会重复包含静态库的代码，导致浪费空间。</p><p>动态库则是在运行时动态加载并链接到可执行文件中，因此可执行文件中只包含了对库函数的引用，而不包含完整的库代码。动态库的好处是可以在运行时动态加载，节省空间，也方便库的更新和维护。但是，动态库的使用相对复杂，需要在编译时指定库的位置，并且需要在运行时保证库文件的可用性。</p><p>关于动态库和静态库，我还知道以下几点：</p><ol><li>静态库的文件扩展名通常为.a（Unix/Linux）或.lib（Windows），<a href="http://xn--siqsrq5g3tb3wu3ycdsap5gqzh71i2q4cq5x3i0c.so">而动态库的文件扩展名通常为.so</a>（Unix/Linux）或.dll（Windows）。</li><li>静态库和动态库都可以包含函数、变量和类等。但是，如果库中包含了全局变量，那么在动态库中可能会出现符号冲突问题。</li><li>动态库需要在运行时加载，所以可能会影响程序的性能。此外，由于动态库的引用是在运行时解析的，所以动态库存在版本兼容性问题，需要进行版本管理。</li><li>静态库和动态库的选择取决于具体的需求和场景。通常情况下，如果需要多个可执行文件共享同一库，使用动态库更为合适；如果只需要在一个可执行文件中使用库，使用静态库更为合适。</li></ol><h4 id="为什么析构函数要定义成虚函数详细解释一下"><a class="markdownIt-Anchor" href="#为什么析构函数要定义成虚函数详细解释一下">#</a> 为什么析构函数要定义成虚函数详细解释一下</h4><p>C++ 中析构函数的作用是在对象生命周期结束时进行资源的清理和释放，它与构造函数相对应。如果一个类有虚函数，那么它的析构函数通常也应该被定义成虚函数。</p><p>理由如下：</p><ol><li>多态调用问题：如果一个基类指针指向派生类对象，那么通过这个指针调用 delete 操作时，只会调用到基类的析构函数，而不会调用到派生类的析构函数。这就导致派生类中可能存在的资源泄漏问题。如果将基类的析构函数定义成虚函数，那么在调用 delete 操作时，就会自动调用到派生类的析构函数，从而确保资源被正确释放。</li><li>防止内存泄漏问题：当一个对象从动态分配的内存中释放时，如果析构函数不是虚函数，可能只有该对象的部分内存会被释放，而不是整个对象的内存。这种情况下，就会出现内存泄漏的问题。</li><li>防止对象切割问题：如果派生类对象以值传递给一个函数，而函数参数类型是基类指针或引用类型，那么传递进去的对象就会发生 “对象切割”，即只有基类部分会被复制到函数的参数中，而派生类部分会被丢失。如果基类的析构函数不是虚函数，那么在函数结束时只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类对象的资源无法释放。</li></ol><p>综上所述，如果一个类可能会被继承或者被作为基类，那么应该将其析构函数定义为虚函数，以确保在对象被销毁时能够正确地释放资源。</p><h4 id="只定义析构函数会自动生成哪些构造函数"><a class="markdownIt-Anchor" href="#只定义析构函数会自动生成哪些构造函数">#</a> 只定义析构函数，会自动生成哪些构造函数</h4><p>在 C++ 中，如果只定义一个析构函数，编译器会自动生成默认的构造函数、拷贝构造函数和拷贝赋值运算符。</p><p>具体来说，如果一个类只定义了析构函数，没有定义任何构造函数，则编译器会自动生成默认构造函数。默认构造函数没有参数，并且不执行任何操作，仅仅是为对象分配空间。</p><p>如果一个类只定义了析构函数和拷贝构造函数，则编译器会自动生成默认拷贝赋值运算符。默认拷贝构造函数用于在对象被复制时执行浅复制，即仅仅复制对象的成员变量的值，而不会复制对象的动态资源。默认拷贝赋值运算符用于在对象被赋值时执行浅复制，即将右侧对象的成员变量的值复制给左侧对象的成员变量。</p><p>需要注意的是，如果一个类需要执行深复制或者需要自定义构造函数，那么就需要手动定义这些函数，否则使用默认函数可能会导致程序错误或者内存泄漏。</p><h4 id="解释下向上转型和向下转型以及c中的四种强制类型转换为什么要有这四种强制类型转换你平时都用过哪些"><a class="markdownIt-Anchor" href="#解释下向上转型和向下转型以及c中的四种强制类型转换为什么要有这四种强制类型转换你平时都用过哪些">#</a> 解释下向上转型和向下转型，以及 C++ 中的四种强制类型转换，为什么要有这四种强制类型转换，你平时都用过哪些</h4><ol><li>向上转型（upcasting）：指的是将一个派生类指针或引用赋值给基类指针或引用的过程，即从派生类到基类的转换。这种转换是安全的，因为基类指针或引用只能访问基类中的成员，不会访问派生类中新增的成员或重载的成员函数。</li><li>向下转型（downcasting）：指的是将一个基类指针或引用转换为派生类指针或引用的过程，即从基类到派生类的转换。这种转换是危险的，因为基类指针或引用可能并不指向一个派生类对象，如果这样的转换失败，则会导致程序崩溃或者未定义行为。</li><li>C++ 中的四种强制类型转换分别为：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。<ul><li>static_cast：用于基本数据类型之间的转换，以及指针或引用之间的转换。这种转换是在编译时完成的，对于向上转型和向下转型都可以使用。但是，对于向下转型，如果类型转换不合法，则会在运行时产生未定义行为，因此需要谨慎使用。</li><li>dynamic_cast：用于将基类指针或引用转换为派生类指针或引用。这种转换是在运行时完成的，会进行类型检查，如果类型转换不合法，则返回空指针或抛出 std::bad_cast 异常。dynamic_cast 只能用于有虚函数的类之间的转换，因为它依赖于运行时类型信息。</li><li>const_cast：用于移除对象的 const 属性或将对象的 volatile 属性移除。这种转换主要用于遗留代码和与 C 语言代码的互操作。</li><li>reinterpret_cast：用于不同类型之间的强制转换，它可以将任何类型的指针或引用转换为任何其他类型的指针或引用。这种转换是非常危险的，因为它完全依赖于编译器的实现，可能会导致未定义行为或崩溃。</li></ul></li><li>强制类型转换的主要目的是为了解决类型不匹配的问题。这四种转换方式提供了不同的转换方式，使程序员可以根据需要选择适当的方式。需要注意的是，强制类型转换应该尽可能地避免使用，因为它们可能会导致安全问题和未定义行为。在实际开发中，应该尽量使用更加安全的类型转换方式，例如模板函数、函数重载、继承等。</li></ol><h3 id="做题吧"><a class="markdownIt-Anchor" href="#做题吧">#</a> 做题吧</h3><h4 id="写一个线程安全且高效的懒汉单例模式"><a class="markdownIt-Anchor" href="#写一个线程安全且高效的懒汉单例模式">#</a> 写一个线程安全且高效的懒汉单例模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 私有化构造函数，保证只能在内部创建实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;怎么这样捏，太紧张了，很多东西都没想起来&lt;/p&gt;
&lt;p&gt;自我介绍开场&lt;/p&gt;
&lt;h4 id=&quot;c&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c&quot;&gt;#&lt;/a&gt; C++&lt;/h4&gt;
&lt;h4 id=&quot;智能指针熟悉吗介绍下智能指针&quot;&gt;&lt;a class=</summary>
      
    
    
    
    
    <category term="面试" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题day11</title>
    <link href="https://flowerhai.github.io/2023/04/24/day11/"/>
    <id>https://flowerhai.github.io/2023/04/24/day11/</id>
    <published>2023-04-24T03:55:24.000Z</published>
    <updated>2023-04-24T03:55:57.536Z</updated>
    
    <content type="html"><![CDATA[<h4 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和">#</a> <a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><p>给你一个整数数组  <code>nums</code>  ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>这个题动态规划就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> r = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i<span class="number">-1</span>] + nums[i] &gt; nums[i]) res[i] = res[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">            <span class="keyword">else</span> res[i] = nums[i];</span><br><span class="line"></span><br><span class="line">            r = <span class="built_in">max</span>(r, res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a class="markdownIt-Anchor" href="#70-爬楼梯">#</a> <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要  <code>n</code>  阶你才能到达楼顶。</p><p>每次你可以爬  <code>1</code>  或  <code>2</code>  个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p>DP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + res[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表">#</a> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>老熟人了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!list1) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span> (!list2) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list2-&gt;next, list1);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="912-排序数组"><a class="markdownIt-Anchor" href="#912-排序数组">#</a> <a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></h4><p>给你一个整数数组  <code>nums</code> ，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p>写一个快排吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="83-删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#83-删除排序链表中的重复元素">#</a> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><p>给定一个已排序的链表的头  <code>head</code>  ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>用的递归，过了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        ListNode* hn = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (!hn) <span class="keyword">return</span> h;</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;val == hn-&gt;val) <span class="keyword">return</span> hn;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            h-&gt;next = hn;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="19-删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第-n-个结点">#</a> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>给你一个链表，删除链表的倒数第  <code>n</code>  个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>用的笨方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        ListNode* he  = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (ListNode* a = head; a != <span class="literal">nullptr</span>; a = a-&gt;next) &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = l - n;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* a = he;a != <span class="literal">nullptr</span> ; a = a-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == r ) &#123;</span><br><span class="line">                a-&gt;next = a-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = he-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> he;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="876-链表的中间结点"><a class="markdownIt-Anchor" href="#876-链表的中间结点">#</a> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><p>给你单链表的头结点  <code>head</code>  ，请你找出并返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[3,4,5]</span><br><span class="line">解释：链表只有一个中间结点，值为 3 。</span><br></pre></td></tr></table></figure><p>明显双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;53-最大子数组和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#53-最大子数组和&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/maximum-subarray/&quot;&gt;53. 最大子数组和&lt;</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day10</title>
    <link href="https://flowerhai.github.io/2023/04/23/day10/"/>
    <id>https://flowerhai.github.io/2023/04/23/day10/</id>
    <published>2023-04-23T14:36:04.000Z</published>
    <updated>2023-04-23T14:36:35.800Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#剑指-offer-25-合并两个排序的链表">#</a> <a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>难度简单 343 收藏分享切换为英文接收动态反馈</p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>算是很简单吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* h;</span><br><span class="line">        <span class="comment">//ListNode* head = new ListNode(0);</span></span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">            h = l2;</span><br><span class="line">            h-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            h = l1;</span><br><span class="line">            h-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-56-ii-数组中数字出现的次数-ii"><a class="markdownIt-Anchor" href="#剑指-offer-56-ii-数组中数字出现的次数-ii">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p>难度中等 443 收藏分享切换为英文接收动态反馈</p><p>在一个数组  <code>nums</code>  中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>排序解决了应该有更好的解法</p><p>需要特殊处理下边界条件，第一个元素和最后一个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        if (nums[0] != nums[1] &amp;&amp; nums[1] == nums[2]) return nums[0];</span><br><span class="line">        if (nums[nums.size()-1] != nums[nums.size()-2] &amp;&amp; nums[nums.size()-2] == nums[nums.size()-3]) return nums[nums.size()-1];</span><br><span class="line">        for (int i = 1; i&lt; nums.size()-1; i ++) &#123;</span><br><span class="line">            if (nums[i] != nums[i+1] &amp;&amp; nums[i] != nums[i-1]) return nums[i];</span><br><span class="line">        &#125; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-53-ii-0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#剑指-offer-53-ii-0~n-1中缺失的数字">#</a> <a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1 中缺失的数字</a></h4><p>难度简单 373 收藏分享切换为英文接收动态反馈</p><p>一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k:nums) cnt += k;</span><br><span class="line">        <span class="keyword">return</span> (nums.<span class="built_in">size</span>()+<span class="number">1</span>)*nums.<span class="built_in">size</span>()/<span class="number">2</span> - cnt; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点">#</a> <a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>难度简单 636 收藏分享切换为英文接收动态反馈</p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表 **：**</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p>昨天写过原题了，没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* ha = headA;</span><br><span class="line">        ListNode* hb = headB;</span><br><span class="line">        <span class="keyword">if</span> (!ha || !hb) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (ha != hb) &#123;</span><br><span class="line">            ha = ha ? ha-&gt;next : headB;</span><br><span class="line">            hb = hb ? hb-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写了四个简单题，下午面试被拷打的太惨了，写四个简单题找找自信吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-offer-25-合并两个排序的链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-25-合并两个排序的链表&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/he-bin</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day9</title>
    <link href="https://flowerhai.github.io/2023/04/22/day9/"/>
    <id>https://flowerhai.github.io/2023/04/22/day9/</id>
    <published>2023-04-22T13:32:54.000Z</published>
    <updated>2023-04-22T13:34:15.376Z</updated>
    
    <content type="html"><![CDATA[<h4 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表">#</a> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>难度简单 2076 收藏分享切换为英文接收动态反馈</p><p>给你两个单链表的头节点  <code>headA</code>  和  <code>headB</code>  ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回  <code>null</code>  。</p><p>图示两个链表在节点  <code>c1</code>  开始相交 **：**</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code>  - 相交的起始节点的值。如果不存在相交节点，这一值为  <code>0</code></li><li><code>listA</code>  - 第一个链表</li><li><code>listB</code>  - 第二个链表</li><li><code>skipA</code>  - 在  <code>listA</code>  中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code>  - 在  <code>listB</code>  中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点  <code>headA</code>  和  <code>headB</code>  传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p>关于这个题，用双指针</p><p>一个从 A 出发，一个从 B 出发</p><p>一个到头后从另外一个起点出发，相遇的点就是交点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *a = headA;</span><br><span class="line">        ListNode *b = headB;</span><br><span class="line">        <span class="comment">//if (a == nullptr || b == nullptr) return nullptr;</span></span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="543-二叉树的直径"><a class="markdownIt-Anchor" href="#543-二叉树的直径">#</a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><p>难度简单 1305 收藏分享切换为英文接收动态反馈</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br> 给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">depth</span>(rt-&gt;left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">depth</span>(rt-&gt;right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>今天下午网易笔试，做完脑子不好使了，今天就写这两题，还有三天连着面试，线程池稍微慢一点，这几天复习下面经，背下知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;160-相交链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#160-相交链表&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/intersection-of-two-linked-lists</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>信号量以及Any类型的实现</title>
    <link href="https://flowerhai.github.io/2023/04/22/thread-pool5/"/>
    <id>https://flowerhai.github.io/2023/04/22/thread-pool5/</id>
    <published>2023-04-22T10:28:32.000Z</published>
    <updated>2023-04-22T10:30:01.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池实现任意类型的返回值"><a class="markdownIt-Anchor" href="#线程池实现任意类型的返回值">#</a> 线程池实现任意类型的返回值</h3><p>实现 C++17 中的 Any 类</p><p>任意的其他类型 template</p><p>基类类型指向派生类类型</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Any</span>(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Any</span>(Any&amp;&amp;) = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T data)</span> : base_(std::make_unique&lt;Derive&lt;T&gt;&gt;(data)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">    T <span class="title">cast_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Derive&lt;T&gt; *pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (pd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;type is unmatch&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//基类类型</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Derive</span>(T data) : <span class="built_in">data_</span>(data) &#123;&#125;</span><br><span class="line">            T data_;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="信号量实现"><a class="markdownIt-Anchor" href="#信号量实现">#</a> 信号量实现</h3><p>因为线程池中的不同线程可能运行时间并不相同，因此实现线程池中的线程通信是十分有必要的。</p><p>在此不适应 C++20 中的，直接使用互斥锁和条件变量实现一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">semaphore</span>(<span class="type">int</span> Limit = <span class="number">0</span>) </span><br><span class="line">        : <span class="built_in">resLimit_</span>(Limit) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">semaphore</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//获取一个信号资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> resLimit_ &gt; <span class="number">0</span>;&#125;);</span><br><span class="line">        resLimit_ --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加一个信号资源</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        resLimit_ ++;</span><br><span class="line">        cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> resLimit_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程池实现任意类型的返回值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池实现任意类型的返回值&quot;&gt;#&lt;/a&gt; 线程池实现任意类型的返回值&lt;/h3&gt;
&lt;p&gt;实现 C++17 中的 Any 类&lt;/p&gt;
&lt;p&gt;任意的其他类型 templ</summary>
      
    
    
    
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>周五总结</title>
    <link href="https://flowerhai.github.io/2023/04/21/hhh/"/>
    <id>https://flowerhai.github.io/2023/04/21/hhh/</id>
    <published>2023-04-21T14:25:51.000Z</published>
    <updated>2023-04-21T14:26:28.200Z</updated>
    
    <content type="html"><![CDATA[<p>点进来了捏！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;点进来了捏！&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="逗你玩~" scheme="https://flowerhai.github.io/tags/%E9%80%97%E4%BD%A0%E7%8E%A9/"/>
    
  </entry>
  
  <entry>
    <title>刷题day8</title>
    <link href="https://flowerhai.github.io/2023/04/21/day8/"/>
    <id>https://flowerhai.github.io/2023/04/21/day8/</id>
    <published>2023-04-21T14:08:15.000Z</published>
    <updated>2023-04-21T14:08:45.969Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和">#</a> <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><p>难度中等 2459 收藏分享切换为英文接收动态反馈</p><p>给你一个 <strong>无重复元素</strong> 的整数数组  <code>candidates</code>  和一个目标整数  <code>target</code>  ，找出  <code>candidates</code>  中可以使数字和为目标数  <code>target</code>  的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code>  中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为  <code>target</code>  的不同组合数少于  <code>150</code>  个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p>这个题首先想到的就是直接 dfs 写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d==candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[i], d + <span class="number">1</span>);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ft</span><span class="params">(candidates.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是呢这样还是不符合题意的，因为题目还要求我们去重。</p><p>那么该如何去做呢？</p><p>关于去重，首先我是想到了哈希表，然后仔细想想不大行，太复杂了，因此考虑一下顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d==candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选当前元素</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, d+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//选当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[d] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r.<span class="built_in">emplace_back</span>(candidates[d]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[d], d);</span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ft</span><span class="params">(candidates.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>太困了脑子不好使，今天只写一题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;39-组合总和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#39-组合总和&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;39. 组合总和&lt;/a&gt;&lt;/h4</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>线程池中添加任务实现以及功能验证</title>
    <link href="https://flowerhai.github.io/2023/04/20/thread-pool4/"/>
    <id>https://flowerhai.github.io/2023/04/20/thread-pool4/</id>
    <published>2023-04-20T14:07:27.000Z</published>
    <updated>2023-04-20T14:08:09.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="向线程池中添加任务"><a class="markdownIt-Anchor" href="#向线程池中添加任务">#</a> 向线程池中添加任务：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="comment">//线程的通信 等待任务队列有空余 wait wait_for wait_until</span></span><br><span class="line">    <span class="comment">//wait 等到条件满足</span></span><br><span class="line">    <span class="comment">//wait_for 等一段时间</span></span><br><span class="line">    <span class="comment">//wait_until 等待到</span></span><br><span class="line">    <span class="comment">//notFull_.wait(lock, [&amp;]()-&gt;bool &#123;return taskQue_.size() &lt; taskQueMaxThreshHold_; &#125;);</span></span><br><span class="line">    <span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>), [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//表示notFull等待一秒钟，条件仍然没有满足</span></span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;task queue is full, submit task fail&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有余， 把任务放入任务队列</span></span><br><span class="line">    taskQue_.<span class="built_in">emplace</span>(sp);</span><br><span class="line">    taskSize_ ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为新放了任务，任务肯定非空，not_empty通知</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证线程池功能"><a class="markdownIt-Anchor" href="#验证线程池功能">#</a> 验证线程池功能：</h3><h4 id="只在里面添加一个任务"><a class="markdownIt-Anchor" href="#只在里面添加一个任务">#</a> 只在里面添加一个任务</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140243752814144</span><br><span class="line">任务获取成功 140243752814144</span><br><span class="line">tid 140243752814144begin  </span><br><span class="line">tid 140243752814144end  </span><br><span class="line">尝试获取任务 140243752814144</span><br><span class="line">尝试获取任务 140243761206848</span><br><span class="line">尝试获取任务 140243769599552</span><br><span class="line">尝试获取任务 140243777992256</span><br></pre></td></tr></table></figure><p>可知线程池成功运行</p><h4 id="在线程池中添加三个任务"><a class="markdownIt-Anchor" href="#在线程池中添加三个任务">#</a> 在线程池中添加三个任务</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br><span class="line">pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;Mytask&gt;());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">任务获取成功 140607714780736</span><br><span class="line">tid 140607714780736begin  </span><br><span class="line">tid 140607714780736end  </span><br><span class="line">尝试获取任务 140607714780736</span><br><span class="line">尝试获取任务 140607723173440</span><br><span class="line">尝试获取任务 140607731566144</span><br><span class="line">尝试获取任务 140607739958848</span><br></pre></td></tr></table></figure><p>发现在一个线程中就完成了所有任务</p><p>猜测是因为 任务体量太小，加一个睡眠函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 140719386736192</span><br><span class="line">任务获取成功 140719386736192</span><br><span class="line">tid 140719386736192begin  </span><br><span class="line">尝试获取任务 140719395128896</span><br><span class="line">任务获取成功 140719395128896</span><br><span class="line">tid 140719395128896begin  </span><br><span class="line">尝试获取任务 140719403521600</span><br><span class="line">任务获取成功 140719403521600</span><br><span class="line">tid 140719403521600begin  </span><br><span class="line">尝试获取任务 140719411914304</span><br><span class="line">tid 140719386736192end  </span><br><span class="line">尝试获取任务 140719386736192</span><br><span class="line">tid 140719395128896end  </span><br><span class="line">尝试获取任务 140719395128896</span><br><span class="line">tid 140719403521600end  </span><br><span class="line">尝试获取任务 140719403521600</span><br></pre></td></tr></table></figure><p>成功</p><h4 id="添加6个任务"><a class="markdownIt-Anchor" href="#添加6个任务">#</a> 添加 6 个任务</h4><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">尝试获取任务 139810625140288</span><br><span class="line">任务获取成功 139810625140288</span><br><span class="line">tid 139810625140288begin  </span><br><span class="line">尝试获取任务 139810633532992</span><br><span class="line">任务获取成功 139810633532992</span><br><span class="line">tid 139810633532992begin  </span><br><span class="line">尝试获取任务 139810641925696</span><br><span class="line">任务获取成功 139810641925696</span><br><span class="line">tid 139810641925696begin  </span><br><span class="line">尝试获取任务 139810650318400</span><br><span class="line">任务获取成功 139810650318400</span><br><span class="line">tid 139810650318400begin  </span><br><span class="line">tid 139810625140288end  </span><br><span class="line">尝试获取任务 139810625140288</span><br><span class="line">任务获取成功 139810625140288</span><br><span class="line">tid 139810625140288begin  </span><br><span class="line">tid 139810633532992end  </span><br><span class="line">尝试获取任务 139810633532992</span><br><span class="line">任务获取成功 139810633532992</span><br><span class="line">tid 139810633532992begin  </span><br><span class="line">tid 139810641925696end  </span><br><span class="line">尝试获取任务 139810641925696</span><br><span class="line">tid 139810650318400end  </span><br><span class="line">尝试获取任务 139810650318400</span><br><span class="line">tid 139810625140288end  </span><br><span class="line">尝试获取任务 139810625140288</span><br><span class="line">tid 139810633532992end  </span><br><span class="line">尝试获取任务 139810633532992</span><br></pre></td></tr></table></figure><h4 id="综上所述"><a class="markdownIt-Anchor" href="#综上所述">#</a> 综上所述</h4><p>该线程池目前看来并无问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;向线程池中添加任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#向线程池中添加任务&quot;&gt;#&lt;/a&gt; 向线程池中添加任务：&lt;/h3&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于线程池的一些设计以及问题排查</title>
    <link href="https://flowerhai.github.io/2023/04/19/thread-pool3/"/>
    <id>https://flowerhai.github.io/2023/04/19/thread-pool3/</id>
    <published>2023-04-19T09:34:16.000Z</published>
    <updated>2023-04-19T09:37:47.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于线程池的一些设计以及问题排查"><a class="markdownIt-Anchor" href="#关于线程池的一些设计以及问题排查">#</a> 关于线程池的一些设计以及问题排查</h3><p>关于任务队列，为了实现资源的高效管理，选用 shared_ptr 智能指针</p><p>使用 bind 函数实现类外定义的类能够访问本类所拥有的私有函数以及私有变量</p><h4 id="在验证线程池的时候发现打印出来的线程id都一样于是排查哪里出了问题"><a class="markdownIt-Anchor" href="#在验证线程池的时候发现打印出来的线程id都一样于是排查哪里出了问题">#</a> 在验证线程池的时候发现打印出来的线程 ID 都一样，于是排查哪里出了问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br><span class="line">begin threadFunc tid 140654060929984</span><br><span class="line">end threadFunc tid 140654060929984</span><br></pre></td></tr></table></figure><p>所写线程池创建 ID</p><p>原代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; initThreadSize_; i ++) &#123;</span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,<span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; initThreadSize_; i ++) &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();<span class="comment">//执行线程函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_)</span></span>; </span><br><span class="line">    t.<span class="built_in">detach</span>();<span class="comment">//设置分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;end threadFunc tid &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细排查发现应该是这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;end threadFunc tid &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_)</span></span>; </span><br><span class="line">    t.<span class="built_in">detach</span>();<span class="comment">//设置分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">    :<span class="built_in">func_</span>(func)</span><br><span class="line">&#123;&#125;</span><br><span class="line">Thread:: ~<span class="built_in">Thread</span>()&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid 140554644977216</span><br><span class="line">end threadFunc tid 140554644977216</span><br><span class="line"></span><br><span class="line">begin threadFunc tid 140554653369920</span><br><span class="line">begin threadFunc tid 140554653369920</span><br></pre></td></tr></table></figure><p>但是明明线程池里有四个线程，为什么只运行了两个呢？</p><p>查阅资料发现，是主线程运行时间太快了，因此让主线程睡一会儿～</p><p>主线程加上 sleep (3) 后发现果然，成功！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin threadFunc tid <span class="number">140566920504896</span></span><br><span class="line">end threadFunc tid <span class="number">140566920504896</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566928897600</span></span><br><span class="line">end threadFunc tid <span class="number">140566928897600</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566937290304</span></span><br><span class="line">end threadFunc tid <span class="number">140566937290304</span></span><br><span class="line"></span><br><span class="line">begin threadFunc tid <span class="number">140566945683008</span></span><br><span class="line">end threadFunc tid <span class="number">140566945683008</span></span><br></pre></td></tr></table></figure><h4 id="发现线程池中的线程用的是裸指针"><a class="markdownIt-Anchor" href="#发现线程池中的线程用的是裸指针">#</a> 发现线程池中的线程用的是裸指针</h4><p>修改为 unique_ptr 后然后发现以下问题</p><p ::new((void="" *)__p)="" _Up(std::forward&lt;_Args(__args)...);="">/usr/include/c++/11/ext/new_allocator.h:162:11: error: cannot convert ‘std::unique_ptr&lt;Thread, std::default_delete<Thread> &gt;’ to ‘Thread*’ in initialization<br>162 |        </p><p>左值引用问题</p><p>move 一下</p><p>然后还是错误</p><p>陷入沉思</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,<span class="keyword">this</span>));</span><br><span class="line">threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br></pre></td></tr></table></figure><p>逆天！</p><p>气死我了！</p><p>因为是远程连接 ECS 的原因，头文件没保存，</p><p>心中一万只草泥🐎奔腾！</p><p>所以修改成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于线程池的一些设计以及问题排查&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于线程池的一些设计以及问题排查&quot;&gt;#&lt;/a&gt; 关于线程池的一些设计以及问题排查&lt;/h3&gt;
&lt;p&gt;关于任务队列，为了实现资源的高效管理，选用 shared_</summary>
      
    
    
    
    
    <category term="bug" scheme="https://flowerhai.github.io/tags/bug/"/>
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="https://flowerhai.github.io/2023/04/19/shuati/acw1/"/>
    <id>https://flowerhai.github.io/2023/04/19/shuati/acw1/</id>
    <published>2023-04-19T01:53:07.000Z</published>
    <updated>2023-04-19T03:28:23.138Z</updated>
    
    <content type="html"><![CDATA[<ol start="241"><li>楼兰图腾</li></ol><p>在完成了分配任务之后，西部 314314 来到了楼兰古城的西部。</p><p>相传很久以前这片土地上 (比楼兰古城还早) 生活着两个部落，一个部落崇拜尖刀 ( <code>V</code> )，一个部落崇拜铁锹 ( <code>∧</code> )，他们分别用  <code>V</code>  和  <code>∧</code>  的形状来代表各自部落的图腾。</p><p>西部 314314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n  个点，经测量发现这 n 个点的水平位置和竖直位置是两两不同的。</p><p>西部 314314 认为这幅壁画所包含的信息与这 n  个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)(1, 1),(2, 2),…,( ,  )，其中 y1∼yn 1∼   是 11 到 n  的一个排列。</p><p>西部 314314 打算研究这幅壁画中包含着多少个图腾。</p><p>如果三个点 (i,yi),(j,yj),(k,yk)( ,  ),( ,  ),( ,  ) 满足 1≤i&lt;j&lt;k≤n1≤ &lt; &lt; ≤  且 yi&gt;yj,yj<yk  >  ,  &lt;  ，则称这三个点构成  <code>V</code>  图腾；</p><p>如果三个点 (i,yi),(j,yj),(k,yk)( ,  ),( ,  ),( ,  ) 满足 1≤i&lt;j&lt;k≤n1≤ &lt; &lt; ≤  且 yi&lt;yj,yj&gt;yk  &lt;  ,  &gt;  ，则称这三个点构成  <code>∧</code>  图腾；</p><p>西部 314314 想知道，这 n  个点中两个部落图腾的数目。</p><p>因此，你需要编写一个程序来求出  <code>V</code>  的个数和  <code>∧</code>  的个数。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行一个数 n 。</p><p>第二行是 n  个数，分别代表 y1，y2,…,yn 1， 2,…,  。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>两个数，中间用空格隔开，依次为  <code>V</code>  的个数和  <code>∧</code>  的个数。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>对于所有数据，n≤200000 ≤200000，且输出答案不会超过 int64   64。<br>y1∼yn 1∼   是 11 到 n  的一个排列。</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 2 4</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure><p>此题用树状数组，对于每一个点找出其左边比该点值大的，右边亦如此，两个数相乘，最后得到的数就是该点中 V 的图腾个数，n 正好相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> Greater[N], lower[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        Greater[i] = <span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y);</span><br><span class="line">        lower[i] = <span class="built_in">sum</span>(y - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">    LL res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * (LL)(<span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y));</span><br><span class="line">        res2 += lower[i] * (LL)(<span class="built_in">sum</span>(y - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, res1, res2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;241&quot;&gt;
&lt;li&gt;楼兰图腾&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在完成了分配任务之后，西部 314314 来到了楼兰古城的西部。&lt;/p&gt;
&lt;p&gt;相传很久以前这片土地上 (比楼兰古城还早) 生活着两个部落，一个部落崇拜尖刀 ( &lt;code&gt;V&lt;/code&gt; )，一个</summary>
      
    
    
    
    
    <category term="树状数组" scheme="https://flowerhai.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>刷题day7</title>
    <link href="https://flowerhai.github.io/2023/04/19/day7/"/>
    <id>https://flowerhai.github.io/2023/04/19/day7/</id>
    <published>2023-04-19T01:51:46.000Z</published>
    <updated>2023-04-19T01:52:48.593Z</updated>
    
    <content type="html"><![CDATA[<h4 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和">#</a> <a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>难度中等 5885 收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组  <code>nums</code>  ，判断是否存在三元组  <code>[nums[i], nums[j], nums[k]]</code>  满足  <code>i != j</code> 、 <code>i != k</code>  且  <code>j != k</code>  ，同时还满足  <code>nums[i] + nums[j] + nums[k] == 0</code>  。请</p><p>你返回所有和为  <code>0</code>  且不重复的三元组。</p><p>** 注意：** 答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p>三树之和，经典老题了。</p><p>先将数组排序，随后用双指针，从头到尾，slow 的话从 i+1 开始，fast 从末尾开始。</p><p>如果 nums [i] + nums [slow] + nums [fast] &lt; 0</p><p>将 slow 右移</p><p>如果上面那个值大于 0</p><p>将 fast 左移</p><p>每次移动避开相同的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> slow = i + <span class="number">1</span>, fast = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (slow &lt; fast) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[slow]+nums[fast]+nums[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    slow ++;</span><br><span class="line">                    <span class="comment">//while (nums[slow] == nums[slow-1] &amp;&amp; slow &lt; fast) slow ++;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nums[slow]+nums[fast]+nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    fast --;</span><br><span class="line">                    <span class="comment">//while (nums[fast] == nums[fast+1] &amp;&amp; slow &lt; fast) fast --;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[slow], nums[fast]&#125;);</span><br><span class="line">                    slow ++;</span><br><span class="line">                    <span class="keyword">while</span> (nums[slow] == nums[slow<span class="number">-1</span>] &amp;&amp; slow &lt; fast) slow ++;</span><br><span class="line">                    fast --;</span><br><span class="line">                    <span class="keyword">while</span> (nums[fast] == nums[fast+<span class="number">1</span>] &amp;&amp; slow &lt; fast) fast --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res.erase(unique(res.begin(), res.end()), res.end());</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表">#</a> <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><p>难度简单 3105 收藏分享切换为英文接收动态反馈</p><p>给你单链表的头节点  <code>head</code>  ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>此题 easy 题，用一个头节点即可轻松完成翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">while</span> (h) &#123;</span><br><span class="line">            ListNode* ne = h-&gt;next;</span><br><span class="line">            h-&gt;next = q;</span><br><span class="line">            q = h;</span><br><span class="line">            h = ne;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="538-把二叉搜索树转换为累加树"><a class="markdownIt-Anchor" href="#538-把二叉搜索树转换为累加树">#</a> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>难度中等 880 收藏分享切换为英文接收动态反馈</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点  <code>node</code>  的新值等于原树中大于或等于  <code>node.val</code>  的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p>** 注意：** 本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p>反向中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">            sum += root-&gt;val;</span><br><span class="line">            root-&gt;val = sum;</span><br><span class="line">            <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="241"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;15-三数之和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#15-三数之和&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/3sum/&quot;&gt;15. 三数之和&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;难度中等 5</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day6</title>
    <link href="https://flowerhai.github.io/2023/04/18/day6/"/>
    <id>https://flowerhai.github.io/2023/04/18/day6/</id>
    <published>2023-04-18T12:51:08.000Z</published>
    <updated>2023-04-18T12:52:15.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="75-颜色分类"><a class="markdownIt-Anchor" href="#75-颜色分类">#</a> <a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h4><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>示例</mtext><mn>1</mn><mtext>：输入：</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo><mtext>输出：</mtext><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">示例 1：输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">例</span><span class="mord">1</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">：</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">：</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p>这个题，炒鸡简单。、</p><p>先把 0 放放前面，再把 1 放前面，就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> two = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) <span class="built_in">swap</span>(nums[i], nums[zero++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏">#</a> <a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p>对每个点都求一下最大可到达距离，如果有点的能够大于等于 size-1，即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> r_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r_max) &#123;</span><br><span class="line">                r_max = <span class="built_in">max</span>(r_max, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (r_max &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#剑指-offer-34-二叉树中和为某一值的路径">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br> 输出：[[5,4,11,2],[5,8,4,5]]</p><p>这道题，对每一个节点进行 dfs 操作，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        r.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        target -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, target);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, target);</span><br><span class="line">        r.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="1252"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;75-颜色分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#75-颜色分类&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/sort-colors/&quot;&gt;75. 颜色分类&lt;/a&gt;&lt;/h4&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>线程池代码(整合版)</title>
    <link href="https://flowerhai.github.io/2023/04/18/thread-pool2/"/>
    <id>https://flowerhai.github.io/2023/04/18/thread-pool2/</id>
    <published>2023-04-18T08:44:21.000Z</published>
    <updated>2023-04-18T08:45:36.269Z</updated>
    
    <content type="html"><![CDATA[<p>关于线程池的设计，很多都和内存池差不多，在此贴上总体代码。</p><p>后续再挨个分析细节以及编写过程中的 Bug 调试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> TASK_MAX_THRESHHOLD = <span class="number">2</span>; <span class="comment">// INT32_MAX;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_IDLE_TIME = <span class="number">60</span>; <span class="comment">// 单位：秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池支持的模式</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">PoolMode</span> &#123;</span><br><span class="line">MODE_FIXED,  <span class="comment">// 固定数量的线程</span></span><br><span class="line">MODE_CACHED, <span class="comment">// 线程数量可动态增长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程函数对象类型</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程构造</span></span><br><span class="line"><span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">: <span class="built_in">func_</span>(func)</span><br><span class="line">, <span class="built_in">threadId_</span>(generateId_++)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 线程析构</span></span><br><span class="line">~<span class="built_in">Thread</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个线程来执行一个线程函数 pthread_create</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func_, threadId_)</span></span>;  <span class="comment">// C++11来说 线程对象t  和线程函数func_</span></span><br><span class="line">t.<span class="built_in">detach</span>(); <span class="comment">// 设置分离线程   pthread_detach  pthread_t设置成分离线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> threadId_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ThreadFunc func_;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> generateId_;</span><br><span class="line"><span class="type">int</span> threadId_;  <span class="comment">// 保存线程id</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 线程池构造</span></span><br><span class="line"><span class="built_in">ThreadPool</span>()</span><br><span class="line">: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">curThreadSize_</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">threadSizeThreshHold_</span>(THREAD_MAX_THRESHHOLD)</span><br><span class="line">, <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED)</span><br><span class="line">, <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池析构</span></span><br><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程池里面所有的线程返回  有两种状态：阻塞 &amp; 正在执行任务中</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池的工作模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">poolMode_ = mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置task任务队列上线阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">taskQueMaxThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程池cached模式下线程阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkRunningState</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">&#123;</span><br><span class="line">threadSizeThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池提交任务</span></span><br><span class="line"><span class="comment">// 使用可变参模板编程，让submitTask可以接收任意任务函数和任意数量的参数</span></span><br><span class="line"><span class="comment">// pool.submitTask(sum1, 10, 20);   csdn  大秦坑王  右值引用+引用折叠原理</span></span><br><span class="line"><span class="comment">// 返回值future&lt;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 打包任务，放入任务队列里面</span></span><br><span class="line"><span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">std::future&lt;RType&gt; result = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"><span class="comment">// 用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回</span></span><br><span class="line"><span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">[&amp;]()-&gt;<span class="type">bool</span> &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; (<span class="type">size_t</span>)taskQueMaxThreshHold_; &#125;)) &#123;</span><br><span class="line"><span class="comment">// 表示notFull_等待1s种，条件依然没有满足</span></span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;task queue is full, submit task fail.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">[]()-&gt;RType &#123; <span class="keyword">return</span> <span class="built_in">RType</span>(); &#125;);</span><br><span class="line">(*task)();</span><br><span class="line"><span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有空余，把任务放入任务队列中</span></span><br><span class="line"><span class="comment">// taskQue_.emplace(sp);  </span></span><br><span class="line"><span class="comment">// using Task = std::function&lt;void()&gt;;</span></span><br><span class="line">taskQue_.<span class="built_in">emplace</span>([task]() &#123;(*task)();&#125;);</span><br><span class="line">taskSize_++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为新放了任务，任务队列肯定不空了，在notEmpty_上进行通知，赶快分配线程执行任务</span></span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式 任务处理比较紧急 场景：小而快的任务 需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程出来</span></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">&amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">&amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line"><span class="comment">// 修改线程个数相关的变量</span></span><br><span class="line">curThreadSize_++;</span><br><span class="line">idleThreadSize_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回任务的Result对象</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启线程池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> initThreadSize = std::thread::hardware_concurrency())</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录初始线程个数</span></span><br><span class="line">initThreadSize_ = initThreadSize;</span><br><span class="line">curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line"><span class="comment">// 创建thread线程对象的时候，把线程函数给到thread线程对象</span></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line"><span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line"><span class="comment">// threads_.emplace_back(std::move(ptr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动所有线程  std::vector&lt;Thread*&gt; threads_;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++) &#123;</span><br><span class="line">threads_[i]-&gt;<span class="built_in">start</span>(); <span class="comment">// 需要去执行一个线程函数</span></span><br><span class="line">idleThreadSize_++;    <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有任务必须执行完成，线程池才可以回收所有线程资源</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Task task; &#123;</span><br><span class="line"><span class="comment">// 先获取锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line"><span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line"><span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line"><span class="comment">// 锁 + 双重判断</span></span><br><span class="line"><span class="keyword">while</span> (taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line"><span class="keyword">if</span> (!isPoolRunning_) &#123;</span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line">exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 线程函数结束，线程结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED) &#123;</span><br><span class="line"><span class="comment">// 条件变量，超时返回了</span></span><br><span class="line"><span class="keyword">if</span> (std::cv_status::timeout ==</span><br><span class="line">notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line"><span class="keyword">if</span> (dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">&amp;&amp; curThreadSize_ &gt; initThreadSize_) &#123;</span><br><span class="line"><span class="comment">// 开始回收当前线程</span></span><br><span class="line"><span class="comment">// 记录线程数量的相关变量的值修改</span></span><br><span class="line"><span class="comment">// 把线程对象从线程列表容器中删除   没有办法 threadFunc《=》thread对象</span></span><br><span class="line"><span class="comment">// threadid =&gt; thread对象 =&gt; 删除</span></span><br><span class="line">threads_.<span class="built_in">erase</span>(threadid); <span class="comment">// std::this_thread::getid()</span></span><br><span class="line">curThreadSize_--;</span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">&lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 等待notEmpty条件</span></span><br><span class="line">notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_--;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从任务队列种取一个任务出来</span></span><br><span class="line">task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">taskSize_--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果依然有剩余任务，继续通知其它得线程执行任务</span></span><br><span class="line"><span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出一个任务，进行通知，通知可以继续提交生产任务</span></span><br><span class="line">notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125; <span class="comment">// 就应该把锁释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程负责执行这个任务</span></span><br><span class="line"><span class="keyword">if</span> (task != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">task</span>(); <span class="comment">// 执行function&lt;void()&gt; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleThreadSize_++;</span><br><span class="line">lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">// 更新线程执行完任务的时间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查pool的运行状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isPoolRunning_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_; <span class="comment">// 线程列表</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> initThreadSize_;  <span class="comment">// 初始的线程数量</span></span><br><span class="line"><span class="type">int</span> threadSizeThreshHold_; <span class="comment">// 线程数量上限阈值</span></span><br><span class="line">std::atomic_int curThreadSize_;<span class="comment">// 记录当前线程池里面线程的总数量</span></span><br><span class="line">std::atomic_int idleThreadSize_; <span class="comment">// 记录空闲线程的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task任务 =》 函数对象</span></span><br><span class="line"><span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">std::queue&lt;Task&gt; taskQue_; <span class="comment">// 任务队列</span></span><br><span class="line">std::atomic_int taskSize_; <span class="comment">// 任务的数量</span></span><br><span class="line"><span class="type">int</span> taskQueMaxThreshHold_;  <span class="comment">// 任务队列数量上限阈值</span></span><br><span class="line"></span><br><span class="line">std::mutex taskQueMtx_; <span class="comment">// 保证任务队列的线程安全</span></span><br><span class="line">std::condition_variable notFull_; <span class="comment">// 表示任务队列不满</span></span><br><span class="line">std::condition_variable notEmpty_; <span class="comment">// 表示任务队列不空</span></span><br><span class="line">std::condition_variable exitCond_; <span class="comment">// 等到线程资源全部回收</span></span><br><span class="line"></span><br><span class="line">PoolMode poolMode_; <span class="comment">// 当前线程池的工作模式</span></span><br><span class="line">std::atomic_bool isPoolRunning_; <span class="comment">// 表示当前线程池的启动状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于线程池的设计，很多都和内存池差不多，在此贴上总体代码。&lt;/p&gt;
&lt;p&gt;后续再挨个分析细节以及编写过程中的 Bug 调试&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>线程池总体设计及相关概念</title>
    <link href="https://flowerhai.github.io/2023/04/18/thread-pool1/"/>
    <id>https://flowerhai.github.io/2023/04/18/thread-pool1/</id>
    <published>2023-04-18T08:42:56.000Z</published>
    <updated>2023-04-19T09:36:36.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池">#</a> 线程池</h2><h3 id="线程池-2"><a class="markdownIt-Anchor" href="#线程池-2">#</a> 线程池</h3><p>池也算是比较常用的降低时间开销的手段了吧，</p><p>在此总结一下写过的线程池，把每一步捋顺了，再稍微复习下多线程相关的知识。</p><h4 id="关于本线程池项目描述"><a class="markdownIt-Anchor" href="#关于本线程池项目描述">#</a> 关于本线程池项目描述：</h4><ul><li>基于可变参模板编程和引用折叠原理，实现线程池 submitTask 接口，支持任意任务函数和任意参数 的传递</li><li>使用 future 类型定制 submitTask 提交任务的返回值</li><li>使用 map 和 queue 容器管理线程对象和任务</li><li>基于条件变量 condition_variable 和互斥锁 mutex 实现任务提交线程和任务执行线程间</li><li>的通信机制</li><li>支持 fixed 和 cached 模式的线程池定制</li><li>gdb 调试分析定位死锁问题</li></ul><h4 id="线程的消耗"><a class="markdownIt-Anchor" href="#线程的消耗">#</a> 线程的消耗</h4><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好？</p><ul><li>线程的创建和销毁都是非常 &quot;重&quot; 的操作</li><li>线程栈本身占用大量内存</li><li>线程的上下文切换要占用大量时间</li><li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机</li></ul><h4 id="线程池的优势"><a class="markdownIt-Anchor" href="#线程池的优势">#</a> 线程池的优势</h4><p>操作系统上创建线程和销毁线程都是很 &quot;重&quot; 的操作，耗时耗性能都比较多，那么在服务执行的过程中， 如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能 降低，业务的处理能力也会降低。 线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线 程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 task 任务即可，task 执行 完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的 task 提供服务。</p><h4 id="fixed模式线程池"><a class="markdownIt-Anchor" href="#fixed模式线程池">#</a> fixed 模式线程池</h4><p>线程池里面的线程个数是固定不变的，一般是 ThreadPool 创建时根据当前机器的 CPU 核心数量进行指 定。</p><h4 id="cached模式线程池"><a class="markdownIt-Anchor" href="#cached模式线程池">#</a> cached 模式线程池</h4><p>线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程 数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了 60s 还没 有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。</p><ul><li><p>C++11</p><p>组合和继承，多态，STL，智能指针，函数对象，绑定器，可变参模板编程</p></li><li><p>C++11 多线程编程</p><p>thread,mutxe,atomic,condition_variable,unique_lock</p></li><li><p>C<ins>17 和 C</ins>20 的标准的一些内容</p><p>17 的 any， 20 的 semaphore</p></li><li><p>多线程理论</p><p>多线程基本知识，线程互斥，线程同步，原子操作，CAS</p></li></ul><h4 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行">#</a> 并发和并行</h4><ul><li>CPU 单核</li><li>CPU 多核、多 CPU</li></ul><h4 id="并发"><a class="markdownIt-Anchor" href="#并发">#</a> 并发</h4><p>单核上，多个线程占用不同的 CPU 时间片，物理上还是串行执行的，但是由于每个线程占用的 CPU 时间 片非常短（比如 10ms），看起来就像是多个线程都在共同执行一样，这样的场景称作并发 （concurrent）。</p><h4 id="并行"><a class="markdownIt-Anchor" href="#并行">#</a> 并行</h4><p>在多核或者多 CPU 上，多个线程是在真正的同时执行，这样的场景称作并行（parallel）。</p><h3 id="多线程的优势"><a class="markdownIt-Anchor" href="#多线程的优势">#</a> 多线程的优势</h3><p>多线程程序一定就好吗？不一定，要看具体的应用场景：</p><h4 id="io密集型"><a class="markdownIt-Anchor" href="#io密集型">#</a> IO 密集型</h4><p>程序里面指令的执行，涉及一些 IO 操作 (会阻塞)</p><p>无论是 CPU 单核、CPU 多核、多 CPU，都是比较适合多线程程序的</p><h4 id="cpu密集型"><a class="markdownIt-Anchor" href="#cpu密集型">#</a> CPU 密集型</h4><p>(程序里面的指令做计算用的)</p><ul><li><p>CPU 单核</p><p>多线程存在上下文切换，是额外的花销，线程越多上下文切换所花费的额外时间也越多，倒不如一个线 程一直进 行计算。</p></li><li><p>CPU 多核、多 CPU</p><p>多个线程可以并行执行，对 CPU 利用率好</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池&quot;&gt;#&lt;/a&gt; 线程池&lt;/h2&gt;
&lt;h3 id=&quot;线程池-2&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程池-2&quot;&gt;#&lt;/a&gt; 线程池&lt;/h3</summary>
      
    
    
    
    
    <category term="bug" scheme="https://flowerhai.github.io/tags/bug/"/>
    
    <category term="线程池实现" scheme="https://flowerhai.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池压测</title>
    <link href="https://flowerhai.github.io/2023/04/17/yace/"/>
    <id>https://flowerhai.github.io/2023/04/17/yace/</id>
    <published>2023-04-17T11:37:45.000Z</published>
    <updated>2023-04-17T11:38:13.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压测"><a class="markdownIt-Anchor" href="#压测">#</a> 压测：</h3><ul><li>50393us 数据库连接池 100</li><li>424062us 普通连接 100</li></ul><p>可以看出使用线程池后效果拔群！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;压测&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#压测&quot;&gt;#&lt;/a&gt; 压测：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;50393us 数据库连接池 100&lt;/li&gt;
&lt;li&gt;424062us 普通连接 100&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出</summary>
      
    
    
    
    
    <category term="数据库连接池实现" scheme="https://flowerhai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库连接池实现</title>
    <link href="https://flowerhai.github.io/2023/04/17/mysql-mysql-poo2/"/>
    <id>https://flowerhai.github.io/2023/04/17/mysql-mysql-poo2/</id>
    <published>2023-04-17T11:34:15.000Z</published>
    <updated>2023-04-17T11:36:46.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库连接池"><a class="markdownIt-Anchor" href="#数据库连接池">#</a> 数据库连接池</h3><h4 id="数据库连接池-2"><a class="markdownIt-Anchor" href="#数据库连接池-2">#</a> 数据库连接池：</h4><h5 id="小tips"><a class="markdownIt-Anchor" href="#小tips">#</a> 小 tips：</h5><p>关于外部获取连接池中的空闲连接，在此可以使用智能指针来完成内存管理，能够方便许多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">connectpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取连接池对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> connectpool* <span class="title">getconnectpool</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;<span class="comment">//给外部提供一个接口，从连接池中获取一个可用的空闲连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadconfig</span><span class="params">()</span></span>;<span class="comment">//加载配置项</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span></span>;<span class="comment">//生产新连接 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connectpool</span>();<span class="comment">//构造函数私有化</span></span><br><span class="line">    string _ip;<span class="comment">//ip地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> _port;<span class="comment">//端口号</span></span><br><span class="line">    string _username;<span class="comment">//用户名</span></span><br><span class="line">    string _password;<span class="comment">//密码</span></span><br><span class="line">    string _dbname;<span class="comment">//db名字</span></span><br><span class="line">    <span class="type">int</span> _initsize; <span class="comment">//初始连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxsize;<span class="comment">//最大连接数量</span></span><br><span class="line">    <span class="type">int</span> _maxIdleTime;<span class="comment">//连接池最大空闲时间</span></span><br><span class="line">    <span class="type">int</span> _connectTimeout;<span class="comment">//连接池获取连接的超时时间 </span></span><br><span class="line"></span><br><span class="line">    queue&lt;connection*&gt; _connectqueue; <span class="comment">//存储mysql的队列</span></span><br><span class="line">    mutex _queueMutex;<span class="comment">//维护连接队列的线程安全互斥锁</span></span><br><span class="line">    atomic_int connectCnt;<span class="comment">//记录连接创建的connect连接的数量</span></span><br><span class="line">    condition_variable cv;<span class="comment">//设置条件变量，用于连接生产者和消费者</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="数据库连接池的构造函数"><a class="markdownIt-Anchor" href="#数据库连接池的构造函数">#</a> 数据库连接池的构造函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connectpool::<span class="built_in">connectpool</span>() &#123;</span><br><span class="line">    <span class="built_in">loadconfig</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _initsize; i ++) &#123;</span><br><span class="line">        connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">        p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">        _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">        connectCnt ++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//启动一个新的线程，作为连接的生产者</span></span><br><span class="line">    <span class="function">thread <span class="title">produce</span><span class="params">(bind(&amp;connectpool::produceConnectionTask, <span class="keyword">this</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者函数"><a class="markdownIt-Anchor" href="#生产者函数">#</a> 生产者函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::produceConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock);<span class="comment">//队列不空，生产者进入等待状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接数量没到达上限，继续创建新的连接</span></span><br><span class="line">        <span class="keyword">if</span>(connectCnt &lt; _maxsize) &#123;</span><br><span class="line">            connection*p = <span class="keyword">new</span> <span class="built_in">connection</span>();</span><br><span class="line">            p-&gt;<span class="built_in">connect</span>(_ip, _port, _username, _password, _dbname);</span><br><span class="line">            _connectqueue.<span class="built_in">push</span>(p);</span><br><span class="line">            connectCnt ++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知消费者线程，可以消费连接</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者函数"><a class="markdownIt-Anchor" href="#消费者函数">#</a> 消费者函数：</h4><p>智能指针加 lambda 表达式</p><p>注意 sleep 和 wait-for 的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;connection&gt; <span class="title">connectpool::getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv_status::timeout ==  cv.<span class="built_in">wait_for</span>(lock, chrono::<span class="built_in">milliseconds</span>(_connectTimeout))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="built_in">LOG</span>(<span class="string">&quot;获取空闲连接超时————失败！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 智能指针析构时，会把资源delete，需要自定义 ./run</span></span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">sp</span><span class="params">(_connectqueue.front(), </span></span></span><br><span class="line"><span class="params"><span class="function">            [&amp;](connection *pcon) &#123;<span class="comment">//要考虑线程安全</span></span></span></span><br><span class="line"><span class="params"><span class="function">                unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">                pcon-&gt;refreshAliveTime();<span class="comment">//刷新一下开始空闲起始时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                _connectqueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_connectqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();<span class="comment">//空了再通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除超时连接"><a class="markdownIt-Anchor" href="#删除超时连接">#</a> 删除超时连接</h4><p>应当注意在上面的代码中，在每次创建完数据库连接时刷新一下定时器，或者消费者使用完的连接返还回数据库连接池时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectpool::scanConnectionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//通过sleep模拟定时效果</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(_maxIdleTime));</span><br><span class="line">        <span class="comment">//扫描整个队列，释放多余连接</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (connectCnt &gt; _initsize) &#123;</span><br><span class="line">            connection *p = _connectqueue.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;<span class="built_in">getAliceTime</span>() &gt;= (_maxIdleTime * <span class="number">1000</span>)) &#123;</span><br><span class="line">                _connectqueue.<span class="built_in">pop</span>();</span><br><span class="line">                connectCnt --;</span><br><span class="line">                <span class="keyword">delete</span> p;<span class="comment">//释放连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//队头的连接都没超时，后面更不会</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库连接池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库连接池&quot;&gt;#&lt;/a&gt; 数据库连接池&lt;/h3&gt;
&lt;h4 id=&quot;数据库连接池-2&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库连接池-2</summary>
      
    
    
    
    
    <category term="数据库连接池实现" scheme="https://flowerhai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
</feed>
