<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚迷离</title>
  
  
  <link href="https://flowerhai.github.io/atom.xml" rel="self"/>
  
  <link href="https://flowerhai.github.io/"/>
  <updated>2023-05-20T09:15:04.830Z</updated>
  <id>https://flowerhai.github.io/</id>
  
  <author>
    <name>恍惚迷离</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并行计算环境搭建</title>
    <link href="https://flowerhai.github.io/2023/05/20/bingxing/ab/"/>
    <id>https://flowerhai.github.io/2023/05/20/bingxing/ab/</id>
    <published>2023-05-20T05:56:53.000Z</published>
    <updated>2023-05-20T09:15:04.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验环境配置"><a class="markdownIt-Anchor" href="#实验环境配置">#</a> 实验环境配置</h3><p>阅读实验手册发现，并没有地方需要使用 openEuler 20.03 操作系统</p><p>如果硬用 openEuler 20.03 各种恶心人的问题。</p><p>不如直接选择 Ubuntu 系统，安装各种包更方便。<br>同时推荐使用 xhell，xftp 对云服务器进行操作</p><p>这是我的开发环境，别忘了购买公网 IP。<br>注意要选择高性能计算型，否则 make -j2 那里会出现问题<br> 2vCPUs | 4GiB | h3.large.2<br>Ubuntu 22.04 server 64bit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mpich</span><br></pre></td></tr></table></figure><p>输入即可。</p><p>随后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/xianyi/OpenBLAS/archive/v0.3.8.tar.gz</span><br><span class="line">tar -zxvf v0.3.8.tar.gz &amp;&amp; cd OpenBLAS-0.3.8</span><br><span class="line">make -j2</span><br><span class="line">sudo make PREFIX=/usr/local/openblas install</span><br><span class="line">sudo chmod -R 777 /usr/local/openblas/</span><br><span class="line">sudo ln -s /usr/local/openblas/lib/libopenblas.so /usr/lib/libopenblas.so</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vim之后添加</span></span><br><span class="line">export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/openblas/include</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/openblas/lib</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line">make</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br><span class="line">ip b</span><br><span class="line">(ip是指ifconfig看到的那个ip)</span><br></pre></td></tr></table></figure><h2 id="搭建多机集群"><a class="markdownIt-Anchor" href="#搭建多机集群">#</a> 搭建多机集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>假设一个机器为 a, 另外一个机器为 b。<br>用 ifconfig 查看 ip。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 192.xxx.0.xxx</span><br><span class="line">b 192.xxx.0.xxx</span><br></pre></td></tr></table></figure><p>此处 xxx 是为了隐藏我的 ip</p><p>切入下目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ssh</span><br><span class="line">vim sshd_config</span><br></pre></td></tr></table></figure><p>随后将某些注销去掉并改值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Port 22 端口号，服务器和客户端相同即可</span><br><span class="line">ListenAddress 0.0.0.0   打开监听所有端口</span><br><span class="line">PermitRootLogin yes 允许远程客户进入根权限</span><br><span class="line">PublicAuthentication yes 打开密钥对认证模式</span><br><span class="line">AuthorizedKeysFile .ssh/yourname.pub 名称为yourname.pub的公钥放置处</span><br><span class="line">PasswordAuthentication yes 需要密码认证</span><br><span class="line">PermitEmptyPasswords yes 允许空密码</span><br></pre></td></tr></table></figure><h4 id="随后输入"><a class="markdownIt-Anchor" href="#随后输入">#</a> 随后输入</h4><p>a</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cp id_rsa.pub authorized_keys</span><br><span class="line">chmod 777 authorized_keys</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp authorized_keys a@b:~/.ssh/</span><br></pre></td></tr></table></figure><p>执行完后输入 b 的密码</p><p>b</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cp authorized_keys authorized_keys</span><br><span class="line">chmod 777 authorized_keys</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp authorized_keys b@a:~/.ssh/</span><br></pre></td></tr></table></figure><p>如果 scp authorized_keys b@a:~/.ssh/ 这行不起作用，手动更换。</p><p>将 a 和 b 生成的 authorized_keys 交换。</p><p>此时 a,b 以及搭建成为集群。</p><p>至此，开发环境搭建完毕，20min，如果是 openEuler, 此过程需要 n 小时，后续 copy 代码即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实验环境配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验环境配置&quot;&gt;#&lt;/a&gt; 实验环境配置&lt;/h3&gt;
&lt;p&gt;阅读实验手册发现，并没有地方需要使用 openEuler 20.03 操作系统&lt;/p&gt;
&lt;p&gt;如果硬用 openEul</summary>
      
    
    
    
    
    <category term="并行计算" scheme="https://flowerhai.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>微信搜索 一面</title>
    <link href="https://flowerhai.github.io/2023/05/18/mianshi/mian-3/"/>
    <id>https://flowerhai.github.io/2023/05/18/mianshi/mian-3/</id>
    <published>2023-05-18T08:27:54.000Z</published>
    <updated>2023-05-18T08:47:16.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信搜索-一面"><a class="markdownIt-Anchor" href="#微信搜索-一面">#</a> 微信搜索 一面</h2><h3 id="new和malloc区别"><a class="markdownIt-Anchor" href="#new和malloc区别">#</a> new 和 malloc 区别</h3><p>new/delete 是 C++ 运算符，可以重载，且不需要知道所需分配的空间，可自动确定</p><p>malloc/free 是 C 函数，且分配空间的时候需知道内存空间大小。</p><h4 id="如果new的内存用free会发生什么问题"><a class="markdownIt-Anchor" href="#如果new的内存用free会发生什么问题">#</a> 如果 new 的内存用 free，会发生什么问题？</h4><p>new () 函数实际过程中做了两步操作，第一步是分配内存空间，第二步是调用类的构造函数；delete () 也同样是两步，第一步是调用类的析构函数，第二步才是释放内存；而 malloc () 和 free () 仅仅是分配内存与释放内存操作；</p><p>那么如果通过 new 分配的内存，再用 free 去释放，就会少一步调用析构函数的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> *i;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A gouzao&quot;</span>&lt;&lt;<span class="built_in">endl</span>;i = new <span class="type">int</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    ~A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A xigou&quot;</span>&lt;&lt;<span class="built_in">endl</span>; delete i;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> c = <span class="number">0</span>)</span>  &#123;*i = c;&#125;</span><br><span class="line">    <span class="type">int</span> *<span class="title function_">get</span><span class="params">()</span> &#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = new A();</span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> *p = a-&gt;get();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    delete(a);</span><br><span class="line">    <span class="comment">//free(a);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 delete 输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A gouzao</span><br><span class="line">2</span><br><span class="line">A xigou</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>用 free 输出结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;cout&lt;&lt;<span class="string">&quot;A gouzao&quot;</span>&lt;&lt;endl;i = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;cout&lt;&lt;<span class="string">&quot;A xigou&quot;</span>&lt;&lt;endl; <span class="keyword">delete</span> i;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> c = <span class="number">0</span>)</span>  </span>&#123;*i = c;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> *p = a-&gt;<span class="built_in">get</span>();</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//delete(a);</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针和裸指针访问速度"><a class="markdownIt-Anchor" href="#智能指针和裸指针访问速度">#</a> 智能指针和裸指针访问速度</h3><p>智能指针和裸指针的访问速度在实际情况下通常是相同的。智能指针是一种高级抽象，它封装了裸指针，并提供了额外的功能，如自动内存管理和所有权转移。这些功能可能会导致轻微的性能开销，但在现代编译器和运行时环境下，这种开销通常是可以忽略不计的。</p><p>智能指针的主要优势在于安全性和便利性，它们可以帮助防止常见的内存错误，如空指针引用、重复释放和内存泄漏。通过使用智能指针，可以更轻松地编写安全、可维护的代码，因为它们提供了自动的资源管理。</p><p>然而，如果对性能要求非常高，或者在某些特殊情况下，使用裸指针可能更合适。裸指针直接访问内存，没有额外的开销，但也没有提供自动的内存管理或安全保证。在这种情况下，程序员需要自己负责确保内存的正确分配和释放，以及避免悬空指针和野指针等错误。</p><p>总的来说，智能指针和裸指针的访问速度在实际情况下通常没有显著的差异。选择使用哪种指针类型应该基于代码的安全性、可维护性和可读性等因素，而不是基于微小的性能差异。</p><h3 id="智能指针内部怎么实现的访问控制"><a class="markdownIt-Anchor" href="#智能指针内部怎么实现的访问控制">#</a> 智能指针内部怎么实现的访问控制</h3><ol><li>所有权管理：智能指针通常使用所有权概念来管理资源的生命周期。它们可以跟踪对象的所有权，并确保只有一个智能指针可以拥有资源。当智能指针超出范围时（例如，离开其作用域），它会自动释放资源。</li><li>引用计数：一种常见的智能指针实现是引用计数指针。它们在内部维护一个计数器，跟踪指向资源的引用数量。每当创建新的智能指针指向资源时，计数器递增；当智能指针被销毁或不再引用资源时，计数器递减。当计数器变为零时，智能指针可以自动释放资源。</li><li>生命周期跟踪：一些智能指针实现使用更复杂的生命周期跟踪机制。它们可以使用有向无环图（DAG）等数据结构来记录对象之间的依赖关系。这种方式可以检测和处理循环引用等情况，以避免内存泄漏。</li></ol><h3 id="linux排查性能"><a class="markdownIt-Anchor" href="#linux排查性能">#</a> linux 排查性能</h3><ol><li>CPU 使用率分析：使用工具如 top、htop 或 sar 来监视 CPU 使用率，识别是否存在 CPU 饱和的情况，以及确定哪些进程或线程消耗了大量的 CPU 资源。</li><li>内存使用分析：通过 free、top 或 vmstat 等工具来检查系统的内存使用情况。关注系统的内存消耗、交换空间使用情况以及内存泄漏等问题。</li><li>磁盘 I/O 分析：使用工具如 iostat、iotop 或 sar 来监测磁盘 I/O 活动。检查磁盘读写速度、I/O 等待时间以及是否存在磁盘瓶颈等问题。</li><li>网络使用分析：使用工具如 iftop、nethogs 或 sar 来监视网络使用情况，检查网络带宽使用率、连接数以及潜在的网络瓶颈。</li><li>进程和线程分析：使用工具如 ps、top 或 htop 来查看系统中运行的进程和线程。了解哪些进程或线程消耗了大量的资源，包括 CPU、内存和 I/O 等。</li><li>资源限制和调整：检查系统中是否存在资源限制，如 ulimit 或 sysctl 参数设置，以及适时调整这些限制以满足应用程序的需求。</li><li>日志分析：查看系统日志文件，如 /var/log/syslog 或应用程序的日志文件，以发现潜在的性能问题或错误信息。</li><li>使用性能分析工具：Linux 提供了一些强大的性能分析工具，如 perf、strace 和 tcpdump 等。这些工具可以用于跟踪系统调用、函数调用、网络流量等，以深入分析和解决性能问题。</li></ol><h3 id="如何处理惊群效应"><a class="markdownIt-Anchor" href="#如何处理惊群效应">#</a> 如何处理惊群效应</h3><ol><li>互斥锁：使用互斥锁来确保只有一个进程或线程可以访问资源。当一个进程或线程获得锁并访问资源时，其他等待的进程或线程将被阻塞，直到锁被释放。这样可以避免多个进程或线程同时竞争资源，减少惊群效应的发生。</li><li>信号量或条件变量：使用信号量或条件变量来实现资源的等待和唤醒机制。等待进程或线程会在资源不可用时等待，而唤醒进程或线程会在资源可用时通知其中一个进程或线程。这样可以避免同时唤醒所有等待的进程或线程，从而减少竞争和资源浪费。</li><li>优雅等待：在等待资源时，进程或线程可以选择进行优雅等待，而不是无限制地快速重试。可以使用一些延迟机制，例如指数退避策略，让进程或线程在等待资源时逐渐增加等待时间，以减少竞争和资源浪费。</li><li>预取或缓存：对于一些可预测的资源需求，可以使用预取或缓存机制来提前获取或缓存资源，以减少对共享资源的频繁竞争。这样可以减少等待资源的进程或线程的数量，从而降低惊群效应的发生。</li><li>负载均衡：在分布式系统中，可以使用负载均衡策略将请求分散到多个服务实例上，以避免单一资源点成为瓶颈。这样可以减少资源争夺和惊群效应的发生。</li></ol><h3 id="线程独占的资源有哪些"><a class="markdownIt-Anchor" href="#线程独占的资源有哪些">#</a> 线程独占的资源有哪些？</h3><ol><li>文件描述符：在某些操作系统中，打开的文件（例如磁盘文件、管道、套接字等）会被分配一个唯一的文件描述符。当一个线程打开文件并持有文件描述符时，其他线程无法直接使用该文件描述符，除非通过特定的机制（如共享文件描述符）进行共享。</li><li>锁和互斥量：线程可能会使用锁（如互斥量）来实现对共享资源的独占访问。当一个线程获取锁时，其他线程需要等待该锁的释放才能访问被保护的资源。</li><li>数据库连接：在多线程应用程序中，数据库连接通常被视为独占资源。当一个线程获得数据库连接时，其他线程需要等待连接的释放才能执行数据库操作。</li><li>共享内存段：共享内存是一种用于多个线程或进程之间共享数据的机制。当一个线程获得对共享内存段的访问权限时，其他线程需要等待访问权限的释放才能读取或写入共享内存。</li><li>设备资源：某些设备资源可能需要独占访问，例如打印机、串口、摄像头等。在多线程环境下，当一个线程使用设备时，其他线程需要等待设备的释放才能进行操作。</li></ol><h3 id="给多个文件每个文件都存储了id值每个文件都很大无法放进内存用户id的空间也很大也放不进内存如果统计出次数最多的top100"><a class="markdownIt-Anchor" href="#给多个文件每个文件都存储了id值每个文件都很大无法放进内存用户id的空间也很大也放不进内存如果统计出次数最多的top100">#</a> 给多个文件，每个文件都存储了 id 值，每个文件都很大，无法放进内存，用户 id 的空间也很大，也放不进内存，如果统计出次数最多的 top100</h3><ol><li>遍历每个文件，逐块读取数据。由于文件很大，无法一次性读取全部数据，因此需要分块读取。</li><li>对于每个文件块，使用合适的排序算法（如归并排序或快速排序）对数据进行排序。由于数据量较大，可能需要使用外部排序算法，将块内排序结果写入临时文件。</li><li>重复步骤 1 和 2，直到遍历完所有文件，并对每个文件块进行排序。</li><li>合并排序结果。在这个阶段，可以使用归并排序的思想，逐个读取已排序的块，合并它们并保持整体有序性。为了找出出现次数最多的 top100，可以使用一个适当的数据结构（如最小堆）来跟踪并更新当前的 top100。</li><li>最终，当合并排序完成后，得到的结果即为出现次数最多的 top100。</li></ol><h3 id="左值引用右值引用移动构造完美转发"><a class="markdownIt-Anchor" href="#左值引用右值引用移动构造完美转发">#</a> 左值引用，右值引用，移动构造，完美转发</h3><p>当谈到左值引用、右值引用、移动构造和完美转发时，这些概念通常与 C++ 语言中的引用和移动语义相关。下面是对这些概念的详细解释：</p><ol><li><p>左值引用（Lvalue Reference）：</p><ul><li><p>左值引用是 C++ 中的一种引用类型，用于引用具有名称和地址的左值对象。左值引用使用 <code>&amp;</code>  符号声明，并且必须绑定到具有相同类型的左值对象。</p></li><li><p>左值引用提供了对对象的别名，并允许对对象进行修改。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeint x = 10;</span><br><span class="line">int&amp; ref = x;  // 左值引用绑定到左值对象 x</span><br></pre></td></tr></table></figure></li></ul></li><li><p>右值引用（Rvalue Reference）：</p><ul><li><p>右值引用是 C++11 引入的新特性，用于引用临时对象、无名称的对象或将要销毁的对象（右值）。</p></li><li><p>右值引用使用 <code>&amp;&amp;</code>  符号声明，并且必须绑定到右值表达式或右值对象。</p></li><li><p>右值引用支持移动语义，可以在移动语义中将资源从一个对象（例如临时对象）转移到另一个对象，而无需进行昂贵的复制操作。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">int&amp;&amp; rref = 42;  // 右值引用绑定到右值表达式</span><br></pre></td></tr></table></figure></li></ul></li><li><p>移动构造（Move Constructor）：</p><ul><li><p>移动构造函数是一种特殊的构造函数，用于从一个右值引用对象中 “移动” 资源（例如堆内存、文件句柄等）到另一个对象，而不是进行深层的拷贝。</p></li><li><p>移动构造函数通常采用右值引用作为参数，并通过将资源的所有权转移给新对象来实现高效的移动操作。</p></li><li><p>移动构造函数通常与移动语义一起使用，以避免不必要的复制操作并提高性能。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codeclass MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">  // 移动构造函数</span><br><span class="line">  MyClass(MyClass&amp;&amp; other) &#123;</span><br><span class="line">    // 从 other 移动资源到当前对象</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>完美转发（Perfect Forwarding）：</p><ul><li><p>完美转发是一种通过保留函数参数的值类别（左值或右值）来转发函数调用的机制。</p></li><li><p>完美转发通常使用模板和引用折叠规则来实现，以确保函数调用中的参数类型和值类别与原始调用保持一致。</p></li><li><p>完美转发可以用于实现通用的转发函数，将参数传递给其他函数，同时保持原始调用的值类别。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codetemplate &lt;typename T&gt;</span><br><span class="line">void forwardFunction(T&amp;&amp; arg) &#123;</span><br><span class="line">  otherFunction(std::forward&lt;T&gt;(arg));  // 完美转发 arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>以上是对左值引用、右值引用、移动构造和完美转发的详细解释。这些概念在 C++ 中提供了更灵活和高效的资源管理和函数调用机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*a)[10] int (*a[10])(int) int(*a)(int)分别是什么</span><br></pre></td></tr></table></figure><ul><li><code>int (*a)[10]</code> : 这是一个指针  <code>a</code> ，指向一个包含 10 个整数的数组。它的声明中使用了括号来明确指针的优先级，表示  <code>a</code>  是一个指针，它指向一个包含 10 个整数的数组。</li><li><code>int (*a[10])(int)</code> : 这是一个包含 10 个元素的数组  <code>a</code> ，每个元素都是一个函数指针，指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。它的声明中使用了括号来明确指针的优先级和数组的大小。</li><li><code>int (*a)(int)</code> : 这是一个指针  <code>a</code> ，指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。它的声明中没有使用括号，所以  <code>a</code>  是一个指针，指向一个函数。</li></ul><p>这些声明可以有点复杂，但我们可以通过拆解它们来理解其含义。注意到，声明中的  <code>(*a)</code>  表示  <code>a</code>  是一个指针。接着，我们可以根据  <code>*a</code>  的部分进一步理解其指向的类型。在第一个例子中， <code>*a</code>  是一个指向包含 10 个整数的数组的指针。在第二个例子中， <code>*a</code>  是一个指向以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数的指针。而在第三个例子中， <code>*a</code>  是一个指向以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数的指针。</p><p>综上所述，可以总结如下：</p><ul><li><code>int (*a)[10]</code> ： <code>a</code>  是一个指针，指向一个包含 10 个整数的数组。</li><li><code>int (*a[10])(int)</code> ： <code>a</code>  是一个包含 10 个元素的函数指针数组，每个元素都指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。</li><li><code>int (*a)(int)</code> ： <code>a</code>  是一个指针，指向一个以  <code>int</code>  为参数类型并返回  <code>int</code>  的函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微信搜索-一面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信搜索-一面&quot;&gt;#&lt;/a&gt; 微信搜索 一面&lt;/h2&gt;
&lt;h3 id=&quot;new和malloc区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#n</summary>
      
    
    
    
    
    <category term="面试总结" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>快手一面补充</title>
    <link href="https://flowerhai.github.io/2023/05/18/mianshi/mian-2/"/>
    <id>https://flowerhai.github.io/2023/05/18/mianshi/mian-2/</id>
    <published>2023-05-18T07:51:55.000Z</published>
    <updated>2023-05-18T07:52:44.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快手一面补充"><a class="markdownIt-Anchor" href="#快手一面补充">#</a> 快手一面补充</h2><h3 id="内存对齐"><a class="markdownIt-Anchor" href="#内存对齐">#</a> 内存对齐</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">char</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>int 占 4 个字节，char 占 1 个字节，按理说应该是 5 字节，实际是 8 字节，这就是发生了内存对齐。</p><h5 id="为什么要内存对齐"><a class="markdownIt-Anchor" href="#为什么要内存对齐">#</a> 为什么要内存对齐</h5><ol><li><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，四字节，8 字节，16 字节甚至 32 字节为单位来存取内存，我们将上述 这些存取单位称为内存存取粒度.</p><p>现在考虑 4 字节存取粒度的处理器取 int 类型变量（32 位系统），该处理器只能从地址为 4 的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个 int 变量存放在从地址 1 开始的联系四个字节地址中，该处理器去取数据时，要先从 0 地址开始读取第一个 4 字节块，剔除不想要的字节（0 地址）, 然后从地址 4 开始读取下一个 4 字节块，同样剔除不要的数据（5，6，7 地址）, 最后留下的两块数据合并放入寄存器。这需要做很多工作.</p><p><img src="https://pic3.zhimg.com/80/v2-3f40af513a94901b36ceb5387982277e_720w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-3f40af513a94901b36ceb5387982277e_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>现在有了内存对齐的，int 类型数据只能存放在按照对齐规则的内存中，比如说 0 地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p><p><img src="https://pic1.zhimg.com/80/v2-361e2d16876ce8383c9e6ea2dca34474_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-361e2d16876ce8383c9e6ea2dca34474_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p></li></ol><h4 id="内存对齐规则"><a class="markdownIt-Anchor" href="#内存对齐规则">#</a> 内存对齐规则</h4><p>每个特定平台上的编译器都有自己的默认 “对齐系数”（也叫对齐模数）。gcc 中默认 #pragma pack (4)，可以通过预编译命令 #pragma pack (n)，n = 1,2,4,8,16 来改变这一系数。</p><p>有效对其值：是给定值 #pragma pack (n) 和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><p>(1) 结构体第一个成员的<strong>偏移量（offset）<strong>为 0，以后每个成员相对于结构体首地址的 offset 都是</strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(3) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p>下面给出几个例子以便于理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="type">char</span> c2;  </span><br><span class="line">&#125;x2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1;  </span><br><span class="line">    <span class="type">char</span> c2; </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">&#125;x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上测试都是在 Linux 环境下进行的，linux 下默认 #pragma pack (4)，且结构体中最长的数据类型为 4 个字节，所以有效对齐单位为 4 字节，下面根据上面所说的规则以 s2 来分析其内存布局：</p><p>首先使用规则 1，对成员变量进行对齐：</p><p>sizeof (c1) = 1 &lt;= 4 (有效对齐位)，按照 1 字节对齐，占用第 0 单元；</p><p>sizeof (i) = 4 &lt;= 4 (有效对齐位)，相对于结构体首地址的偏移要为 4 的倍数，占用第 4，5，6，7 单元；</p><p>sizeof (c2) = 1 &lt;= 4 (有效对齐位)，相对于结构体首地址的偏移要为 1 的倍数，占用第 8 单元；</p><p>然后使用规则 2，对结构体整体进行对齐：</p><p>s2 中变量 i 占用内存最大占 4 字节，而有效对齐单位也为 4 字节，两者较小值就是 4 字节。因此整体也是按照 4 字节对齐。由规则 1 得到 s2 占 9 个字节，此处再按照规则 2 进行整体的 4 字节对齐，所以整个结构体占用 12 个字节。</p><p>根据上面的分析，不难得出上面例子三个结构体的内存布局如下：</p><p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="pragma-packn"><a class="markdownIt-Anchor" href="#pragma-packn">#</a> *<strong>#pragma pack(n)*</strong></h4><p>不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令 #pragma pack (n), n= 1,2,4,8,16 来改变对齐系数。</p><p>例如，对于上个例子的三个结构体，如果前面加上 #pragma pack (1)，那么此时有效对齐值为 1 字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是 6 字节。</p><p><img src="https://pic2.zhimg.com/80/v2-672ebe0ccc1430adbda00dfd7abc0375_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-672ebe0ccc1430adbda00dfd7abc0375_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>如果前面加上 #pragma pack (2)，有效对齐值为 2 字节，此时根据对齐规则，三个结构体的大小应为 6,8,6。内存分布图如下：</p><p><img src="https://pic4.zhimg.com/80/v2-1c35bc20c76d85d07855901964488637_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-1c35bc20c76d85d07855901964488637_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>对内存对齐有了全面的认识和了解，在以后的编码中定义结构体时需要考虑成员变量定义的先后顺序了。</p><h3 id="编译的几个阶段和作用"><a class="markdownIt-Anchor" href="#编译的几个阶段和作用">#</a> 编译的几个阶段和作用</h3><p>GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程分为四个阶段：<strong>预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）、链接（Linking）</strong>。执行这四个阶段的程序（<strong>预处理器、编译器、汇编器、和链接器</strong>）一起构成了编译系统。</p><p><img src="https://pic3.zhimg.com/v2-b9e8babf753b1691039458592667121a_r.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/v2-b9e8babf753b1691039458592667121a_r.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="预处理阶段"><a class="markdownIt-Anchor" href="#预处理阶段">#</a> <strong>预处理阶段：</strong></h4><ol><li>预处理器（cpp）将所有的 #define 删除，并且展开所有的宏定义。</li><li>处理所有的条件预编译指令，比如 #if、#ifdef、#elif、#else、#endif 等。</li><li>处理 #include 预编译指令，将被包含的文件直接插入到预编译指令的位置。</li><li>删除所有的注释。</li><li>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。</li><li>保留所有的 #pragma 编译器指令，因为编译器需要使用它们。</li><li>使用 <code>gcc -E hello.c -o hello.i</code>  命令来进行预处理， 预处理得到的另一个程序通常是以.i 作为文件扩展名。</li></ol><h4 id="编译阶段"><a class="markdownIt-Anchor" href="#编译阶段">#</a> <strong>编译阶段：</strong></h4><p>编译器（ccl）将预处理完的文本文件 hello.i 进行一系列的词法分析、语法分析、语义分析和优化，翻译成文本文件 hello.s，它包含一个汇编语言程序。如下所示</p><p><img src="https://pic4.zhimg.com/80/v2-a962deac411dedc572d02affa2d24f0f_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-a962deac411dedc572d02affa2d24f0f_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>该程序包含函数 main 的定义，2-7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。</p><p>汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。</p><p>编译过程可分为 6 步：<strong>扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化</strong>。</p><ol><li>词法分析：扫描器（Scanner）将源代的字符序列分割成一系列的记号（Token）。lex 工具可实现词法扫描。</li><li>语法分析：语法分析器将记号（Token）产生语法树（Syntax Tree）。yacc 工具可实现语法分析 (yacc: Yet Another Compiler Compiler)。</li><li>语义分析：静态语义（在编译器可以确定的语义）、动态语义（只能在运行期才能确定的语义）。</li><li>源代码优化：源代码优化器 (Source Code Optimizer)，将整个语法书转化为中间代码（Intermediate Code）（中间代码是与目标机器和运行环境无关的）。中间代码使得编译器被分为前端和后端。编译器前端负责产生机器无关的中间代码；编译器后端将中间代码转化为目标机器代码。</li><li>目标代码生成：代码生成器 (Code Generator).</li><li>目标代码优化：目标代码优化器 (Target Code Optimizer)。</li></ol><h4 id="汇编阶段"><a class="markdownIt-Anchor" href="#汇编阶段">#</a> <strong>汇编阶段：</strong></h4><p>汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>的格式，并将结果保存在目标文件 hello.o 中，hello.o 是一个二进制文件。</p><h4 id="链接阶段"><a class="markdownIt-Anchor" href="#链接阶段">#</a> <strong>链接阶段：</strong></h4><p>hello 程序调用了 printf 函数，它存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。连接器（ld）就负责处理这种合并。结果就得到了 hello 文件，它是一个<strong>可执行目标文件</strong>（或者称为<strong>可执行文件</strong>），可以被加载到内存中，由系统执行。（链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件）。</p><h4 id="链接"><a class="markdownIt-Anchor" href="#链接">#</a> <strong>链接</strong></h4><h4 id="简述"><a class="markdownIt-Anchor" href="#简述">#</a> <strong>简述：</strong></h4><p>链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于<strong>编译时（compile time）</strong>，也就是在源代码被翻译成机器代码时；也可以执行于<strong>加载时（load time）</strong>，也就是在程序被<strong>加载器（loader）<strong>加载到内存并执行时；甚至执行于</strong>运行时（run time）</strong>，也就是由应用程序来执行。链接是由叫 ** 链接器（linker）** 的程序自动执行的。</p><h4 id="意义"><a class="markdownIt-Anchor" href="#意义">#</a> <strong>意义：</strong></h4><p>链接使得 ** 分离编译（separate compilation）** 成为可能，我们不用将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解成为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其他文件。</p><h3 id="select和epoll的区别以及优缺点"><a class="markdownIt-Anchor" href="#select和epoll的区别以及优缺点">#</a> select 和 epoll 的区别以及优缺点</h3><p>select 单个进程可监视的 fd 数量受到限制，epoll 和 select 都可实现同时监听多个 I/O 事件的状态。</p><ul><li>select 基于轮询机制</li><li>epoll 基于 os 支持的 I/O 通知机制。epoll 支持水平触发和边沿触发两种模式。</li></ul><h3 id="epoll的底层实现"><a class="markdownIt-Anchor" href="#epoll的底层实现">#</a> epoll 的底层实现</h3><p><a href="https://blog.csdn.net/hjlogzw/article/details/122953715">https://blog.csdn.net/hjlogzw/article/details/122953715</a></p><p>有空了读下源码吧，底层是用了 mmap ，这倒是没问题。</p><h3 id="静态链接和动态链接"><a class="markdownIt-Anchor" href="#静态链接和动态链接">#</a> 静态链接和动态链接</h3><p>静态链接和动态链接两者最大的区别就在于链接的时机不一样，静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时，下面来详细介绍这两种链接方式。</p><p>一、静态链接<br> 1. 为什么要进行静态链接<br>在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个 *.c 文件会形成一个 *.o 文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接</p><p>2. 静态链接的原理<br>由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。</p><p>​    以下面这个图来简单说明一下从静态链接到可执行文件的过程，根据在源文件中包含的头文件和程序中使用到的库函数，如 stdio.h 中定义的 printf () 函数，在 libc.a 中找到目标文件 printf.o (这里暂且不考虑 printf () 函数的依赖关系)，然后将这个目标文件和我们 hello.o 这个文件进行链接形成我们的可执行文件。</p><p><img src="https://img-blog.csdn.net/20180505235327609" class="lazyload placeholder" data-srcset="https://img-blog.csdn.net/20180505235327609" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>​    这里有一个小问题，就是从上面的图中可以看到静态运行库里面的一个目标文件只包含一个函数，如 libc.a 里面的 printf.o 只有 printf () 函数，strlen.o 里面只有 strlen () 函数。</p><p>​    我们知道，链接器在链接静态链接库的时候是以目标文件为单位的。比如我们引用了静态库中的 printf () 函数，那么链接器就会把库中包含 printf () 函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。<br>3. 静态链接的优缺点<br>​    静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了 printf () 函数，则这多个程序中都含有 printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p><p>二、动态链接<br> 1. 为什么会出现动态链接<br>动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。</p><p>2. 动态链接的原理<br>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：</p><p>​    假设现在有两个程序 program1.o 和 program2.o，这两者共用同一个库 lib.o, 假设首先运行程序 program1，系统首先加载 program1.o，当系统发现 program1.o 中用到了 lib.o，即 program1.o 依赖于 lib.o，那么系统接着加载 lib.o，如果 program1.o 和 lib.o 还依赖于其他目标文件，则依次全部加载到内存中。当 program2 运行时，同样的加载 program2.o，然后发现 program2.o 依赖于 lib.o，但是此时 lib.o 已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的 lib.o 映射到 program2 的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。</p><p>3. 动态链接的优缺点<br>动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p><p>​    据估算，动态链接和静态链接相比，性能损失大约在 5% 以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。</p><p>4. 动态链接地址是如何重定位的呢？<br>前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。</p><p>参考链接：</p><p><a href="http://www.cnblogs.com/cyyljw/p">www.cnblogs.com/cyyljw/p</a></p><p><a href="https://zhuanlan.zhihu.com/p/105936114">https://zhuanlan.zhihu.com/p/105936114</a></p><p><a href="https://zhuanlan.zhihu.com/p/30007037">https://zhuanlan.zhihu.com/p/30007037</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快手一面补充&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#快手一面补充&quot;&gt;#&lt;/a&gt; 快手一面补充&lt;/h2&gt;
&lt;h3 id=&quot;内存对齐&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存对齐&quot;&gt;#&lt;/a&gt; </summary>
      
    
    
    
    
    <category term="面试总结" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>快手一面</title>
    <link href="https://flowerhai.github.io/2023/05/17/mianshi/mian-1/"/>
    <id>https://flowerhai.github.io/2023/05/17/mianshi/mian-1/</id>
    <published>2023-05-17T14:27:27.000Z</published>
    <updated>2023-05-17T14:28:04.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经总结-1"><a class="markdownIt-Anchor" href="#面经总结-1">#</a> 面经总结 - 1</h1><h3 id="快手一面"><a class="markdownIt-Anchor" href="#快手一面">#</a> 快手一面</h3><h4 id="虚函数和多态的实现原理"><a class="markdownIt-Anchor" href="#虚函数和多态的实现原理">#</a> 虚函数和多态的实现原理</h4><p>多态主要就是靠重载和重写来实现的。</p><p>重写，主要依赖与编译器，静态多态。</p><p>因为编译器在底层会把参数也加到函数名后面。</p><p>重载，主要是靠虚表来实现。</p><p>写一个简单的程序，用 gdb 调试验证以下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;int&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(<span class="type">float</span> a)</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;float&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B-&gt;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;C-&gt;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hh</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;C-&gt;B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A aa;</span><br><span class="line">    aa.<span class="built_in">play</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">3.1</span>;</span><br><span class="line">    aa.<span class="built_in">play</span>(c);</span><br><span class="line">    aa.<span class="built_in">hhh</span>();</span><br><span class="line">    B bb;</span><br><span class="line">    bb.<span class="built_in">hhh</span>();</span><br><span class="line">    bb.<span class="built_in">hh</span>();</span><br><span class="line">    C cc;</span><br><span class="line">    cc.<span class="built_in">hhh</span>();</span><br><span class="line">    cc.<span class="built_in">hh</span>();</span><br><span class="line">    cc.<span class="built_in">h</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p aa</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;_vptr.A = 0x555555557d20 &lt;vtable <span class="keyword">for</span> A+16&gt;&#125;</span></span><br><span class="line">(gdb) p bb</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = &#123;&lt;A&gt; = &#123;_vptr.A = 0x555555557d00 &lt;vtable <span class="keyword">for</span> B+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br><span class="line">(gdb) p cc</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = &#123;&lt;A&gt; = &#123;_vptr.A = 0x555555557cd8 &lt;vtable <span class="keyword">for</span> C+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br><span class="line">(gdb) info line 5</span><br><span class="line">Line 5 of &quot;hh.cpp&quot; starts at address 0x555555555308 &lt;_ZN1A4playEi&gt; and ends at 0x55555555531b &lt;_ZN1A4playEi+19&gt;.</span><br><span class="line">(gdb) i line 6</span><br><span class="line">Line 6 of &quot;hh.cpp&quot; starts at address 0x55555555534a &lt;_ZN1A4playEf&gt; and ends at 0x55555555535f &lt;_ZN1A4playEf+21&gt;.</span><br><span class="line">(gdb) i line 8</span><br><span class="line">Line 8 of &quot;hh.cpp&quot; starts at address 0x55555555538e &lt;_ZN1A3hhhEv&gt; and ends at 0x55555555539e &lt;_ZN1A3hhhEv+16&gt;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看这里</p><p>关于重载我们可以看到一个是 playEi 一个是 playEf， 名字不一样，实现重写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info line 5</span><br><span class="line">Line 5 of &quot;hh.cpp&quot; starts at address 0x555555555308 &lt;_ZN1A4playEi&gt; and ends at 0x55555555531b &lt;_ZN1A4playEi+19&gt;.</span><br><span class="line">(gdb) i line 6</span><br><span class="line">Line 6 of &quot;hh.cpp&quot; starts at address 0x55555555534a &lt;_ZN1A4playEf&gt; and ends at 0x55555555535f &lt;_ZN1A4playEf+21&gt;.</span><br></pre></td></tr></table></figure><p>关于虚函数重载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p cc</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">11 = &#123;&lt;A&gt; = &#123;_vptr.A = 0x555555557cd8 &lt;vtable <span class="keyword">for</span> C+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br><span class="line">(gdb)  p /a *(void**)0x555555557cd8@2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">12 = &#123;0x555555555448 &lt;_ZN1C3hhhEv&gt;, 0x555555555486 &lt;_ZN1C2hhEv&gt;&#125;</span></span><br><span class="line">(gdb)  p /a *(void**)0x555555557cd8@1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">13 = &#123;0x555555555448 &lt;_ZN1C3hhhEv&gt;&#125;</span></span><br><span class="line">(gdb)  p /a *(void**)0x555555557cd8@3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">14 = &#123;0x555555555448 &lt;_ZN1C3hhhEv&gt;, 0x555555555486 &lt;_ZN1C2hhEv&gt;, 0x5555555554c4 &lt;_ZN1C1hEv&gt;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="智能指针的类型和用法"><a class="markdownIt-Anchor" href="#智能指针的类型和用法">#</a> 智能指针的类型和用法</h4><p>unique_ptr 独占，禁止右值引用和拷贝复制构造</p><p>解决该问题可以用移动语义 move</p><p>shared_ptr 带计数</p><p>weak_ptr 解决 shared_ptr 循环引用问题</p><p>何为循环引用？</p><p>两个对象互相使用一个 shared_ptr 成员变量指向对方。这样会引发一个问题，其中任何一个对象的引用计数都为 2。析构时两个资源引⽤计数会减⼀，于是两者引⽤计数还是大于 0，导致跳出函数时资源没有被释放（离开作用域时两个对象的析构函数没有被调⽤）</p><p>weak_ptr 是如何解决这个问题的？</p><p>因为 weak_ptr 指向对方，并不会增加循环引用，所以会解决这个问题。</p><h4 id="内存对齐"><a class="markdownIt-Anchor" href="#内存对齐">#</a> 内存对齐</h4><p>不熟悉，后面补一下</p><h4 id="编译的几个阶段和作用"><a class="markdownIt-Anchor" href="#编译的几个阶段和作用">#</a> 编译的几个阶段和作用</h4><p>预编译</p><p>编译</p><p>汇编</p><p>连接</p><h4 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数">#</a> 内联函数</h4><p>内联函数不会给函数开辟新的栈帧，省去了开辟栈帧回收栈帧的空间，在需要重复调用短小函数的时候能够缩短运行时间。</p><h4 id="socket编程基本流程"><a class="markdownIt-Anchor" href="#socket编程基本流程">#</a> socket 编程基本流程</h4><p>这个需要分为服务端和客户段</p><p>TCP 下如下，UDP 类似</p><p>服务端：</p><ul><li>加载套接字库</li><li>创建套接字（socket）</li><li>将套接字绑定到一个本地地址和端口上（bind）</li><li>将套接字设为监听模式，准备接收客户请求（listen）</li><li>等待客户请求到来；当请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept）</li><li>用返回的套接字和客户端进行通信（send/recv）</li><li>返回，等待另一客户请求。</li><li>关闭套接字。</li></ul><p>客户段：</p><ul><li>加载套接字库</li><li>创建套接字（socket）</li><li>向服务器发出连接请求（connect）</li><li>和服务器端进行通信（send/recv）</li><li>关闭套接字。</li></ul><h4 id="tcp和udp的区别"><a class="markdownIt-Anchor" href="#tcp和udp的区别">#</a> tcp 和 udp 的区别</h4><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个<a href="https://www.zhihu.com/search?q=%E7%AB%AF%E7%82%B9&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">端点</a>。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和<a href="https://www.zhihu.com/search?q=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">流量控制机制</a>，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是  <code>20</code>  个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是<a href="https://www.zhihu.com/search?q=%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">流式传输</a>，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP <a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%8C%85&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2619299969%7D">数据包</a>，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><h4 id="tcp流量控制和拥塞控制的实现"><a class="markdownIt-Anchor" href="#tcp流量控制和拥塞控制的实现">#</a> tcp 流量控制和拥塞控制的实现</h4><p>滑动窗口 慢启动 拥塞避免 快重传 快恢复</p><h4 id="select和epoll的区别以及优缺点"><a class="markdownIt-Anchor" href="#select和epoll的区别以及优缺点">#</a> select 和 epoll 的区别以及优缺点</h4><p>select 每次只能注册一个时间</p><p>epoll 每次可以拿一个事件组，更加高校</p><h2 id="epoll的具体底层实现"><a class="markdownIt-Anchor" href="#epoll的具体底层实现">#</a> epoll 的具体底层实现</h2><p><a href="https://blog.csdn.net/hjlogzw/article/details/122953715">https://blog.csdn.net/hjlogzw/article/details/122953715</a></p><h4 id="delete操作后指针指向内存区的数据会被清掉吗"><a class="markdownIt-Anchor" href="#delete操作后指针指向内存区的数据会被清掉吗">#</a> delete 操作后指针指向内存区的数据会被清掉吗？</h4><p>不会立刻清除，会等待一段时间</p><h4 id="4种隔离级别以及含义"><a class="markdownIt-Anchor" href="#4种隔离级别以及含义">#</a> 4 种隔离级别以及含义？</h4><p><a href="https://zhuanlan.zhihu.com/p/76743929">https://zhuanlan.zhihu.com/p/76743929</a></p><h4 id="静态链接和动态链接"><a class="markdownIt-Anchor" href="#静态链接和动态链接">#</a> 静态链接和动态链接</h4><p><a href="https://zhuanlan.zhihu.com/p/105936114">https://zhuanlan.zhihu.com/p/105936114</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面经总结-1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面经总结-1&quot;&gt;#&lt;/a&gt; 面经总结 - 1&lt;/h1&gt;
&lt;h3 id=&quot;快手一面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#快手一面&quot;&gt;#&lt;/a</summary>
      
    
    
    
    
    <category term="面试总结" scheme="https://flowerhai.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>图床项目整体构思</title>
    <link href="https://flowerhai.github.io/2023/05/17/picturebed/all/"/>
    <id>https://flowerhai.github.io/2023/05/17/picturebed/all/</id>
    <published>2023-05-17T02:58:40.000Z</published>
    <updated>2023-05-17T02:59:33.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图床项目"><a class="markdownIt-Anchor" href="#图床项目">#</a> 图床项目</h2><p>准备自己搭一个图床，平时自己的网站老拿别人的图床用，算什么程序猿！</p><p>正好也算是自己秋招的一个项目吧。</p><h4 id="构思"><a class="markdownIt-Anchor" href="#构思">#</a> 构思</h4><p>技术点：</p><p>socket 网络编程</p><p>HTTP 解析</p><p>线程池</p><p>epoll</p><p>图片显示用随机数就可以解决 (当然图片命名得用一定范围内的整数)</p><h4 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路">#</a> 大致思路</h4><p>ECS 上运行运行一个服务端程序，监听 443 端口 (随便写的一个)，一旦监听到有 https 连接，用状态机解析报文，随后生成一个随机数拼接成图片路径返回一个 https 连接。</p><p>考虑岛图床肯定是一个多线程项目，为了提高项目的稳定性以及并发性，可以使用 epoll+thread_pool，再加一个定时器，在返回资源后的 3s 后断开连接，为了能够更加方便的维护项目，可以再使用单例模式设计一个日志系统。</p><p>完美！就先这样，慢慢来，想到什么了再继续完善。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图床项目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图床项目&quot;&gt;#&lt;/a&gt; 图床项目&lt;/h2&gt;
&lt;p&gt;准备自己搭一个图床，平时自己的网站老拿别人的图床用，算什么程序猿！&lt;/p&gt;
&lt;p&gt;正好也算是自己秋招的一个项目吧。&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    
    <category term="图床" scheme="https://flowerhai.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab:system calls</title>
    <link href="https://flowerhai.github.io/2023/05/17/s081/lab2/"/>
    <id>https://flowerhai.github.io/2023/05/17/s081/lab2/</id>
    <published>2023-05-17T02:57:06.000Z</published>
    <updated>2023-05-17T02:58:05.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-system-calls"><a class="markdownIt-Anchor" href="#lab-system-calls">#</a> Lab: system calls</h1><p>这个实验还蛮搞的 hh，关于最后的输出时候的 syscalls [p-&gt;trapframe-&gt;a7] 和示例并不一样，但是能完整通过测试，猜测是因为我的操作系统位数和要求不一样，因此寄存器的值达不到。</p><h3 id="tracing"><a class="markdownIt-Anchor" href="#tracing">#</a> tracing</h3><p>关于系统调用的流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user/user.h:用户态程序调用跳板函数 trace()</span><br><span class="line">user/usys.S:跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态</span><br><span class="line">kernel/syscall.c到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。</span><br><span class="line">kernel/syscall.csyscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。</span><br><span class="line">kernel/sysproc.c到达 sys_trace() 函数，执行具体内核操作</span><br></pre></td></tr></table></figure><p>usys.S 中部分命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sysinfo</span><br><span class="line">sysinfo:</span><br><span class="line"> li a7, SYS_sysinfo</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>仅拿 tarce 来说，首先 global 声明全局可见，然后将 SYS_trace 加载到 a7 中，ecall 会将系统调用值转移到 a0</p><p>这么繁琐的调用流程的主要目的是实现用户态和内核态的良好隔离。</p><p>并且由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。</p><p>同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。（在本 lab 第二个实验会用到）</p><p>关于如何注册一个系统调用在此不做过多说明，只说关键函数的设计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line">  myproc()-&gt;syscall_trace = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>查看</mtext><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>t</mi><mtext>以及</mtext><mi>a</mi><mi>r</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>w</mi><mtext>我们可以知道</mtext><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>t</mi><mtext>函数的作用就是返回</mtext><msub><mi>a</mi><mi>n</mi></msub><mtext>寄存器对应的值</mtext></mrow><annotation encoding="application/x-tex">查看argint以及argraw我们可以知道argint函数的作用就是返回a_{n}寄存器对应的值</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">看</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">及</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">道</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">返</span><span class="mord cjk_fallback">回</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span></span></span></span></span></p><p>sys_trace 的作用便是获取 a0 寄存器的值，因此便如上述所写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在 proc.c 中，在注册一个 proc 的时候，将其 mask 置 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line">  p-&gt;syscall_trace = <span class="number">0</span>; <span class="comment">//add here</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork 在 fork 的时候也需要保持父子进程 mask 相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *np;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = <span class="built_in">allocproc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">uvmcopy</span>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(np);</span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = <span class="built_in">filedup</span>(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = <span class="built_in">idup</span>(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(np-&gt;name, p-&gt;name, <span class="built_in">sizeof</span>(p-&gt;name));</span><br><span class="line">  np-&gt;syscall_trace = p-&gt;syscall_trace; <span class="comment">//add here</span></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;wait_lock);</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  <span class="built_in">release</span>(&amp;wait_lock);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;np-&gt;lock);</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后便是 syscall，仅需在原有基础上稍微添加以下即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;syscall_trace &amp; (<span class="number">1</span> &lt;&lt; num)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0); <span class="comment">// syscall_names[num]: 从 syscall 编号到 syscall 名的映射表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sysinfo"><a class="markdownIt-Anchor" href="#sysinfo">#</a> Sysinfo</h3><p>注册流程和上述基本一致</p><p>sys_info 设计</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;addr);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sinfo</span>;</span></span><br><span class="line">  sinfo.freemem = freemem_size();</span><br><span class="line">  sinfo.nproc = count_proc();</span><br><span class="line">  <span class="keyword">if</span> (copyout(myproc()-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;sinfo, <span class="keyword">sizeof</span>(sinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>freemem_size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">freemem_size</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;kmem.lock); <span class="comment">// prevent race condition</span></span><br><span class="line"></span><br><span class="line">  uint64 size = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    size++;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> size * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>count_proc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">count_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc[i].state != UNUSED) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="result"><a class="markdownIt-Anchor" href="#result">#</a> result</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./grade-lab-syscall</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">== Test trace 32 grep == trace 32 grep: OK (3.0s) </span><br><span class="line">== Test trace all grep == trace all grep: OK (2.2s) </span><br><span class="line">== Test trace nothing == trace nothing: OK (2.2s) </span><br><span class="line">== Test trace children == trace children: OK (95.3s) </span><br><span class="line">== Test sysinfotest == sysinfotest: OK (9.2s) </span><br></pre></td></tr></table></figure><p>完美解决，下一个！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-system-calls&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-system-calls&quot;&gt;#&lt;/a&gt; Lab: system calls&lt;/h1&gt;
&lt;p&gt;这个实验还蛮搞的 hh，关于最后的输出时候的 sysca</summary>
      
    
    
    
    
    <category term="MIT6.S081" scheme="https://flowerhai.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>day25</title>
    <link href="https://flowerhai.github.io/2023/05/15/shuati/day25/"/>
    <id>https://flowerhai.github.io/2023/05/15/shuati/day25/</id>
    <published>2023-05-15T10:56:44.000Z</published>
    <updated>2023-05-15T10:57:40.142Z</updated>
    
    <content type="html"><![CDATA[<p>让网站更适合秋招好看一点吧，刷题记录本地有就行了。<br>不再上传。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;让网站更适合秋招好看一点吧，刷题记录本地有就行了。&lt;br&gt;
不再上传。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab:Xv6 and Unix utilities</title>
    <link href="https://flowerhai.github.io/2023/05/15/s081/lab1/"/>
    <id>https://flowerhai.github.io/2023/05/15/s081/lab1/</id>
    <published>2023-05-15T10:50:27.000Z</published>
    <updated>2023-05-15T10:51:22.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-xv6-and-unix-utilities"><a class="markdownIt-Anchor" href="#lab-xv6-and-unix-utilities">#</a> Lab: Xv6 and Unix utilities</h1><h4 id="sleep"><a class="markdownIt-Anchor" href="#sleep">#</a> sleep</h4><p>函数的设计还是很简单的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: number should be given...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  sleep(n);</span><br><span class="line">  <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来刚开始写的是 return 0; 通过样例是没问题的，但是编译 OS 的时候再调用无法正常退出。</p><h3 id="查阅资料发现return和exit的区别还是蛮大的"><a class="markdownIt-Anchor" href="#查阅资料发现return和exit的区别还是蛮大的">#</a> 查阅资料发现，return 和 exit 的区别还是蛮大的。</h3><ol><li>exit 用于结束正在运行的整个程序，它将参数返回给 OS，把控制权交给操作系统；而 return 是退出当前函数，返回函数值，把控制权交给调用函数。</li><li>exit 是系统调用级别，它表示一个进程的结束；而 return 是语言级别的，它表示调用堆栈的返回。</li><li>在 main 函数结束时，会隐式地调用 exit 函数，所以一般程序执行到 main () 结尾时，则结束主进程。exit 将删除进程使用的内存空间，同时把错误信息返回给父进程。</li><li>void exit (int status); 一般 status 为 0，表示正常退出，非 0 表示非正常退出。</li></ol><h4 id="1-exit函数和return函数的主要区别是"><a class="markdownIt-Anchor" href="#1-exit函数和return函数的主要区别是">#</a> 1、exit 函数和 return 函数的主要区别是：</h4><p>1）exit 用于在程序运行的过程中随时结束程序，其参数是返回给 OS 的。也可以这么讲：exit 函数是退出应用程序，并将应用程序的一个状态返回给 OS，这个状态标识了应用程序的一些运行信息。</p><p>main 函数结束时也会隐式地调用 exit 函数，exit 函数运行时首先会执行由 atexit () 函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准 I/O 函数 tmpfile () 创建的临时文件。</p><p>exit 是系统调用级别的，它表示了一个进程的结束，它将删除进程使用的内存空间，同时把错误信息返回父进程。通常情况：exit (0) 表示程序正常，exit (1) 和 exit (-1) 表示程序异常退出，exit (2) 表示系统找不到指定的文件。在整个程序中，只要调用 exit 就结束。</p><p>2）return 是语言级别的，它表示了调用堆栈的返回；return 是返回函数值并退出函数，通常 0 为正常退出，非 0 为非正常退出，请注意，如果是在主函数 main, 自然也就结束当前进程了（也就是说，在 main () 里面，你可以用 return n，也能够直接用 exit (n) 来做），如果不是在 main 函数中，那就是退回上一层调用。在多个进程时，如果有时要检测上个进程是否正常退出，就要用到上个进程的返回值。</p><h4 id="2-进程环境与进程控制"><a class="markdownIt-Anchor" href="#2-进程环境与进程控制">#</a> 2、进程环境与进程控制</h4><p>exit (int n) 其实就是直接退出程序，因为默认的标准程序入口为 int main (int argc, char** argv)，返回值是 int 型的。一般在 shell 下面，运行一个程序，然后使用命令 echo $? 就能得到该程序的返回值，也就是退出值。</p><p>理论上 exit 可以返回小于 256 的任何整数，返回的不同数值主要是给调用者作不同处理的。</p><p>对于单独的进程 exit 的返回值是返回给操作系统的，但如果是多进程，则是返回给父进程的。父进程里面调用 waitpid () 等函数得到子进程退出的状态，以便作不同处理。根据相应的返回值来让调用者作出相应的处理。</p><p>总的说来，exit（）就是当前进程把其控制权返回给调用该子程序的主程序，括号里的是返回值，告诉调用程序该程序的运行状态。</p><h4 id="pingpong"><a class="markdownIt-Anchor" href="#pingpong">#</a> pingpong</h4><p>也还行，要注意管道 0 读 1 写，并且用不着哪边端口需要将其 close，用完的端口也要 close</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: create pipe number should be given one...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> p2[<span class="number">2</span>];</span><br><span class="line">  pipe(p1);</span><br><span class="line">  pipe(p2);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    close(p1[<span class="number">1</span>]);<span class="comment">//close p1 write</span></span><br><span class="line">    close(p2[<span class="number">0</span>]);<span class="comment">//close p2 read</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">10</span>];</span><br><span class="line">    read(p1[<span class="number">0</span>],buff, <span class="number">4</span>);</span><br><span class="line">    close(p1[<span class="number">0</span>]);</span><br><span class="line">    write(p2[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;pong&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buff);</span><br><span class="line">    close(p2[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    close(p1[<span class="number">0</span>]);<span class="comment">//close p1 write</span></span><br><span class="line">    close(p2[<span class="number">1</span>]);<span class="comment">//close p2 read</span></span><br><span class="line">    write(p1[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">    close(p1[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">10</span>];</span><br><span class="line">    read(p2[<span class="number">0</span>],buff, <span class="number">4</span>);</span><br><span class="line">    close(p2[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>,getpid(),buff);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prime"><a class="markdownIt-Anchor" href="#prime">#</a> prime</h4><p>这个题细心阅读他给的文档就行了</p><p>这个解决思路就是每一次筛一个数的倍数，筛到给定的值就行了。</p><p>递归解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subProcess</span><span class="params">(<span class="type">int</span> *oldFd)</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭原管道写端</span></span><br><span class="line">    close(oldFd[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">// 若能从原管道读到数据</span></span><br><span class="line">    <span class="keyword">if</span> (read(oldFd[<span class="number">0</span>], &amp;prime, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">// 第一个数据为质数,进行输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">        <span class="comment">// 创建管道和子进程</span></span><br><span class="line">        pipe(fd);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;    <span class="comment">//子进程</span></span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            subProcess(fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 父进程</span></span><br><span class="line">            <span class="comment">// 关闭新管道读端</span></span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 从原管道进行读取</span></span><br><span class="line">            <span class="keyword">while</span> (read(oldFd[<span class="number">0</span>], &amp;num, <span class="number">4</span>)) &#123;</span><br><span class="line">                <span class="comment">// 不能被记录的质数整除则写入新管道</span></span><br><span class="line">                <span class="keyword">if</span> (num % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(fd[<span class="number">1</span>], &amp;num, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时父进程的原管道关闭, 则关闭原管道的读端</span></span><br><span class="line">            close(oldFd[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 关闭新管道的写端</span></span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 等待子进程结束</span></span><br><span class="line">            wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 此时说明原管道已关闭,第一个数字都读不出</span></span><br><span class="line">        <span class="comment">// 不创建子进程直接关闭原管道读端</span></span><br><span class="line">        close(oldFd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        subProcess(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 遍历 2~35 写入管道写端</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i) &#123;</span><br><span class="line">            write(fd[<span class="number">1</span>], &amp;i, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写完关闭管道写端并等待子进程结束</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="find"><a class="markdownIt-Anchor" href="#find">#</a> find</h4><p>参考 ls 的实现，就简单改一下，遍历当前路径下所有文件名，如果发现当前文件是一个文件夹，就递归下去，如果发现当前是一个文件并且文件名同所要查找的一样，那就输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(<span class="type">char</span> *dir, <span class="type">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 声明 文件名缓冲区 和 指针</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="comment">// 声明文件描述符 fd</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 声明与文件相关的结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open() 函数打开路径，返回一个文件描述符，如果错误返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(dir, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 报错，提示无法打开此路径</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, dir);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int fstat(int fd, struct stat *);</span></span><br><span class="line">    <span class="comment">// 系统调用 fstat 与 stat 类似，但它以文件描述符作为参数</span></span><br><span class="line">    <span class="comment">// int stat(char *, struct stat *);</span></span><br><span class="line">    <span class="comment">// stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本</span></span><br><span class="line">    <span class="comment">// stat 以文件名作为参数，返回文件的 i 结点中的所有信息</span></span><br><span class="line">    <span class="comment">// 如果出错，则返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出错则报错</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, dir);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是目录类型</span></span><br><span class="line">    <span class="keyword">if</span> (st.type != T_DIR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 报类型不是目录错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: %s is not a directory\n&quot;</span>, dir);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径过长放不入缓冲区，则报错提示</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(dir) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: directory too long\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭文件描述符 fd</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 dir 指向的字符串即绝对路径复制到 buf</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, dir);</span><br><span class="line">    <span class="comment">// buf 是一个绝对路径，p 是一个文件名，通过加 &quot;/&quot; 前缀拼接在 buf 的后面</span></span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="comment">// 读取 fd ，如果 read 返回字节数与 de 长度相等则循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// strcmp(s, t);</span></span><br><span class="line">        <span class="comment">// 根据 s 指向的字符串小于（s&lt;t）、等于（s==t）或大于（s&gt;t） t 指向的字符串的不同情况</span></span><br><span class="line">        <span class="comment">// 分别返回负整数、0或正整数</span></span><br><span class="line">        <span class="comment">// 不要递归 &quot;.&quot; 和 &quot;...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// memmove，把 de.name 信息复制 p，其中 de.name 代表文件名</span></span><br><span class="line">        <span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">        <span class="comment">// 设置文件名结束符</span></span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int stat(char *, struct stat *);</span></span><br><span class="line">        <span class="comment">// stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本</span></span><br><span class="line">        <span class="comment">// stat 以文件名作为参数，返回文件的 i 结点中的所有信息</span></span><br><span class="line">        <span class="comment">// 如果出错，则返回 -1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 出错则报错</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是目录类型，递归查找</span></span><br><span class="line">        <span class="keyword">if</span> (st.type == T_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">find</span>(buf, file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是文件类型 并且 名称与要查找的文件名相同</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_FILE &amp;&amp; !<span class="built_in">strcmp</span>(de.name, file))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印缓冲区存放的路径</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果参数个数不为 3 则报错</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出提示</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: input should be three\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 find 函数查找指定目录下的文件</span></span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="xargs"><a class="markdownIt-Anchor" href="#xargs">#</a> xargs</h4><p>也还行，利用 fork 子进程然后 exec 执行命令就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果参数个数小于 2</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印参数错误提示</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: xargs command\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 异常退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放子进程 exec 的参数</span></span><br><span class="line">    <span class="type">char</span> * argvs[MAXARG];</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 略去 xargs ，用来保存命令行参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        argvs[index++] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓冲区存放从管道读出的数据</span></span><br><span class="line">    <span class="type">char</span> buf[MAXN] = &#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="comment">// 0 代表的是管道的 0，也就是从管道循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span>((n = read(<span class="number">0</span>, buf, MAXN)) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 临时缓冲区存放追加的参数</span></span><br><span class="line"><span class="type">char</span> temp[MAXN] = &#123;<span class="string">&quot;\0&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// xargs 命令的参数后面再追加参数</span></span><br><span class="line">        argvs[index] = temp;</span><br><span class="line">        <span class="comment">// 内循环获取追加的参数并创建子进程执行命令</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(buf); ++i) &#123;</span><br><span class="line">            <span class="comment">// 读取单个输入行，当遇到换行符时，创建子线程</span></span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建子线程执行命令</span></span><br><span class="line">                <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                    exec(argv[<span class="number">1</span>], argvs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待子线程执行完毕</span></span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，读取管道的输出作为输入</span></span><br><span class="line">                temp[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-xv6-and-unix-utilities&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-xv6-and-unix-utilities&quot;&gt;#&lt;/a&gt; Lab: Xv6 and Unix utilities&lt;/h1&gt;
&lt;</summary>
      
    
    
    
    
    <category term="MIT6.S081" scheme="https://flowerhai.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>multi-thread-exercise</title>
    <link href="https://flowerhai.github.io/2023/05/11/mutlthread/"/>
    <id>https://flowerhai.github.io/2023/05/11/mutlthread/</id>
    <published>2023-05-11T09:38:53.000Z</published>
    <updated>2023-05-11T09:39:59.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程编程"><a class="markdownIt-Anchor" href="#多线程编程">#</a> 多线程编程</h1><p>随便找几个多线程练习题练练手</p><p>1. 实现两个线程交替打印 1-100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="comment">/*实现两个线程交替打印1-100*/</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COUNT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNumber</span><span class="params">(<span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (count &lt;= MAX_COUNT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == threadId) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printNumber, <span class="number">0</span>)</span></span>;  <span class="comment">// 线程0打印奇数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printNumber, <span class="number">1</span>)</span></span>;  <span class="comment">// 线程1打印偶数</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环 50 次，试写出代码</p><p>有点怪说实话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次，试写出代码。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_LOOPS = <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUB_THREAD_LOOP_COUNT = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAIN_THREAD_LOOP_COUNT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isSubThreadTurn = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subThreadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_LOOPS; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> isSubThreadTurn; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SUB_THREAD_LOOP_COUNT; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Sub Thread: &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSubThreadTurn = <span class="literal">false</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">subThread</span><span class="params">(subThreadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_LOOPS; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !isSubThreadTurn; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MAIN_THREAD_LOOP_COUNT; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Main Thread: &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSubThreadTurn = <span class="literal">true</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有四个线程 1、2、3、4。线程 1 的功能就是输出 1，线程 2 的功能就是输出 2，</p><p>以此类推… 现在有四个文件 ABCD。初始都为空。现要让四个文件呈如下格式：</p><p>A：1 2 3 4 1 2…</p><p>B：2 3 4 1 2 3…</p><p>C：3 4 1 2 3 4…</p><p>D：4 1 2 3 4 1…</p><p>这个题比前面的有意思多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有四个线程1、2、3、4。线程1的功能就是输出1，线程2的功能就是输出2，</span></span><br><span class="line"><span class="comment">以此类推.........现在有四个文件ABCD。初始都为空。现要让四个文件呈如下格式：</span></span><br><span class="line"><span class="comment">A：1 2 3 4 1 2....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">B：2 3 4 1 2 3....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C：3 4 1 2 3 4....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">D：4 1 2 3 4 1....*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">4</span>; <span class="comment">// 线程数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxCount = <span class="number">10</span>; <span class="comment">// 每个线程要输出的数字总数</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ofstream&gt; <span class="title">outputFiles</span><span class="params">(numThreads)</span></span>; <span class="comment">// 输出文件流对象</span></span><br><span class="line"><span class="function">vector&lt;mutex&gt; <span class="title">fileMutexes</span><span class="params">(numThreads)</span></span>; <span class="comment">// 互斥锁，用于对文件进行同步访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> startNumber = threadId ; <span class="comment">// 每个线程的起始数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> number = (startNumber + i) % numThreads + <span class="number">1</span>; <span class="comment">// 计算当前要写入文件的数字</span></span><br><span class="line"></span><br><span class="line">        fileMutexes[threadId].<span class="built_in">lock</span>(); <span class="comment">// 获取当前线程对应的互斥锁</span></span><br><span class="line"></span><br><span class="line">        outputFiles[threadId] &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 将数字写入对应的文件</span></span><br><span class="line"></span><br><span class="line">        fileMutexes[threadId].<span class="built_in">unlock</span>(); <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        <span class="type">char</span> fileName = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">        outputFiles[i].<span class="built_in">open</span>(<span class="built_in">string</span>(<span class="number">1</span>, fileName) + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; threads; <span class="comment">// 线程对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        outputFiles[i].<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件写入完成。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经验证，符合题意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程编程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多线程编程&quot;&gt;#&lt;/a&gt; 多线程编程&lt;/h1&gt;
&lt;p&gt;随便找几个多线程练习题练练手&lt;/p&gt;
&lt;p&gt;1. 实现两个线程交替打印 1-100&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
    <category term="多线程编程" scheme="https://flowerhai.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081Lab:Xv6 and Unix utilities-part0</title>
    <link href="https://flowerhai.github.io/2023/05/11/s081/lab0/"/>
    <id>https://flowerhai.github.io/2023/05/11/s081/lab0/</id>
    <published>2023-05-11T08:11:13.000Z</published>
    <updated>2023-05-15T10:51:14.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mit6s081lab-xv6-and-unix-utilities"><a class="markdownIt-Anchor" href="#mit6s081lab-xv6-and-unix-utilities">#</a> MIT6.S081Lab: Xv6 and Unix utilities</h1><p>先来开个头</p><p>首先是 linux 开发环境搭建，我仍旧用的是阿里云 ECS Ubuntu  22.04 64 位</p><p>然后就是安装一些必备的包喽</p><p>将 git 到本地后进入文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure><p>成功后出现如下</p><p>ls 一下成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2226</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line">cat            2 4 24192</span><br><span class="line">echo           2 5 23016</span><br><span class="line">forktest       2 6 13240</span><br><span class="line">grep           2 7 27496</span><br><span class="line">init           2 8 23752</span><br><span class="line">kill           2 9 22960</span><br><span class="line">ln             2 10 22800</span><br><span class="line">ls             2 11 26384</span><br><span class="line">mkdir          2 12 23096</span><br><span class="line">rm             2 13 23080</span><br><span class="line">sh             2 14 41912</span><br><span class="line">stressfs       2 15 23952</span><br><span class="line">usertests      2 16 157000</span><br><span class="line">grind          2 17 38128</span><br><span class="line">wc             2 18 25280</span><br><span class="line">zombie         2 19 22344</span><br><span class="line">console        3 20 0</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure><p>先开个头吧，最近好累，字节青训营也开始了。</p><p>那边 CS144 的实验也并没有完全彻彻底底搞明白，下周开始做这个，预计这个六月份之前全部做完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mit6s081lab-xv6-and-unix-utilities&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mit6s081lab-xv6-and-unix-utilities&quot;&gt;#&lt;/a&gt; MIT6.S081Lab: Xv6 </summary>
      
    
    
    
    
    <category term="MIT6.S081" scheme="https://flowerhai.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>CS144Lab 4:the summit (TCP in full)</title>
    <link href="https://flowerhai.github.io/2023/05/11/cs144/cs144lab4/"/>
    <id>https://flowerhai.github.io/2023/05/11/cs144/cs144lab4/</id>
    <published>2023-05-11T03:45:21.000Z</published>
    <updated>2023-05-11T03:47:44.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab-4-the-summit-tcp-in-full"><a class="markdownIt-Anchor" href="#cs144lab-4-the-summit-tcp-in-full">#</a> CS144Lab 4: the summit (TCP in full)</h1><p>这节 lab 主要是将前面三小节的拼起来，以及繁琐的设计，难度估计比前面的加起来都离谱。</p><p>tcp_state.cc</p><p>TCP 的 FSM</p><p>然后看哪里错了，蛮慢慢改吧</p><p>TCP 中每一段的格式</p><p>讲义慢慢琢磨</p><p>OMG，so hard!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ms_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cerr&lt;&lt;&quot;receive: &quot; &lt;&lt; seg.header().to_string() &lt;&lt; &quot;length:&quot;&lt;&lt;seg.length_in_sequence_space()&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    _ms_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> send_empty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win)) &#123;</span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fsm_ack_rst_relaxed: ack in the future -&gt; sent ack back</span></span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> recv_recv = _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="keyword">if</span> (!recv_recv) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn &amp;&amp; !_sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore out of window RST</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (recv_recv || (seg.<span class="built_in">header</span>().ack &amp;&amp; (_sender.<span class="built_in">next_seqno</span>() == seg.<span class="built_in">header</span>().ackno))) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            <span class="built_in">test_end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_sender.<span class="built_in">fin_sent</span>()) &#123;  <span class="comment">// FIN + ACK</span></span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            send_empty = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (send_empty &amp;&amp; _receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (!_clean_shutdown) &amp;&amp; (!_unclean_shutdown) &amp;&amp; (!_rst); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> size = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    _ms_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">    <span class="built_in">test_end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_rst) &#123;</span><br><span class="line">        _rst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">fill_queue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            <span class="built_in">fill_queue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test the end of TCP connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::test_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &amp;&amp; _sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; (<span class="built_in">unassembled_bytes</span>() == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>) &amp;&amp; _sender.<span class="built_in">fin_sent</span>()) &#123;</span><br><span class="line">        <span class="comment">// bytes_in_flight==0 =&gt; state: FIN_ACKED</span></span><br><span class="line">        _clean_shutdown |= (!_linger_after_streams_finish);</span><br><span class="line">        _unclean_shutdown |= (_ms_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill queue from _sender.segments_out() to _segments_out</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::fill_queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; !_rst) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_rst || (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS)) &#123;</span><br><span class="line">            _rst = <span class="number">1</span>;</span><br><span class="line">            seg = TCPSegment&#123;&#125;;</span><br><span class="line">            seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">            _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">            _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// TCPReceiver wants to advertise a window size</span></span><br><span class="line">            <span class="keyword">if</span> (_receiver.<span class="built_in">window_size</span>() &lt; numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().win = numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  cerr &lt;&lt; &quot;send: &quot; &lt;&lt; seg.header().to_string()&lt;&lt;&quot;length:&quot; &lt;&lt; seg.length_in_sequence_space() &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前四个 lab 做完，有点懵，这周继续消化这四个 lab。</p><p>因为有的地方也参考了别人的 work，感觉完成的不是很好，这周吃透。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab-4-the-summit-tcp-in-full&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab-4-the-summit-tcp-in-full&quot;&gt;#&lt;/a&gt; CS144Lab 4: the summ</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144Lab 3:the TCP sender</title>
    <link href="https://flowerhai.github.io/2023/05/11/cs144/cs144lab3/"/>
    <id>https://flowerhai.github.io/2023/05/11/cs144/cs144lab3/</id>
    <published>2023-05-11T02:12:40.000Z</published>
    <updated>2023-05-11T02:13:41.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab-3-the-tcp-sender"><a class="markdownIt-Anchor" href="#cs144lab-3-the-tcp-sender">#</a> CS144Lab 3: the TCP sender</h1><h3 id="定时器"><a class="markdownIt-Anchor" href="#定时器">#</a> 定时器</h3><p>文件中说最好在类外重新定义一个定时器，那么便如此</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPRetransmissionTimer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! retransmission timer for the connection</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _initial_RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! retransmission timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _RTO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! timeout</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _TO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer, 1:open, 0:close</span></span><br><span class="line">    <span class="type">bool</span> _open;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Initialize a TCP retransmission timer</span></span><br><span class="line">    <span class="built_in">TCPRetransmissionTimer</span>(<span class="type">const</span> <span class="type">uint16_t</span> retx_timeout)</span><br><span class="line">        : _initial_RTO(retx_timeout), _RTO(retx_timeout), _TO(<span class="number">0</span>), _open(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! state of the timer</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">open</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _open; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! start the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">true</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! close the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _open = <span class="literal">false</span>;</span><br><span class="line">        _TO = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! tick</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">tick</span><span class="params">(<span class="type">size_t</span> &amp;ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">open</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ms_since_last_tick &gt; _RTO - _TO) &#123;</span><br><span class="line">            ms_since_last_tick -= (_RTO - _TO);</span><br><span class="line">            _TO = _RTO;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _TO += ms_since_last_tick;</span><br><span class="line">            ms_since_last_tick = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_TO &gt;= _RTO) &#123;</span><br><span class="line">            _TO = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// the retransmission timer has expired.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="fill_window"><a class="markdownIt-Anchor" href="#fill_window">#</a> fill_window</h3><p>首先先看一下_next_seqno 的值，如果_next_seqno 为 0 则说明当前处于关闭状态，应该启动并发送一个非空的 TCPsegment。</p><p>如果_next_seqno 和_nBytes_inflight 相等，说明我们之前已经发送过了 SYN，就不用再发送了。</p><p>如果 window_size 的大小为 0，我们将其设为 1.</p><p>然后就是发送一个尽可能大的 TCPSegment 喽。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!_stream.<span class="built_in">error</span>());</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// state is CLOSE, need to send SYN</span></span><br><span class="line">        seg.<span class="built_in">header</span>().syn = <span class="number">1</span>;</span><br><span class="line">        _syn_sent = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(seg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_next_seqno == _nBytes_inflight) &#123;</span><br><span class="line">        <span class="comment">// state is SYN SENT, don&#x27;t send SYN</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero window probing</span></span><br><span class="line">    <span class="type">uint16_t</span> window_size = _window_size ? _window_size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> remaining;</span><br><span class="line">    <span class="keyword">while</span> ((remaining = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(window_size) + (_recv_ackno - _next_seqno))) &#123;</span><br><span class="line">        <span class="comment">// FIN flag occupies space in window</span></span><br><span class="line">        TCPSegment new_seg;</span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !_fin_sent) &#123;</span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">size_t</span> size = <span class="built_in">min</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(remaining), TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">        new_seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(size));</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() &lt; window_size &amp;&amp; _stream.<span class="built_in">eof</span>()) &#123;  <span class="comment">// piggy-back FIN</span></span><br><span class="line">            new_seg.<span class="built_in">header</span>().fin = <span class="number">1</span>;</span><br><span class="line">            _fin_sent = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">send_non_empty_segment</span>(new_seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ack_received"><a class="markdownIt-Anchor" href="#ack_received">#</a> ack_received</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="comment">//! \returns `false` if the ackno appears invalid (acknowledges something the TCPSender hasn&#x27;t sent yet)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ackno - <span class="built_in">next_seqno</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果window_size为0，需要记录下来，&quot;zero window probing&quot;, 影响tick()和fill_window()的行为</span></span><br><span class="line">    _window_size = window_size;</span><br><span class="line">    <span class="type">uint64_t</span> abs_ackno = <span class="built_in">unwrap</span>(ackno, _isn, _recv_ackno);</span><br><span class="line">    <span class="keyword">if</span> (abs_ackno &lt;= _recv_ackno) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _recv_ackno = abs_ackno;</span><br><span class="line">    <span class="comment">// acknowledges the successful receipt of new data</span></span><br><span class="line">    _timer._RTO = _timer._initial_RTO;</span><br><span class="line">    _timer._TO = <span class="number">0</span>;</span><br><span class="line">    _consecutive_retransmissions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque fully-acknowledged segments</span></span><br><span class="line">    <span class="keyword">while</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;seg = _segments_outstanding.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (ackno - seg.<span class="built_in">header</span>().seqno &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(seg.<span class="built_in">length_in_sequence_space</span>())) &#123;</span><br><span class="line">            _nBytes_inflight -= seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            _segments_outstanding.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the window</span></span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// any outstanding segment, restart the timer.</span></span><br><span class="line">    <span class="comment">// [RFC6298](5.3)</span></span><br><span class="line">    <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _timer.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tick"><a class="markdownIt-Anchor" href="#tick">#</a> tick</h3><p>这里基本上就是和超时重传差不多吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> time_left = ms_since_last_tick;</span><br><span class="line">    <span class="keyword">if</span> (_timer.<span class="built_in">tick</span>(time_left)) &#123;</span><br><span class="line">        <span class="comment">// Notice: remove fill_the_window() here to fix the test fsm_retx_relaxed</span></span><br><span class="line">        <span class="comment">// timer has expired, retransmit at most ONE outstanding segment</span></span><br><span class="line">        <span class="keyword">if</span> (!_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// retransmit the outstanding segment with the lowest sequence number</span></span><br><span class="line">            _segments_out.<span class="built_in">push</span>(_segments_outstanding.<span class="built_in">front</span>());</span><br><span class="line">            <span class="keyword">if</span> (_window_size) &#123;</span><br><span class="line">                _consecutive_retransmissions++;</span><br><span class="line">                _timer._RTO *= <span class="number">2</span>;  <span class="comment">// double the RTO, exponential backoff, it slows down retransmissions on lousy</span></span><br><span class="line">                                   <span class="comment">// networks to avoid further gumming up the works</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_timer.<span class="built_in">open</span>()) &#123;  <span class="comment">//[RFC6298](5.1)</span></span><br><span class="line">                _timer.<span class="built_in">start</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">syn_sent</span>() &amp;&amp; (_next_seqno == _nBytes_inflight) &amp;&amp; (_timer._RTO &lt; <span class="number">3000</span>)) &#123;</span><br><span class="line">                _timer._RTO = <span class="number">3000</span>;  <span class="comment">// SYN_SENT, [RFC6298](5.7)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_segments_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _timer.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab-3-the-tcp-sender&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab-3-the-tcp-sender&quot;&gt;#&lt;/a&gt; CS144Lab 3: the TCP sender&lt;/h1&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>刷题记录-24天</title>
    <link href="https://flowerhai.github.io/2023/05/10/shuati/day24/"/>
    <id>https://flowerhai.github.io/2023/05/10/shuati/day24/</id>
    <published>2023-05-10T14:10:46.000Z</published>
    <updated>2023-05-10T14:11:25.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1015-可被-k-整除的最小整数"><a class="markdownIt-Anchor" href="#1015-可被-k-整除的最小整数">#</a> <a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/">1015. 可被 K 整除的最小整数</a></h4><p>给定正整数  <code>k</code>  ，你需要找出可以被  <code>k</code>  整除的、仅包含数字  <code>**1**</code>  的最 <strong>小</strong> 正整数  <code>n</code>  的长度。</p><p>返回  <code>n</code>  的长度。如果不存在这样的  <code>n</code>  ，就返回 - 1。</p><p><strong>注意：</strong>  <code>n</code>  不符合 64 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的答案是 n = 1，其长度为 1。</span><br></pre></td></tr></table></figure><p>能整除 2 或 5 的肯定不行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span> || k % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> resid = <span class="number">1</span> % k, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (resid != <span class="number">0</span>) &#123;</span><br><span class="line">            resid = (resid * <span class="number">10</span> + <span class="number">1</span>) % k;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点  <code>root</code>  ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p>也还行吧，递归就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = -INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_gain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INT_MAX;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">max_gain</span>(root-&gt;right),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pp = r + l + root-&gt;val;</span><br><span class="line">        res = <span class="built_in">max</span>(res, pp);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">max_gain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表">#</a> <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h4><p>给你一个链表的头节点  <code>head</code>  ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪  <code>next</code>  指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数  <code>pos</code>  来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意： <code>pos</code>  不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回  <code>true</code>  。 否则，返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" class="lazyload placeholder" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>典型快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="79-单词搜索"><a class="markdownIt-Anchor" href="#79-单词搜索">#</a> <a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h4><p>给定一个  <code>m x n</code>  二维字符网格  <code>board</code>  和一个字符串单词  <code>word</code>  。如果  <code>word</code>  存在于网格中，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中 “相邻” 单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" class="lazyload placeholder" data-srcset="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>嗯，好像没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ex</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, string word, <span class="type">int</span> d, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == word.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; board[i][j] == word[d]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[d]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == word[d]) &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i<span class="number">-1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;board.<span class="built_in">size</span>() &amp;&amp; board[i+<span class="number">1</span>][j]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i+<span class="number">1</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>&lt;board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; board[i][j+<span class="number">1</span>]==word[d+<span class="number">1</span>])  <span class="built_in">ex</span>(board,word,d+<span class="number">1</span>,i,j+<span class="number">1</span>);</span><br><span class="line">            board[i][j] = word[d];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">ex</span>(board, word, <span class="number">0</span>, i, j);</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1015-可被-k-整除的最小整数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1015-可被-k-整除的最小整数&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/smallest-integ</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>CS144-summary1</title>
    <link href="https://flowerhai.github.io/2023/05/10/cs144/summary1/"/>
    <id>https://flowerhai.github.io/2023/05/10/cs144/summary1/</id>
    <published>2023-05-10T03:23:44.000Z</published>
    <updated>2023-05-10T03:24:17.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs144lab0-1-2-summary"><a class="markdownIt-Anchor" href="#cs144lab0-1-2-summary">#</a> CS144lab0-1-2 summary</h1><p>在 lab0 中，首先实现了一个 get_url 函数，这个函数就是像指定地址发起 http 连接然后做出响应，注意一下 Htpp 报文响应格式就可以了。</p><p>随后我们又完成了 ByteStream 的实现。</p><p>这个 byteStream 主要就是实现 TCP 协议中的最基础的字节流，用来存储需要传输的字节。</p><p>在 lab1 中，实现 StreamReassembler。</p><p>这个主要是 TCP 协议中的数据流控制器，用来将传给 TCP 的数据确保有序写入 byteStream 中。</p><p>在 lab2 中，我们实现 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p><img src="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-89e93bf7a8349bad81a09f494e03e418_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol><li>内核态下 UDP 数据包中的 payload 被解析为 TCPSegment (TCP 报文) 后，交给用户态下的 TCPConnection，即调用 segment_received 方法；</li><li>TCPConnection 收到报文后，将报文交给 TCPReceiver，即调用 TCPReceiver.segment_received 方法，并将报文中的 ackno (确认号) 与 window_size (窗口大小) 交给 TCPSender，即调用 ack_received 方法；</li><li>TCPReceiver 处理 TCP 报文，并将报文中的 payload 推入 StreamReassembler 中，并重组后交给应用程序，随后尝试发送报文；</li><li>TCPConnection 调用 TCPSender.fill_window 方法尝试得到待发送报文 (可能得不到，视具体情况而定)，若有报文，则设置报文 payload 以及其它字段，如 SYN、ackno (从 receiver 获取)、window_size 等，设置完毕后包装为 TCP 报文，将报文交给 UDP；</li><li>UDP 将其打包为数据报，并发送给远端。</li></ol><p>lab2 中只要注意这个图问题不大。</p><p><img src="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/v2-88925e1793d5a992d079630ebcb908e3_r.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>在 TCP header 中 seqno 与 ackno 都是 32 位整数，但是 isn 是发送者随机生成的数字，那么可能会产生一个问题：如果随机生成的 isn 十分接近 2^32-1 怎么办？</p><p>这代表，TCP 数据流很快就会溢出 seqno。为了解决这个问题，sponge 实现了两个序号，一个是正常的 TCP header seqno，32 位，使用 WrappingInt32 表示，初始化为随机数，另一个是绝对 seqno 序号，使用 uint64_t 表示，初始化为 0。用绝对序号来表示数据流上字节的数量，最大数量为 2^64-1，这几乎是不可能达成的目标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs144lab0-1-2-summary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cs144lab0-1-2-summary&quot;&gt;#&lt;/a&gt; CS144lab0-1-2 summary&lt;/h1&gt;
&lt;p&gt;在 lab0 中，首先实现了</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>刷题记录-第23天</title>
    <link href="https://flowerhai.github.io/2023/05/09/shuati/day23/"/>
    <id>https://flowerhai.github.io/2023/05/09/shuati/day23/</id>
    <published>2023-05-09T12:45:13.000Z</published>
    <updated>2023-05-09T12:45:50.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="池塘计数"><a class="markdownIt-Anchor" href="#池塘计数">#</a> 池塘计数</h3><p>农夫约翰有一片 N∗M ∗  的矩形土地。</p><p>最近，由于降雨的原因，部分土地被水淹没了。</p><p>现在用一个字符矩阵来表示他的土地。</p><p>每个单元格内，如果包含雨水，则用”W” 表示，如果不含雨水，则用”.” 表示。</p><p>现在，约翰想知道他的土地中形成了多少片池塘。</p><p>每组相连的积水单元格集合可以看作是一片池塘。</p><p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p><p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W” 块。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h4><p>第一行包含两个整数 N  和 M 。</p><p>接下来 N  行，每行包含 M  个字符，字符为”W” 或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h4><p>输出一个整数，表示池塘数目。</p><h4 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围">#</a> 数据范围</h4><p>1≤N,M≤10001≤ , ≤1000</p><h4 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例">#</a> 输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例">#</a> 输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>经典连通块问题喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    f[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//上、下、左、右、左上、右上、左下、右下</span></span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; f[x+<span class="number">1</span>][y] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">if</span> (y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (y+<span class="number">1</span>&lt;m &amp;&amp; f[x][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x<span class="number">-1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x<span class="number">-1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x<span class="number">-1</span>, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; f[x+<span class="number">1</span>][y<span class="number">-1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>&lt;n &amp;&amp; y+<span class="number">1</span>&lt;m &amp;&amp; f[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(x+<span class="number">1</span>, y+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="type">char</span> a;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;W&#x27;</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">&#x27;.&#x27;</span>) f[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="热浪"><a class="markdownIt-Anchor" href="#热浪">#</a> 热浪</h3><p>德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！</p><p>他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。</p><p>农夫 John 此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p><p>John 已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。</p><p>这些路线包括起始点和终点一共有 T  个城镇，为了方便标号为 11 到 T 。</p><p>除了起点和终点外的每个城镇都由 <strong>双向道路</strong> 连向至少两个其它的城镇。</p><p>每条道路有一个通过费用（包括油费，过路费等等）。</p><p>给定一个地图，包含 C  条直接连接 22 个城镇的道路。</p><p>每条道路由道路的起点 Rs  ，终点 Re   和花费 Ci   组成。</p><p>求从起始的城镇 Ts   到终点的城镇 Te   最小的总费用。</p><h4 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h4><p>第一行: 44 个由空格隔开的整数: T,C,Ts,Te , ,  ,  ;</p><p>第 22 到第 C+1 +1 行：第 i+1 +1 行描述第 i  条道路，包含 33 个由空格隔开的整数: Rs,Re,Ci  ,  ,  。</p><h4 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h4><p>一个单独的整数表示从 Ts   到 Te   的最小总费用。</p><p>数据保证至少存在一条道路。</p><h4 id="数据范围-2"><a class="markdownIt-Anchor" href="#数据范围-2">#</a> 数据范围</h4><p>1≤T≤25001≤ ≤2500,<br>1≤C≤62001≤ ≤6200,<br>1≤Ts,Te,Rs,Re≤T1≤  ,  ,  ,  ≤ ,<br>1≤Ci≤10001≤  ≤1000</p><h4 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2">#</a> 输入样例：</h4><p>dijkstra 算法板子题算是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,c, nbeg, nend;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[nbeg] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c&gt;&gt;nbeg&gt;&gt;nend;</span><br><span class="line">    <span class="keyword">while</span> (c --) &#123;</span><br><span class="line">        <span class="type">int</span> k, p, l;</span><br><span class="line">        cin&gt;&gt;k&gt;&gt;p&gt;&gt;l;</span><br><span class="line">        g[k][p] = g[p][k] = <span class="built_in">min</span>(g[k][p], l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout&lt;&lt;dist[nend];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dijkstra 的整体思路比较清晰<br>即进行 n（n 为 n 的个数）次迭代去确定每个点到起点的最小值 最后输出的终点的即为我们要找的最短路的距离</p><p>所以按照这个思路除了存储图外我们还需要存储两个量</p><p>dist [n] // 用于存储每个点到起点的最短距离<br> st [n]   // 用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新</p><p>每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点<br>（至于为什么是这样那么这就涉及到 Dijkstra 算法的具体数学证明了 有兴趣的同学可以百度一下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t=<span class="number">-1</span>;       <span class="comment">//将t设置为-1 因为Dijkstra算法适用于不存在负权边的图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j])    <span class="comment">//该步骤即寻找还未确定最短路的点中路径最短的点</span></span><br><span class="line">        t=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述操作当前我们的 t 代表就是剩余未确定最短路的点中 路径最短的点<br>而与此同时该点的最短路径也已经确定我们将该点标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st[t]=true;</span><br></pre></td></tr></table></figure><p>然后用这个去更新其余未确定点的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离</span></span><br><span class="line"><span class="comment">//但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响</span></span><br><span class="line"><span class="comment">//当然你也可以在循环判断条件里加上if(!st[i])</span></span><br><span class="line"><span class="comment">//这里j从1开始只是为了代码的简洁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行 n 次迭代后最后就可以确定每个点的最短距离</p><h4 id="面试题-0101-判定字符是否唯一"><a class="markdownIt-Anchor" href="#面试题-0101-判定字符是否唯一">#</a> <a href="https://leetcode.cn/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一</a></h4><p>实现一个算法，确定一个字符串  <code>s</code>  的所有字符是否全都不同。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;</span><br><span class="line">输出: false </span><br></pre></td></tr></table></figure><p>题目说了全是小写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; astr.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[astr[i]-<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            a[astr[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍">#</a> <a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>典</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">max</span>(f[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(f[<span class="number">0</span>], f[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], <span class="built_in">max</span>(nums[i]+f[i<span class="number">-2</span>],f[i<span class="number">-1</span>]));</span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="面试题-0202-返回倒数第-k-个节点"><a class="markdownIt-Anchor" href="#面试题-0202-返回倒数第-k-个节点">#</a> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></h4><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p>** 注意：** 本题相对原题稍作改动</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p>双指针喽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">while</span> (h!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast ++;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;池塘计数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#池塘计数&quot;&gt;#&lt;/a&gt; 池塘计数&lt;/h3&gt;
&lt;p&gt;农夫约翰有一片 N∗M ∗  的矩形土地。&lt;/p&gt;
&lt;p&gt;最近，由于降雨的原因，部分土地被水淹没了。&lt;/p&gt;
&lt;p&gt;现在用一个字符</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>刷题day22</title>
    <link href="https://flowerhai.github.io/2023/05/08/shuati/day22/"/>
    <id>https://flowerhai.github.io/2023/05/08/shuati/day22/</id>
    <published>2023-05-08T13:32:35.000Z</published>
    <updated>2023-05-08T13:33:05.491Z</updated>
    
    <content type="html"><![CDATA[<h4 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站">#</a> <a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h4><p>在一条环路上有  <code>n</code>  个加油站，其中第  <code>i</code>  个加油站有汽油  <code>gas[i]</code>  升。</p><p>你有一辆油箱容量无限的的汽车，从第  <code>i</code>  个加油站开往第  <code>i+1</code>  个加油站需要消耗汽油  <code>cost[i]</code>  升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组  <code>gas</code>  和  <code>cost</code>  ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回  <code>-1</code>  。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p>贪心即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">                start = i + <span class="number">1</span>;  </span><br><span class="line">                curSum = <span class="number">0</span>;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="135-分发糖果"><a class="markdownIt-Anchor" href="#135-分发糖果">#</a> <a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h4><p><code>n</code>  个孩子站成一排。给你一个整数数组  <code>ratings</code>  表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到  <code>1</code>  个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure><p>从左向右，从右向左，各来一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="860-柠檬水找零"><a class="markdownIt-Anchor" href="#860-柠檬水找零">#</a> <a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h4><p>在柠檬水摊上，每一杯柠檬水的售价为  <code>5</code>  美元。顾客排队购买你的产品，（按账单  <code>bills</code>  支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付  <code>5</code>  美元、 <code>10</code>  美元或  <code>20</code>  美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付  <code>5</code>  美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组  <code>bills</code>  ，其中  <code>bills[i]</code>  是第  <code>i</code>  位顾客付的账。如果你能给每位顾客正确找零，返回  <code>true</code>  ，否则返回  <code>false</code>  。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bill : bills) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="comment">// 情况二</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况三</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着</span></span><br><span class="line">                <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                    twenty++; <span class="comment">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                    twenty++; <span class="comment">// 同理，这行代码也可以删了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="406-根据身高重建队列"><a class="markdownIt-Anchor" href="#406-根据身高重建队列">#</a> <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><p>假设有打乱顺序的一群人站成一个队列，数组  <code>people</code>  表示队列中一些人的属性（不一定按顺序）。每个  <code>people[i] = [hi, ki]</code>  表示第  <code>i</code>  个人的身高为  <code>hi</code>  ，前面 <strong>正好</strong> 有  <code>ki</code>  个身高大于或等于  <code>hi</code>  的人。</p><p>请你重新构造并返回输入数组  <code>people</code>  所表示的队列。返回的队列应该格式化为数组  <code>queue</code>  ，其中  <code>queue[j] = [hj, kj]</code>  是队列中第  <code>j</code>  个人的属性（ <code>queue[0]</code>  是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 身高从大到小排（身高相同k小的站前面）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span> (people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que; <span class="comment">// list底层是链表实现，插入效率比vector高的多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>]; <span class="comment">// 插入到下标为position的位置</span></span><br><span class="line">            std::list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (position--) &#123; <span class="comment">// 寻找在插入位置</span></span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(it, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>感觉有时候贪心和动态规划有时候好像。</p><p>很想用动态规划上去结题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;134-加油站&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#134-加油站&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/gas-station/&quot;&gt;134. 加油站&lt;/a&gt;&lt;/h4&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
  <entry>
    <title>Lab 2:the TCP receiver</title>
    <link href="https://flowerhai.github.io/2023/05/08/cs144/cs144lab2/"/>
    <id>https://flowerhai.github.io/2023/05/08/cs144/cs144lab2/</id>
    <published>2023-05-08T12:54:52.000Z</published>
    <updated>2023-05-10T02:54:48.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#lab-2-the-tcp-receiver">#</a> Lab 2: the TCP receiver</h1><p>在 Lab2，我们将实现一个 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p><p>TCPReceiver 除了将读入的数据写入至 ByteStream 中以外，它还需要<strong>告诉发送者两个属性</strong>：</p><ul><li>第一个未组装的字节索引，称为<strong>确认号 ackno</strong>，它是接收者需要的第一个字节的索引。</li><li><strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的距离，称为 <strong>窗口长度 window size</strong>。</li></ul><p>ackno 和 window size 共同描述了接收者当前的<strong>接收窗口</strong>。接收窗口是 发送者允许发送数据的一个范围，通常 TCP 接收方使用接收窗口来进行<strong>流量控制</strong>，限制发送方发送数据。</p><p>总的来说，我们将要实现的 TCPReceiver 需要做以下几件事情：</p><ul><li>接收 TCP segment</li><li>重新组装字节流（包括 EOF）</li><li>确定应该发回给发送者的信号，以进行数据确认和流量控制</li></ul><h2 id="索引转换"><a class="markdownIt-Anchor" href="#索引转换">#</a> 索引转换</h2><p>TCP 报文中用来描述 ** 当前数据首字节的索引（序列号 seqno）** 是 32 位类型的，这意味着在处理上增加了一些需要考虑的东西：</p><p>在传输的 TCP 报文头部中，由于空间限制，字节序列号只能用 32 位的索引来表示。但是 32 位可能无法完全一一对应一串字节流，所以需要我们在接收端人为将索引转换为 64 位以保证不会溢出。</p><ul><li><p>由于 32 位类型最大能表达的值是 4GB，存在上溢的可能。因此当 32 位的 seqno 上溢后，下一个字节的 seqno 就重新从 0 开始。</p></li><li><p>处于安全性考虑，以及避免与之前的 TCP 报文混淆，TCP 需要让每个 seqno 都不可被猜测到，并且降低重复的可能性。因此 TCP seqno 不会从 0 开始，而是从一个 32 位随机数起步（称为<strong>初始序列号 ISN</strong>）。</p><p>而 ISN 是表示 SYN 包（用以表示 TCP 流的开始）的序列号。</p></li><li><p>TCP 流的<strong>逻辑开始数据包</strong>和<strong>逻辑结束数据包</strong>各占用一个 seqno。除了确保<strong>接收到所有字节的数据</strong>以外，TCP 还需要确保接收到<strong>流的开头和结尾</strong>。 因此，在 TCP 中，SYN（流开始）和 FIN（流结束）控制标志将会被分别分配一个序列号（SYN 标志占用的序列号就是 ISN）。</p><p>流中的每个数据字节也占用一个序列号。</p><p>但需要注意的是，SYN 和 FIN 不是流本身的一部分，也不是传输的字节数据。它们只是代表字节流本身的开始和结束。</p></li></ul><p>字节索引类型一多就容易乱。当前总共有三种索引：</p><ul><li>序列号 seqno。<strong>从 ISN 起步</strong>，包含 SYN 和 FIN，<strong>32 位循环</strong>计数</li><li>绝对序列号 absolute seqno。<strong>从 0 起步</strong>，包含 SYN 和 FIN，<strong>64 位非循环</strong>计数</li><li>流索引 stream index。<strong>从 0 起步</strong>，<strong>排除 SYN 和 FIN</strong>，<strong>64 位非循环</strong>计数。</li></ul><p>这是一个简单浅显的例子，用于区分开三种索引的区别：</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" class="lazyload placeholder" data-srcset="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107105751818.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211107105751818"></p><p>序列号和<strong>绝对</strong>序列号之间相互转换稍微有点麻烦，因为序列号是<strong>循环计数</strong>的。在该实验中，CS144 使用自定义类型 WrappingInt32 表示序列号，并编写了它与绝对序列号之间的转换。</p><p>这个实现稍微有点麻烦，而且实现的时候也最好避免各类循环，减少使用条件判断的次数，以提高执行效率。</p><h4 id="wrap"><a class="markdownIt-Anchor" href="#wrap">#</a> wrap</h4><p>该函数时将 64 位转化为 64 位，还是比较容易</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn); </span></span><br><span class="line">    <span class="comment">// return WrappingInt32&#123;0&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(isn.<span class="built_in">raw_value</span>() + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="unwrap"><a class="markdownIt-Anchor" href="#unwrap">#</a> unwrap</h4><p>该函数将 32 位转化为 64 位，需要动点脑子</p><p>因为 64 位变成 32 位肯定会有些数字代表的并不是一个，可能是多个 64 位的数据，所以这个时候就需要 checkpoint 来告诉我们是哪个</p><p>离得近就是！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(n, isn, checkpoint);</span></span><br><span class="line">    <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">    <span class="type">uint64_t</span> offset = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n.<span class="built_in">raw_value</span>()-isn.<span class="built_in">raw_value</span>());</span><br><span class="line">    <span class="type">uint64_t</span> mod = checkpoint&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> ii  = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add = ii&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> add_1 = offset + add*mod;</span><br><span class="line">    <span class="type">uint64_t</span> add_2 = offset + add*(mod+<span class="number">1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> add_3 = offset + add*(mod<span class="number">-1</span>);</span><br><span class="line">    <span class="type">uint64_t</span> r_1 = add_1 &gt; checkpoint ? add_1 - checkpoint : checkpoint - add_1;</span><br><span class="line">    <span class="type">uint64_t</span> r_2 = add_2 &gt; checkpoint ? add_2 - checkpoint : checkpoint - add_2;</span><br><span class="line">    <span class="type">uint64_t</span> r_3 = add_3 &gt; checkpoint ? add_3 - checkpoint : checkpoint - add_3;</span><br><span class="line">    r_3 ++;</span><br><span class="line">    r_3 --;</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="number">0</span>) r_3 = INT64_MAX;</span><br><span class="line">    <span class="type">uint64_t</span> min_off = <span class="built_in">min</span>(<span class="built_in">min</span>(r_1, r_2), r_3);</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_1) <span class="keyword">return</span> add_1;</span><br><span class="line">    <span class="keyword">if</span> (min_off == r_2) <span class="keyword">return</span> add_2;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> add_3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">    Start 1: t_wrapping_ints_cmp</span><br><span class="line">1/3 Test #1: t_wrapping_ints_cmp ..............   Passed    0.01 sec</span><br><span class="line">    Start 2: t_wrapping_ints_unwrap</span><br><span class="line">2/3 Test #2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span><br><span class="line">    Start 3: t_wrapping_ints_wrap</span><br><span class="line">3/3 Test #3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">tests passed, 0 tests failed out of 3</span></span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.02 sec</span><br></pre></td></tr></table></figure><h4 id="implementing-the-tcp-receiver"><a class="markdownIt-Anchor" href="#implementing-the-tcp-receiver">#</a> Implementing the TCP receiver</h4><p>调试还是蛮麻烦的，很难一下子考虑到所有情况欸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> abs_seqno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_syn_flag) &#123;  <span class="comment">// already get a SYN, refuse other SYN.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _syn_flag = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">        _isn = seg.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>();</span><br><span class="line">        abs_seqno = <span class="number">1</span>;</span><br><span class="line">        _base = <span class="number">1</span>;</span><br><span class="line">        length = seg.<span class="built_in">length_in_sequence_space</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;  <span class="comment">// segment&#x27;s content only have a SYN flag</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_syn_flag) &#123;  <span class="comment">// before get a SYN, refuse any segment</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// not a SYN segment, compute it&#x27;s abs_seqno</span></span><br><span class="line">        abs_seqno = <span class="built_in">unwrap</span>(<span class="built_in">WrappingInt32</span>(seg.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>()), <span class="built_in">WrappingInt32</span>(_isn), abs_seqno);</span><br><span class="line">        length = seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_fin_flag) &#123;  <span class="comment">// already get a FIN, refuse other FIN</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _fin_flag = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// not FIN and not one size&#x27;s SYN, check border</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp; abs_seqno == _base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (abs_seqno &gt;= _base + <span class="built_in">window_size</span>() || abs_seqno + length &lt;= _base) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(), abs_seqno - <span class="number">1</span>, seg.<span class="built_in">header</span>().fin);</span><br><span class="line">    _base = _reassembler.<span class="built_in">head_index</span>() + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">input_ended</span>())  <span class="comment">// FIN be count as one byte</span></span><br><span class="line">        _base++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_base &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(<span class="built_in">wrap</span>(_base, <span class="built_in">WrappingInt32</span>(_isn)));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _reassembler.<span class="built_in">stream_out</span>().<span class="built_in">buffer_size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>测试结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Test project /root/lianxi/CS144/sponge/build</span><br><span class="line">      Start  <span class="number">1</span>: t_wrapping_ints_cmp</span><br><span class="line"> <span class="number">1</span>/<span class="number">25</span> Test  #<span class="number">1</span>: t_wrapping_ints_cmp ..............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">2</span>: t_wrapping_ints_unwrap</span><br><span class="line"> <span class="number">2</span>/<span class="number">25</span> Test  #<span class="number">2</span>: t_wrapping_ints_unwrap ...........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">3</span>: t_wrapping_ints_wrap</span><br><span class="line"> <span class="number">3</span>/<span class="number">25</span> Test  #<span class="number">3</span>: t_wrapping_ints_wrap .............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start  <span class="number">4</span>: t_recv_connect</span><br><span class="line"> <span class="number">4</span>/<span class="number">25</span> Test  #<span class="number">4</span>: t_recv_connect ...................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">5</span>: t_recv_transmit</span><br><span class="line"> <span class="number">5</span>/<span class="number">25</span> Test  #<span class="number">5</span>: t_recv_transmit ..................   Passed    <span class="number">0.06</span> sec</span><br><span class="line">      Start  <span class="number">6</span>: t_recv_window</span><br><span class="line"> <span class="number">6</span>/<span class="number">25</span> Test  #<span class="number">6</span>: t_recv_window ....................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">7</span>: t_recv_reorder</span><br><span class="line"> <span class="number">7</span>/<span class="number">25</span> Test  #<span class="number">7</span>: t_recv_reorder ...................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start  <span class="number">8</span>: t_recv_close</span><br><span class="line"> <span class="number">8</span>/<span class="number">25</span> Test  #<span class="number">8</span>: t_recv_close .....................   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">15</span>: t_strm_reassem_single</span><br><span class="line"> <span class="number">9</span>/<span class="number">25</span> Test #<span class="number">15</span>: t_strm_reassem_single ............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">16</span>: t_strm_reassem_seq</span><br><span class="line"><span class="number">10</span>/<span class="number">25</span> Test #<span class="number">16</span>: t_strm_reassem_seq ...............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">17</span>: t_strm_reassem_dup</span><br><span class="line"><span class="number">11</span>/<span class="number">25</span> Test #<span class="number">17</span>: t_strm_reassem_dup ...............   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">18</span>: t_strm_reassem_holes</span><br><span class="line"><span class="number">12</span>/<span class="number">25</span> Test #<span class="number">18</span>: t_strm_reassem_holes .............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">19</span>: t_strm_reassem_many</span><br><span class="line"><span class="number">13</span>/<span class="number">25</span> Test #<span class="number">19</span>: t_strm_reassem_many ..............   Passed    <span class="number">0.13</span> sec</span><br><span class="line">      Start <span class="number">20</span>: t_strm_reassem_overlapping</span><br><span class="line"><span class="number">14</span>/<span class="number">25</span> Test #<span class="number">20</span>: t_strm_reassem_overlapping .......   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">21</span>: t_strm_reassem_win</span><br><span class="line"><span class="number">15</span>/<span class="number">25</span> Test #<span class="number">21</span>: t_strm_reassem_win ...............   Passed    <span class="number">0.12</span> sec</span><br><span class="line">      Start <span class="number">22</span>: t_strm_reassem_cap</span><br><span class="line"><span class="number">16</span>/<span class="number">25</span> Test #<span class="number">22</span>: t_strm_reassem_cap ...............   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">23</span>: t_byte_stream_construction</span><br><span class="line"><span class="number">17</span>/<span class="number">25</span> Test #<span class="number">23</span>: t_byte_stream_construction .......   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">24</span>: t_byte_stream_one_write</span><br><span class="line"><span class="number">18</span>/<span class="number">25</span> Test #<span class="number">24</span>: t_byte_stream_one_write ..........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">25</span>: t_byte_stream_two_writes</span><br><span class="line"><span class="number">19</span>/<span class="number">25</span> Test #<span class="number">25</span>: t_byte_stream_two_writes .........   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">26</span>: t_byte_stream_capacity</span><br><span class="line"><span class="number">20</span>/<span class="number">25</span> Test #<span class="number">26</span>: t_byte_stream_capacity ...........   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">27</span>: t_byte_stream_many_writes</span><br><span class="line"><span class="number">21</span>/<span class="number">25</span> Test #<span class="number">27</span>: t_byte_stream_many_writes ........   Passed    <span class="number">0.01</span> sec</span><br><span class="line">      Start <span class="number">28</span>: t_webget</span><br><span class="line"><span class="number">22</span>/<span class="number">25</span> Test #<span class="number">28</span>: t_webget .........................   Passed    <span class="number">0.50</span> sec</span><br><span class="line">      Start <span class="number">48</span>: t_address_dt</span><br><span class="line"><span class="number">23</span>/<span class="number">25</span> Test #<span class="number">48</span>: t_address_dt .....................   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">49</span>: t_parser_dt</span><br><span class="line"><span class="number">24</span>/<span class="number">25</span> Test #<span class="number">49</span>: t_parser_dt ......................   Passed    <span class="number">0.00</span> sec</span><br><span class="line">      Start <span class="number">50</span>: t_socket_dt</span><br><span class="line"><span class="number">25</span>/<span class="number">25</span> Test #<span class="number">50</span>: t_socket_dt ......................   Passed    <span class="number">0.01</span> sec</span><br><span class="line"></span><br><span class="line"><span class="number">100</span>% tests passed, <span class="number">0</span> tests failed out of <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="function">Total Test <span class="title">time</span> <span class="params">(real)</span> </span>=   <span class="number">0.98</span> sec</span><br><span class="line">[<span class="number">100</span>%] Built target check_lab2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-2-the-tcp-receiver&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-2-the-tcp-receiver&quot;&gt;#&lt;/a&gt; Lab 2: the TCP receiver&lt;/h1&gt;
&lt;p&gt;在 Lab2，我们将</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
    <category term="TCP" scheme="https://flowerhai.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CS144- 太可恶了!</title>
    <link href="https://flowerhai.github.io/2023/05/08/cs144/css144/"/>
    <id>https://flowerhai.github.io/2023/05/08/cs144/css144/</id>
    <published>2023-05-08T04:08:07.000Z</published>
    <updated>2023-05-09T08:54:04.643Z</updated>
    
    <content type="html"><![CDATA[<p>强烈声讨</p><p>CS144lab2cmake文件</p><p>库文件写错了，一直只会给出not found</p><p>搞得我还以为自己没安装成功</p><p>头痛一上午</p><p>寻找了各种方法</p><p>mmp</p><p>最后忍不了了直接查看cmake文件</p><p>好啊</p><p>原来是你在那个地方一直给了一个not found</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;强烈声讨&lt;/p&gt;
&lt;p&gt;CS144lab2cmake文件&lt;/p&gt;
&lt;p&gt;库文件写错了，一直只会给出not found&lt;/p&gt;
&lt;p&gt;搞得我还以为自己没安装成功&lt;/p&gt;
&lt;p&gt;头痛一上午&lt;/p&gt;
&lt;p&gt;寻找了各种方法&lt;/p&gt;
&lt;p&gt;mmp&lt;/p&gt;
&lt;p&gt;最后忍不了了直接查看c</summary>
      
    
    
    
    
    <category term="CS144" scheme="https://flowerhai.github.io/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>new-malloc-free-delete</title>
    <link href="https://flowerhai.github.io/2023/05/07/c-basic/new-malloc/"/>
    <id>https://flowerhai.github.io/2023/05/07/c-basic/new-malloc/</id>
    <published>2023-05-07T13:44:07.000Z</published>
    <updated>2023-05-07T13:44:55.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-delete"><a class="markdownIt-Anchor" href="#new-delete">#</a> new delete</h3><h3 id="new-和malloc的区别"><a class="markdownIt-Anchor" href="#new-和malloc的区别">#</a> new 和 malloc 的区别</h3><p>new 不仅可以开辟内存还可以初始化</p><p>malloc 开辟内存失败，是通过返回值和 nullptr 做比较的；而 new 开辟内存失败，是通过抛出 bad_alloc 类型的异常来判断的。</p><h3 id="delete和free的区别"><a class="markdownIt-Anchor" href="#delete和free的区别">#</a> delete 和 free 的区别</h3><p>malloc 和 free，C 的库函数</p><p>new 和 delete 运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">*p =<span class="number">20</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure><p>关于 delete 数组的时候</p><p>需要 delete [] p</p><p>如果不加的话只删第一个 (<strong>why?</strong>)</p><p>数组是一片连续的内存，释放时候你传递的数组名，也仅是一个指针，。<br>C++ 规定，delete p 时，仅删除指针指向的第一块内存。<br>delete [] p 才能把指针指向的一片连续内存都删除，因为在底层有一个变量，保存着需要删除的对象的数目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-delete&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#new-delete&quot;&gt;#&lt;/a&gt; new delete&lt;/h3&gt;
&lt;h3 id=&quot;new-和malloc的区别&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    
    <category term="C++基础" scheme="https://flowerhai.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>刷题day21</title>
    <link href="https://flowerhai.github.io/2023/05/07/shuati/day21/"/>
    <id>https://flowerhai.github.io/2023/05/07/shuati/day21/</id>
    <published>2023-05-07T12:59:45.000Z</published>
    <updated>2023-05-07T13:00:11.024Z</updated>
    
    <content type="html"><![CDATA[<p>今天是贪心专题 KMP 暂且缓缓 调试 lab1 花了太久太久</p><h3 id="贪心本质局部最优推出全局最优"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优">#</a> 贪心本质：局部最优推出全局最优。</h3><h4 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干">#</a> <a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子  <code>i</code> ，都有一个胃口值  <code>g[i]</code> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干  <code>j</code> ，都有一个尺寸  <code>s[j]</code>  。如果  <code>s[j] &gt;= g[i]</code> ，我们可以将这个饼干  <code>j</code>  分配给孩子  <code>i</code>  ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gl = <span class="number">0</span>, sl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (gl &lt; g.<span class="built_in">size</span>() &amp;&amp; sl &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sl] &gt;= g[gl]) &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">                gl ++;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sl ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="376-摆动序列"><a class="markdownIt-Anchor" href="#376-摆动序列">#</a> <a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 ** 摆动序列 。** 第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如，  <code>[1, 7, 4, 9, 2, 5]</code>  是一个 <strong>摆动序列</strong> ，因为差值  <code>(6, -3, 5, -7, 3)</code>  是正负交替出现的。</li><li>相反， <code>[1, 4, 7, 2, 5]</code>  和  <code>[1, 7, 4, 5, 5]</code>  不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组  <code>nums</code>  ，返回  <code>nums</code>  中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p>这题可以用 DP，当然今天是贪心专题，贪心做法就是去掉连续上升值中然后制造峰值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201126%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E5%91%A8">https://www.programmercarl.com/ 周总结 / 20201126 贪心周末总结.html# 周</a></p><h3 id="贪心本质局部最优推出全局最优-2"><a class="markdownIt-Anchor" href="#贪心本质局部最优推出全局最优-2">#</a> 贪心本质：局部最优推出全局最优。</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是贪心专题 KMP 暂且缓缓 调试 lab1 花了太久太久&lt;/p&gt;
&lt;h3 id=&quot;贪心本质局部最优推出全局最优&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#贪心本质局部最优推出全局最优&quot;&gt;#&lt;/a&gt; 贪心本质：局部最优推出全局最优。&lt;/h</summary>
      
    
    
    
    
    <category term="lc" scheme="https://flowerhai.github.io/tags/lc/"/>
    
  </entry>
  
</feed>
